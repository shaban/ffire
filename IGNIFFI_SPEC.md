# igniffi - Micro ffire C API

**igniffi** (/'ɪɡnɪfaɪ/) - The minimal, arena-based C API for ffire

> **igni** (Latin: fire, spark) + **ffi** (Foreign Function Interface)

A lightweight C API inspired by upb (μpb) that enables zero-copy, high-performance ffire bindings for dynamic languages.

---

## Design Philosophy

### Core Principles

1. **Minimal API surface** - ~15 core functions, rest is generated
2. **Arena-based memory** - Single allocation, single free
3. **Typed structs** - Not generic messages (unlike upb)
4. **Zero-copy strings** - StringView (pointer + length)
5. **Direct field access** - Generated inline functions, no reflection overhead
6. **Language-agnostic** - Works with Python, PHP, JavaScript, Ruby, etc.

### Inspiration from upb

**What we adopt:**
- ✅ Arena memory management pattern
- ✅ Lazy wrapper object approach for language bindings
- ✅ StringView for zero-copy strings
- ✅ Single arena free for entire message tree

**What we improve:**
- ✅ Typed structs instead of generic `upb_Message*`
- ✅ Simpler API (ffire's wire format is simpler than protobuf)
- ✅ Direct field access (no reflection needed at runtime)
- ✅ Smaller code size (no descriptor tables, no JIT compiler needed)

---

## Core C API

### 1. Arena Management

```c
// igniffi_arena.h

typedef struct igniffi_Arena igniffi_Arena;

// Create a new arena
igniffi_Arena* igniffi_arena_new(void);

// Free an arena and all memory allocated within it
void igniffi_arena_free(igniffi_Arena* arena);

// Get arena statistics (optional, for debugging)
typedef struct {
    size_t bytes_allocated;
    size_t num_blocks;
} igniffi_ArenaStats;

igniffi_ArenaStats igniffi_arena_stats(const igniffi_Arena* arena);
```

### 2. Core Types

```c
// igniffi_types.h

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// String view (zero-copy, no null terminator)
typedef struct {
    const char* data;
    size_t size;
} igniffi_StringView;

// Helper to create StringView from C string
static inline igniffi_StringView igniffi_stringview(const char* str) {
    igniffi_StringView sv;
    sv.data = str;
    sv.size = str ? strlen(str) : 0;
    return sv;
}

// Helper to copy StringView to arena
igniffi_StringView igniffi_stringview_copy(igniffi_StringView src, 
                                           igniffi_Arena* arena);

// Helper to create null-terminated C string from StringView (allocates in arena)
const char* igniffi_stringview_to_cstr(igniffi_StringView sv, 
                                       igniffi_Arena* arena);
```

### 3. Schema Management (Optional)

```c
// igniffi_schema.h

typedef struct igniffi_Schema igniffi_Schema;

// Load schema from embedded data (generated)
const igniffi_Schema* igniffi_schema_for_complex(void);

// Or load from file (if dynamic schema loading is needed)
igniffi_Schema* igniffi_schema_from_file(const char* path);
void igniffi_schema_free(igniffi_Schema* schema);
```

### 4. Encode/Decode (Generic)

```c
// igniffi_wire.h

// Error handling
typedef struct {
    bool ok;
    const char* message;  // Borrowed string, valid until next error
} igniffi_Status;

// Generic decode (rarely used directly - generated wrappers preferred)
void* igniffi_decode(const uint8_t* data, size_t len,
                     const igniffi_Schema* schema,
                     igniffi_Arena* arena,
                     igniffi_Status* status);

// Generic encode (rarely used directly - generated wrappers preferred)
uint8_t* igniffi_encode(const void* msg,
                        const igniffi_Schema* schema,
                        size_t* out_len,
                        igniffi_Arena* arena,
                        igniffi_Status* status);

// Convenience: decode and return ownership of arena
typedef struct {
    void* message;          // Decoded message (type-erased)
    igniffi_Arena* arena;  // Arena owning the message
    igniffi_Status status;
} igniffi_DecodeResult;

igniffi_DecodeResult igniffi_decode_owned(const uint8_t* data, size_t len,
                                          const igniffi_Schema* schema);
```

---

## Generated Code (Per Schema)

### Example: complex.ffi

**Schema:**
```ffi
package test

struct Parameter {
    DisplayName: string,
    DefaultValue: float32,
    CurrentValue: float32,
    Address: int32,
}

struct Plugin {
    Name: string,
    ManufacturerID: string,
    Parameters: []Parameter,
}

type PluginList = []Plugin
```

**Generated C Header (igniffi_complex.h):**

```c
// Code generated by ffire - DO NOT EDIT

#ifndef IGNIFFI_COMPLEX_H
#define IGNIFFI_COMPLEX_H

#include "igniffi.h"

// Struct definitions (stored directly in arena)
typedef struct igniffi_Parameter {
    igniffi_StringView display_name;
    float default_value;
    float current_value;
    int32_t address;
} igniffi_Parameter;

typedef struct igniffi_Plugin {
    igniffi_StringView name;
    igniffi_StringView manufacturer_id;
    igniffi_Parameter* parameters;  // Array stored in arena
    uint16_t parameters_len;        // Array length
} igniffi_Plugin;

typedef struct igniffi_PluginList {
    igniffi_Plugin* items;  // Array stored in arena
    uint16_t len;           // Array length
} igniffi_PluginList;

// ============================================================================
// Decode Functions
// ============================================================================

// Decode PluginList message
igniffi_PluginList* igniffi_decode_plugin_list(const uint8_t* data, 
                                                size_t len,
                                                igniffi_Arena* arena,
                                                igniffi_Status* status);

// Convenience: decode with owned arena
static inline igniffi_DecodeResult igniffi_decode_plugin_list_owned(
    const uint8_t* data, size_t len) {
    igniffi_DecodeResult result;
    result.arena = igniffi_arena_new();
    result.message = igniffi_decode_plugin_list(data, len, result.arena, 
                                                 &result.status);
    return result;
}

// ============================================================================
// Encode Functions
// ============================================================================

// Encode PluginList message
uint8_t* igniffi_encode_plugin_list(const igniffi_PluginList* msg,
                                     size_t* out_len,
                                     igniffi_Arena* arena,
                                     igniffi_Status* status);

// ============================================================================
// Field Accessors (inline - zero overhead)
// ============================================================================

// Parameter accessors
static inline igniffi_StringView igniffi_parameter_get_display_name(
    const igniffi_Parameter* p) {
    return p->display_name;
}

static inline void igniffi_parameter_set_display_name(
    igniffi_Parameter* p, igniffi_StringView val, igniffi_Arena* arena) {
    p->display_name = igniffi_stringview_copy(val, arena);
}

static inline float igniffi_parameter_get_default_value(
    const igniffi_Parameter* p) {
    return p->default_value;
}

static inline void igniffi_parameter_set_default_value(
    igniffi_Parameter* p, float val) {
    p->default_value = val;
}

// Plugin accessors
static inline igniffi_StringView igniffi_plugin_get_name(
    const igniffi_Plugin* p) {
    return p->name;
}

static inline void igniffi_plugin_set_name(
    igniffi_Plugin* p, igniffi_StringView val, igniffi_Arena* arena) {
    p->name = igniffi_stringview_copy(val, arena);
}

static inline uint16_t igniffi_plugin_get_parameters_len(
    const igniffi_Plugin* p) {
    return p->parameters_len;
}

static inline const igniffi_Parameter* igniffi_plugin_get_parameter(
    const igniffi_Plugin* p, uint16_t index) {
    if (index >= p->parameters_len) return NULL;
    return &p->parameters[index];
}

static inline igniffi_Parameter* igniffi_plugin_get_mutable_parameter(
    igniffi_Plugin* p, uint16_t index) {
    if (index >= p->parameters_len) return NULL;
    return &p->parameters[index];
}

// PluginList accessors
static inline uint16_t igniffi_plugin_list_len(
    const igniffi_PluginList* list) {
    return list->len;
}

static inline const igniffi_Plugin* igniffi_plugin_list_get(
    const igniffi_PluginList* list, uint16_t index) {
    if (index >= list->len) return NULL;
    return &list->items[index];
}

static inline igniffi_Plugin* igniffi_plugin_list_get_mutable(
    igniffi_PluginList* list, uint16_t index) {
    if (index >= list->len) return NULL;
    return &list->items[index];
}

// ============================================================================
// Builder Functions (mutable construction)
// ============================================================================

// Create new PluginList with capacity
igniffi_PluginList* igniffi_plugin_list_new(uint16_t capacity, 
                                             igniffi_Arena* arena);

// Add plugin to list (grows if needed)
bool igniffi_plugin_list_add(igniffi_PluginList* list,
                              const igniffi_Plugin* plugin,
                              igniffi_Arena* arena);

// Create new Plugin
igniffi_Plugin* igniffi_plugin_new(igniffi_Arena* arena);

// Add parameter to plugin
bool igniffi_plugin_add_parameter(igniffi_Plugin* plugin,
                                   const igniffi_Parameter* param,
                                   igniffi_Arena* arena);

#endif // IGNIFFI_COMPLEX_H
```

---

## Python Integration Example

```python
# igniffi_complex.py (generated)

import ctypes
from typing import List, Optional

# Load shared library
_lib = ctypes.CDLL("libigniffi_complex.so")

# ============================================================================
# Core Types
# ============================================================================

class Arena:
    def __init__(self):
        self._ptr = _lib.igniffi_arena_new()
    
    def __del__(self):
        if self._ptr:
            _lib.igniffi_arena_free(self._ptr)
            self._ptr = None

class StringView(ctypes.Structure):
    _fields_ = [("data", ctypes.c_char_p), ("size", ctypes.c_size_t)]

# ============================================================================
# Message Classes
# ============================================================================

class Parameter:
    """Lazy wrapper around C struct"""
    def __init__(self, ptr, arena):
        self._ptr = ptr  # igniffi_Parameter*
        self._arena = arena  # Keep arena alive
    
    @property
    def display_name(self) -> str:
        sv = _lib.igniffi_parameter_get_display_name(self._ptr)
        return sv.data[:sv.size].decode('utf-8')
    
    @display_name.setter
    def display_name(self, value: str):
        utf8 = value.encode('utf-8')
        if len(utf8) > 65535:
            raise ValueError(f"String too long: {len(utf8)} bytes")
        sv = StringView(utf8, len(utf8))
        _lib.igniffi_parameter_set_display_name(self._ptr, sv, self._arena._ptr)
    
    @property
    def default_value(self) -> float:
        return _lib.igniffi_parameter_get_default_value(self._ptr)
    
    @default_value.setter
    def default_value(self, value: float):
        _lib.igniffi_parameter_set_default_value(self._ptr, ctypes.c_float(value))

class Plugin:
    """Lazy wrapper around C struct"""
    def __init__(self, ptr, arena):
        self._ptr = ptr  # igniffi_Plugin*
        self._arena = arena
    
    @property
    def name(self) -> str:
        sv = _lib.igniffi_plugin_get_name(self._ptr)
        return sv.data[:sv.size].decode('utf-8')
    
    @name.setter
    def name(self, value: str):
        utf8 = value.encode('utf-8')
        if len(utf8) > 65535:
            raise ValueError(f"String too long: {len(utf8)} bytes")
        sv = StringView(utf8, len(utf8))
        _lib.igniffi_plugin_set_name(self._ptr, sv, self._arena._ptr)
    
    @property
    def parameters(self) -> 'ParameterList':
        return ParameterList(self._ptr, self._arena)

class ParameterList:
    """Lazy array wrapper"""
    def __init__(self, plugin_ptr, arena):
        self._plugin_ptr = plugin_ptr
        self._arena = arena
    
    def __len__(self) -> int:
        return _lib.igniffi_plugin_get_parameters_len(self._plugin_ptr)
    
    def __getitem__(self, index: int) -> Parameter:
        if index < 0 or index >= len(self):
            raise IndexError(f"Index {index} out of range")
        param_ptr = _lib.igniffi_plugin_get_parameter(self._plugin_ptr, index)
        return Parameter(param_ptr, self._arena)

class PluginList:
    """Root message wrapper"""
    def __init__(self, ptr, arena):
        self._ptr = ptr  # igniffi_PluginList*
        self._arena = arena
    
    def __len__(self) -> int:
        return _lib.igniffi_plugin_list_len(self._ptr)
    
    def __getitem__(self, index: int) -> Plugin:
        if index < 0 or index >= len(self):
            raise IndexError(f"Index {index} out of range")
        plugin_ptr = _lib.igniffi_plugin_list_get(self._ptr, index)
        return Plugin(plugin_ptr, self._arena)

# ============================================================================
# Public API
# ============================================================================

def decode(data: bytes) -> PluginList:
    """Decode wire format to PluginList"""
    arena = Arena()
    status = Status()
    
    msg_ptr = _lib.igniffi_decode_plugin_list(
        data, len(data), arena._ptr, ctypes.byref(status))
    
    if not status.ok:
        raise ValueError(f"Decode failed: {status.message}")
    
    return PluginList(msg_ptr, arena)

def encode(msg: PluginList) -> bytes:
    """Encode PluginList to wire format"""
    out_len = ctypes.c_size_t()
    status = Status()
    
    data_ptr = _lib.igniffi_encode_plugin_list(
        msg._ptr, ctypes.byref(out_len), msg._arena._ptr, ctypes.byref(status))
    
    if not status.ok:
        raise ValueError(f"Encode failed: {status.message}")
    
    return bytes(ctypes.string_at(data_ptr, out_len.value))

# ============================================================================
# Usage Example
# ============================================================================

if __name__ == "__main__":
    # Decode
    wire_data = open("fixture.bin", "rb").read()
    plugin_list = decode(wire_data)
    
    # Access (lazy - only creates Python objects when accessed)
    print(f"Plugin count: {len(plugin_list)}")
    
    for plugin in plugin_list:
        print(f"Plugin: {plugin.name}")
        for param in plugin.parameters:
            print(f"  - {param.display_name}: {param.default_value}")
    
    # Encode
    wire_data2 = encode(plugin_list)
    assert wire_data == wire_data2
```

---

## Performance Characteristics

### Memory Layout

```
Python Process:
┌─────────────────┐
│ PluginList obj  │ (24 bytes: ptr + arena ref)
└────────┬────────┘
         │ owns
         ▼
┌─────────────────┐
│  Arena (Python) │ (16 bytes: wrapper)
└────────┬────────┘
         │ wraps
         ▼
┌─────────────────┐
│ igniffi_Arena   │ (C memory pool)
│   (C struct)    │
└────────┬────────┘
         │ owns (single allocation)
         ▼
┌─────────────────┐
│  PluginList     │ (8 bytes: ptr + len)
│  Plugin[0]      │ (32 bytes: 2 strings + array ptr + len)
│  Plugin[1]      │ (32 bytes)
│  Parameter[0]   │ (24 bytes: string + 3 floats)
│  Parameter[1]   │ (24 bytes)
│  String data... │ (variable)
└─────────────────┘

Total Python overhead: ~40 bytes
All data in C arena: ~kilobytes
```

### Access Patterns

```python
# Lazy access - only materializes what's needed
for plugin in plugin_list:  # No objects created yet
    name = plugin.name      # Creates 1 Python str (copies from C)
    # plugin.parameters not accessed → no Parameter objects created!
```

### Expected Performance

**vs Pure Python:**
- Decode: 5-10x faster
- Access: 2-3x faster (after decode, cached)
- Memory: 10x less (most data in C arena)

**vs C++ interop (Swift):**
- Decode: 20-30% faster (no ARC overhead, no std::vector copying)
- Access: Similar (both are pointer + field access)
- Memory: Similar (both arena-based)

**vs upb:**
- Decode: Similar (both arena-based)
- Access: Slightly faster (typed structs vs reflection)
- Code size: 50% smaller (no descriptor tables, no JIT)

---

## Next Steps

1. **Core C implementation** (~500 lines)
   - Arena allocator
   - StringView helpers
   - Status/error handling

2. **Code generator updates** (~200 lines of Go)
   - Generate igniffi struct definitions
   - Generate inline accessor functions
   - Generate builder functions

3. **Python bindings generator** (~300 lines)
   - ctypes declarations
   - Lazy wrapper classes
   - Property accessors with validation

4. **Benchmarks** (reuse existing)
   - Compare igniffi vs C++ interop for Swift
   - Measure Python/PHP/JS performance

Sound good? Want me to start with the core C implementation?
