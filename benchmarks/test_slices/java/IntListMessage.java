// Code generated by ffire. DO NOT EDIT.

package test;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;


// ByteSlice is a Go-like slice for byte using off-heap memory
class ByteSlice {
    private static final int ELEMENT_SIZE = 1;
    private java.nio.ByteBuffer buffer;
    private java.nio.ByteBuffer view;
    private int length;
    private int capacity;

    public ByteSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asByteBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public byte get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, byte value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(byte value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asByteBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        ByteSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asByteSliceBuffer().put(arr[i]);
        }
    }

    static ByteSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Byte slice = new byte(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            byte[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}

// ShortSlice is a Go-like slice for short using off-heap memory
class ShortSlice {
    private static final int ELEMENT_SIZE = 2;
    private java.nio.ByteBuffer buffer;
    private java.nio.ShortBuffer view;
    private int length;
    private int capacity;

    public ShortSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asShortBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public short get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, short value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(short value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asShortBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        ShortSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asShortSliceBuffer().put(arr[i]);
        }
    }

    static ShortSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Short slice = new short(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            short[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}

// IntSlice is a Go-like slice for int using off-heap memory
class IntSlice {
    private static final int ELEMENT_SIZE = 4;
    private java.nio.ByteBuffer buffer;
    private java.nio.IntBuffer view;
    private int length;
    private int capacity;

    public IntSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asIntBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public int get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, int value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(int value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asIntBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        IntSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asIntSliceBuffer().put(arr[i]);
        }
    }

    static IntSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Int slice = new int(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            int[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}

// LongSlice is a Go-like slice for long using off-heap memory
class LongSlice {
    private static final int ELEMENT_SIZE = 8;
    private java.nio.ByteBuffer buffer;
    private java.nio.LongBuffer view;
    private int length;
    private int capacity;

    public LongSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asLongBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public long get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, long value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(long value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asLongBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        LongSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asLongSliceBuffer().put(arr[i]);
        }
    }

    static LongSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Long slice = new long(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            long[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}

// FloatSlice is a Go-like slice for float using off-heap memory
class FloatSlice {
    private static final int ELEMENT_SIZE = 4;
    private java.nio.ByteBuffer buffer;
    private java.nio.FloatBuffer view;
    private int length;
    private int capacity;

    public FloatSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asFloatBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public float get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, float value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(float value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asFloatBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        FloatSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asFloatSliceBuffer().put(arr[i]);
        }
    }

    static FloatSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Float slice = new float(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            float[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}

// DoubleSlice is a Go-like slice for double using off-heap memory
class DoubleSlice {
    private static final int ELEMENT_SIZE = 8;
    private java.nio.ByteBuffer buffer;
    private java.nio.DoubleBuffer view;
    private int length;
    private int capacity;

    public DoubleSlice(int capacity) {
        this.capacity = capacity;
        this.buffer = java.nio.ByteBuffer.allocate(capacity * ELEMENT_SIZE);
        this.buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        this.view = buffer.asDoubleBuffer();
        this.length = 0;
    }

    public int len() {
        return length;
    }

    public int cap() {
        return capacity;
    }

    public double get(int index) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        return view.get(index);
    }

    public void set(int index, double value) {
        if (index < 0 || index >= length) {
            throw new IndexOutOfBoundsException("index " + index + " out of bounds for length " + length);
        }
        view.put(index, value);
    }

    public void append(double value) {
        if (length == capacity) {
            grow();
        }
        view.put(length, value);
        length++;
    }

    private void grow() {
        int newCapacity = capacity == 0 ? 8 : capacity * 2;
        java.nio.ByteBuffer newBuffer = java.nio.ByteBuffer.allocate(newCapacity * ELEMENT_SIZE);
        newBuffer.order(java.nio.ByteOrder.LITTLE_ENDIAN);
        
        // Copy existing data
        buffer.rewind();
        buffer.limit(length * ELEMENT_SIZE);
        newBuffer.put(buffer);
        
        this.buffer = newBuffer;
        this.view = newBuffer.asDoubleBuffer();
        this.capacity = newCapacity;
    }

    // Bulk operations for serialization
    void encodeTo(java.nio.ByteBuffer buf) {
        DoubleSlice[] arr = view.array();
        for (int i = 0; i < length; i++) {
            buf.asDoubleSliceBuffer().put(arr[i]);
        }
    }

    static DoubleSlice decodeFrom(java.nio.ByteBuffer buf, int length) {
        Double slice = new double(length);
        slice.length = length;
        if (length > 0) {
            int pos = buf.position();
            double[] arr = slice.view.array();
            buf.as%!s(MISSING)Buffer().get(arr, 0, length);
            buf.position(pos + length * ELEMENT_SIZE);
        }
        return slice;
    }
}
public class IntListMessage {
    public List<Integer> items;

    public IntListMessage() {
        items = new ArrayList<>();
    }

    public byte[] encode() {
        ByteBuffer buf = ByteBuffer.allocate(computeSize());
        buf.order(ByteOrder.LITTLE_ENDIAN);
        encodeTo(buf);
        return buf.array();
    }

    public static IntListMessage decode(byte[] data) {
        ByteBuffer buf = ByteBuffer.wrap(data);
        buf.order(ByteOrder.LITTLE_ENDIAN);
        IntListMessage obj = new IntListMessage();
        obj.decodeFrom(buf);
        return obj;
    }

    int computeSize() {
        int size = 2; // array length prefix
        size += items.size() * 4;
        return size;
    }

    void encodeTo(ByteBuffer buf) {
        buf.putShort((short) items.size());
        for (var elem : items) {
            buf.putInt(elem);
        }
    }

    void decodeFrom(ByteBuffer buf) {
        int count = buf.getShort() & 0xFFFF;
        items = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            int elem = buf.getInt();
            items.add(elem);
        }
    }

}

