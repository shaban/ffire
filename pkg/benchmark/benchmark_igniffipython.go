package benchmark

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/ffire/pkg/fixture"
	"github.com/shaban/ffire/pkg/generator"
	"github.com/shaban/ffire/pkg/schema"
)

// GenerateIgniffiPython generates a Python benchmark using CFFI bindings
func GenerateIgniffiPython(schema *schema.Schema, schemaName, messageName string, jsonData []byte, outputDir string, iterations int) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Step 1: Generate the Python package with igniffi bindings
	config := &generator.PackageConfig{
		Schema:    schema,
		Language:  "igniffi-python",
		OutputDir: outputDir,
		Namespace: schema.Package,
		Optimize:  2,
		Platform:  "current",
		Arch:      "current",
		NoCompile: true, // Don't compile yet - user needs to pip install
		Verbose:   false,
	}

	if err := generator.GenerateIgniffiPythonPackage(config); err != nil {
		return fmt.Errorf("failed to generate Python package: %w", err)
	}

	// Step 2: Convert JSON to binary fixture
	binaryData, err := fixture.Convert(schema, messageName, jsonData)
	if err != nil {
		return fmt.Errorf("failed to convert JSON to binary: %w", err)
	}

	// Step 3: Write the binary fixture
	pyDir := filepath.Join(outputDir, "python")
	fixturePath := filepath.Join(pyDir, "fixture.bin")
	if err := os.WriteFile(fixturePath, binaryData, 0644); err != nil {
		return fmt.Errorf("failed to write fixture: %w", err)
	}

	// Step 4: Generate the benchmark harness
	pkgName := toPythonIdentifier(schema.Package)
	benchmarkCode := generateIgniffiPythonBenchmarkCode(pkgName, messageName, iterations)
	benchPath := filepath.Join(pyDir, "bench.py")
	if err := os.WriteFile(benchPath, []byte(benchmarkCode), 0755); err != nil {
		return fmt.Errorf("failed to write benchmark: %w", err)
	}

	// Step 5: Generate run script
	runScript := generateIgniffiPythonRunScript()
	runPath := filepath.Join(pyDir, "run.sh")
	if err := os.WriteFile(runPath, []byte(runScript), 0755); err != nil {
		return fmt.Errorf("failed to write run script: %w", err)
	}

	return nil
}

func generateIgniffiPythonBenchmarkCode(pkgName, messageName string, iterations int) string {
	buf := &bytes.Buffer{}

	// Add Message suffix to class name
	className := messageName + "Message"

	fmt.Fprintf(buf, `#!/usr/bin/env python3
# Code generated by ffire. DO NOT EDIT.
# igniffi Python benchmark using CFFI

import os
import sys
import time
import json

# Import the generated package
from %s import %s


def main():
    # Load fixture
    script_dir = os.path.dirname(os.path.abspath(__file__))
    fixture_path = os.path.join(script_dir, 'fixture.bin')
    
    with open(fixture_path, 'rb') as f:
        fixture_data = f.read()
    
    iterations = %d
    json_output = os.environ.get('BENCH_JSON') == '1'
    
    # Warmup
    for _ in range(1000):
        msg = %s.decode(fixture_data)
        encoded = msg.encode()
        msg.dispose()
    
    # Benchmark decode
    decode_start = time.perf_counter_ns()
    for _ in range(iterations):
        msg = %s.decode(fixture_data)
        msg.dispose()
    decode_end = time.perf_counter_ns()
    decode_time_ns = decode_end - decode_start
    
    # Benchmark encode (decode once, then encode many times)
    msg = %s.decode(fixture_data)
    encode_start = time.perf_counter_ns()
    for _ in range(iterations):
        encoded = msg.encode()
    encode_end = time.perf_counter_ns()
    encode_time_ns = encode_end - encode_start
    
    msg.dispose()
    
    # Calculate metrics
    encode_ns = encode_time_ns // iterations
    decode_ns = decode_time_ns // iterations
    total_ns = encode_ns + decode_ns
    
    if json_output:
        # Output JSON for automation
        result = {
            'language': 'Python',
            'format': 'ffire',
            'message': '%s',
            'iterations': iterations,
            'encode_ns': encode_ns,
            'decode_ns': decode_ns,
            'total_ns': total_ns,
            'wire_size': len(encoded),
            'fixture_size': len(fixture_data),
            'timestamp': time.strftime('%%Y-%%m-%%dT%%H:%%M:%%SZ', time.gmtime())
        }
        print(json.dumps(result))
    else:
        # Print human-readable results
        print('ffire benchmark: %s')
        print(f'Iterations:  {iterations}')
        print(f'Encode:      {encode_ns} ns/op')
        print(f'Decode:      {decode_ns} ns/op')
        print(f'Total:       {total_ns} ns/op')
        print(f'Wire size:   {len(encoded)} bytes')
        print(f'Fixture:     {len(fixture_data)} bytes')
        print(f'Total time:  {(encode_time_ns + decode_time_ns) / 1e9:.3f}s')


if __name__ == '__main__':
    main()
`, pkgName, className, iterations, className, className, className, messageName, messageName)

	return buf.String()
}

func generateIgniffiPythonRunScript() string {
	return `#!/bin/bash
# Convenience script to run Python benchmark

# Check if python3 is available
if ! command -v python3 &> /dev/null; then
    echo "Error: python3 not found"
    exit 1
fi

# Install the package if not already installed
pip3 install -e . --quiet 2>/dev/null || pip3 install -e . --quiet --user

# Run benchmark
python3 bench.py "$@"
`
}

// toPythonIdentifier converts a name to a valid Python identifier
func toPythonIdentifier(name string) string {
	var result bytes.Buffer
	for i, r := range name {
		if r >= 'A' && r <= 'Z' {
			if i > 0 {
				result.WriteRune('_')
			}
			result.WriteRune(r + 32) // lowercase
		} else if r == '-' {
			result.WriteRune('_')
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}
