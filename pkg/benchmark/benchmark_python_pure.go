package benchmark

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/ffire/pkg/fixture"
	"github.com/shaban/ffire/pkg/generator"
	"github.com/shaban/ffire/pkg/schema"
)

// GeneratePythonPure generates a Pure Python benchmark with embedded fixture
func GeneratePythonPure(schema *schema.Schema, schemaName, messageName string, jsonData []byte, outputDir string, iterations int) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Step 1: Generate the Pure Python package
	config := &generator.PackageConfig{
		Schema:    schema,
		Language:  "python", // Pure Python is now the default "python"
		OutputDir: outputDir,
		Namespace: schema.Package,
		Optimize:  2,
		Platform:  "current",
		Arch:      "current",
		NoCompile: true, // Pure Python - no compilation
		Verbose:   false,
	}

	if err := generator.GeneratePackage(config); err != nil {
		return fmt.Errorf("failed to generate Pure Python package: %w", err)
	}

	// Step 2: Convert JSON to binary fixture using the generated code
	binaryData, err := fixture.Convert(schema, messageName, jsonData)
	if err != nil {
		return fmt.Errorf("failed to convert JSON to binary: %w", err)
	}

	// Step 3: Write the binary fixture
	// Pure Python generates to outputDir/{package}/, not outputDir/python/{package}/
	fixturePath := filepath.Join(outputDir, "fixture.bin")
	if err := os.WriteFile(fixturePath, binaryData, 0644); err != nil {
		return fmt.Errorf("failed to write fixture: %w", err)
	}

	// Step 4: Generate the benchmark harness (same as regular Python)
	benchmarkCode := generatePythonPureBenchmarkCode(schema.Package, messageName, iterations)
	benchPath := filepath.Join(outputDir, "bench.py")
	if err := os.WriteFile(benchPath, []byte(benchmarkCode), 0644); err != nil {
		return fmt.Errorf("failed to write benchmark: %w", err)
	}

	// Step 5: Generate a run script for convenience
	runScript := `#!/bin/bash
# Run Pure Python benchmark
cd "$(dirname "$0")"
python3 bench.py
`
	runPath := filepath.Join(outputDir, "run.sh")
	if err := os.WriteFile(runPath, []byte(runScript), 0755); err != nil {
		return fmt.Errorf("failed to write run script: %w", err)
	}

	return nil
}

// generatePythonPureBenchmarkCode generates the benchmark harness code for pure Python
func generatePythonPureBenchmarkCode(packageName, messageName string, iterations int) string {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `#!/usr/bin/env python3
"""
Benchmark for %s using ffire Pure Python implementation.
Generated by ffire benchmark tool.
"""

import sys
from pathlib import Path
import time
import json
import os

# Add generated package to path
sys.path.insert(0, str(Path(__file__).parent))

# Import generated package
import %s

def benchmark():
    """Run the benchmark and print results"""
    
    # Read fixture
    fixture_path = Path(__file__).parent / 'fixture.bin'
    with open(fixture_path, 'rb') as f:
        fixture_data = f.read()
    
    # First decode to get the object
    decoded = %s.%s.decode(fixture_data)
    
    # Warmup (100 iterations)
    for _ in range(100):
        encoded = decoded.encode()
        _ = %s.%s.decode(encoded)
    
    # Benchmark encode
    encode_times = []
    for _ in range(%d):
        start = time.perf_counter()
        encoded = decoded.encode()
        encode_times.append(time.perf_counter() - start)
    
    # Benchmark decode  
    decode_times = []
    for _ in range(%d):
        start = time.perf_counter()
        result = %s.%s.decode(encoded)
        decode_times.append(time.perf_counter() - start)
    
    # Calculate statistics (nanoseconds)
    encode_ns = int((sum(encode_times) / len(encode_times)) * 1_000_000_000)
    decode_ns = int((sum(decode_times) / len(decode_times)) * 1_000_000_000)
    total_ns = encode_ns + decode_ns
    
    # Print results in JSON format for easy parsing
    results = {
        "language": "Python",
        "format": "ffire",
        "message": "%s",
        "iterations": %d,
        "encode_ns": encode_ns,
        "decode_ns": decode_ns,
        "total_ns": total_ns,
        "wire_size": len(encoded)
    }
    
    print(json.dumps(results))
    return results

if __name__ == "__main__":
    benchmark()
`, messageName, packageName, packageName, messageName, packageName, messageName,
		iterations, iterations, packageName, messageName, messageName, iterations)

	return buf.String()
}
