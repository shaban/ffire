package benchmark

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/shaban/ffire/pkg/fixture"
	"github.com/shaban/ffire/pkg/generator"
	"github.com/shaban/ffire/pkg/schema"
)

// GenerateIgniffiJS generates a JavaScript benchmark using Koffi FFI bindings
func GenerateIgniffiJS(schema *schema.Schema, schemaName, messageName string, jsonData []byte, outputDir string, iterations int) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Step 1: Generate the JavaScript package with igniffi bindings
	config := &generator.PackageConfig{
		Schema:    schema,
		Language:  "igniffi-js",
		OutputDir: outputDir,
		Namespace: schema.Package,
		Optimize:  2,
		Platform:  "current",
		Arch:      "current",
		NoCompile: false,
		Verbose:   false,
	}

	if err := generator.GenerateIgniffiJSPackage(config); err != nil {
		return fmt.Errorf("failed to generate JavaScript package: %w", err)
	}

	// Step 2: Convert JSON to binary fixture
	binaryData, err := fixture.Convert(schema, messageName, jsonData)
	if err != nil {
		return fmt.Errorf("failed to convert JSON to binary: %w", err)
	}

	// Step 3: Write the binary fixture
	jsDir := filepath.Join(outputDir, "javascript")
	fixturePath := filepath.Join(jsDir, "fixture.bin")
	if err := os.WriteFile(fixturePath, binaryData, 0644); err != nil {
		return fmt.Errorf("failed to write fixture: %w", err)
	}

	// Step 4: Generate the benchmark harness
	benchmarkCode := generateIgniffiJSBenchmarkCode(schema.Package, messageName, iterations)
	benchPath := filepath.Join(jsDir, "bench.js")
	if err := os.WriteFile(benchPath, []byte(benchmarkCode), 0644); err != nil {
		return fmt.Errorf("failed to write benchmark: %w", err)
	}

	// Step 5: Generate run script
	runScript := generateIgniffiJSRunScript()
	runPath := filepath.Join(jsDir, "run.sh")
	if err := os.WriteFile(runPath, []byte(runScript), 0755); err != nil {
		return fmt.Errorf("failed to write run script: %w", err)
	}

	return nil
}

func generateIgniffiJSBenchmarkCode(schemaName, messageName string, iterations int) string {
	buf := &bytes.Buffer{}

	// Add Message suffix to class name
	className := messageName + "Message"

	fmt.Fprintf(buf, `#!/usr/bin/env node
// Code generated by ffire. DO NOT EDIT.
// igniffi JavaScript benchmark using Koffi FFI

'use strict';

const fs = require('fs');
const { %s } = require('./index.js');

async function main() {
  // Load fixture
  const fixtureData = fs.readFileSync('fixture.bin');
  
  const iterations = %d;
  const jsonOutput = process.env.BENCH_JSON === '1';
  
  // Warmup
  for (let i = 0; i < 1000; i++) {
    const msg = %s.decode(fixtureData);
    const encoded = msg.encode();
    msg.dispose();
  }
  
  // Benchmark decode
  const decodeStart = process.hrtime.bigint();
  for (let i = 0; i < iterations; i++) {
    const msg = %s.decode(fixtureData);
    msg.dispose();
  }
  const decodeEnd = process.hrtime.bigint();
  const decodeTimeNs = Number(decodeEnd - decodeStart);
  
  // Benchmark encode (decode once, then encode many times)
  const msg = %s.decode(fixtureData);
  const encodeStart = process.hrtime.bigint();
  let encoded;
  for (let i = 0; i < iterations; i++) {
    encoded = msg.encode();
  }
  const encodeEnd = process.hrtime.bigint();
  const encodeTimeNs = Number(encodeEnd - encodeStart);
  
  msg.dispose();
  
  // Calculate metrics
  const encodeNs = Math.round(encodeTimeNs / iterations);
  const decodeNs = Math.round(decodeTimeNs / iterations);
  const totalNs = encodeNs + decodeNs;
  
  if (jsonOutput) {
    // Output JSON for automation
    const result = {
      language: 'JavaScript',
      format: 'ffire',
      message: '%s',
      iterations: iterations,
      encode_ns: encodeNs,
      decode_ns: decodeNs,
      total_ns: totalNs,
      wire_size: encoded.length,
      fixture_size: fixtureData.length,
      timestamp: new Date().toISOString()
    };
    console.log(JSON.stringify(result));
  } else {
    // Print human-readable results
    console.log('ffire benchmark: %s');
    console.log('Iterations:  ' + iterations);
    console.log('Encode:      ' + encodeNs + ' ns/op');
    console.log('Decode:      ' + decodeNs + ' ns/op');
    console.log('Total:       ' + totalNs + ' ns/op');
    console.log('Wire size:   ' + encoded.length + ' bytes');
    console.log('Fixture:     ' + fixtureData.length + ' bytes');
    console.log('Total time:  ' + ((encodeTimeNs + decodeTimeNs) / 1e9).toFixed(3) + 's');
  }
}

main().catch(err => {
  console.error('Benchmark failed:', err);
  process.exit(1);
});
`, className, iterations, className, className, className, messageName, messageName)

	return buf.String()
}

func generateIgniffiJSRunScript() string {
	return `#!/bin/bash
# Convenience script to run JavaScript benchmark

# Check if node is available
if ! command -v node &> /dev/null; then
    echo "Error: node not found"
    exit 1
fi

# Install dependencies if needed
if [ ! -d "node_modules" ]; then
    npm install
fi

# Run benchmark
node bench.js "$@"
`
}
