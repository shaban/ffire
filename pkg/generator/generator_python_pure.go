package generator

import (
	"bytes"
	"fmt"

	"github.com/shaban/ffire/pkg/schema"
)

// GeneratePythonPure generates pure Python encoder/decoder (no C++ bridge)
func GeneratePythonPure(s *schema.Schema) ([]byte, error) {
	gen := &pythonPureGenerator{
		schema: s,
		buf:    &bytes.Buffer{},
	}
	return gen.generate()
}

type pythonPureGenerator struct {
	schema *schema.Schema
	buf    *bytes.Buffer
}

func (g *pythonPureGenerator) generate() ([]byte, error) {
	g.buf.WriteString("# Code generated by ffire. DO NOT EDIT.\n")
	g.buf.WriteString("# Pure Python implementation - no native bindings\n\n")
	g.buf.WriteString("import struct\n")
	g.buf.WriteString("import array\n")
	g.buf.WriteString("from typing import Optional, List\n\n")

	// Generate encoder class
	if err := g.generateEncoder(); err != nil {
		return nil, err
	}

	// Generate decoder class
	if err := g.generateDecoder(); err != nil {
		return nil, err
	}

	// Generate classes for all struct types
	structTypes := g.collectAllStructs()
	for _, structType := range structTypes {
		if err := g.generateStructClass(structType); err != nil {
			return nil, err
		}
	}

	// Generate slice wrapper classes for top-level array messages
	sliceTypes := g.collectSliceTypes()
	for _, sliceType := range sliceTypes {
		if err := g.generateSliceClass(sliceType); err != nil {
			return nil, err
		}
	}

	// Export all struct and slice classes
	allExports := make([]string, 0, len(structTypes)+len(sliceTypes))
	for _, structType := range structTypes {
		allExports = append(allExports, structType.Name)
	}
	for _, msg := range sliceTypes {
		allExports = append(allExports, msg.Name)
	}

	if len(allExports) > 0 {
		g.buf.WriteString("\n__all__ = [\n")
		for i, name := range allExports {
			if i > 0 {
				g.buf.WriteString(",\n")
			}
			fmt.Fprintf(g.buf, "    '%s'", name)
		}
		g.buf.WriteString("\n]\n")
	}

	return g.buf.Bytes(), nil
}

func (g *pythonPureGenerator) generateEncoder() error {
	g.buf.WriteString("# Encoder - writes binary wire format using struct module\n")
	g.buf.WriteString("class Encoder:\n")
	g.buf.WriteString("    def __init__(self, estimated_size=256):\n")
	g.buf.WriteString("        self.buffer = bytearray(estimated_size)\n")
	g.buf.WriteString("        self.pos = 0\n\n")

	g.buf.WriteString("    def ensure_capacity(self, needed):\n")
	g.buf.WriteString("        if self.pos + needed > len(self.buffer):\n")
	g.buf.WriteString("            new_size = max(len(self.buffer) * 2, self.pos + needed)\n")
	g.buf.WriteString("            self.buffer.extend(bytearray(new_size - len(self.buffer)))\n\n")

	g.buf.WriteString("    def to_bytes(self):\n")
	g.buf.WriteString("        return bytes(self.buffer[:self.pos])\n\n")

	// Write primitives using struct module
	g.buf.WriteString("    def write_bool(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(1)\n")
	g.buf.WriteString("        self.buffer[self.pos] = 1 if v else 0\n")
	g.buf.WriteString("        self.pos += 1\n\n")

	g.buf.WriteString("    def write_int8(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(1)\n")
	g.buf.WriteString("        struct.pack_into('<b', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 1\n\n")

	g.buf.WriteString("    def write_int16(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(2)\n")
	g.buf.WriteString("        struct.pack_into('<h', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 2\n\n")

	g.buf.WriteString("    def write_int32(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(4)\n")
	g.buf.WriteString("        struct.pack_into('<i', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 4\n\n")

	g.buf.WriteString("    def write_int64(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(8)\n")
	g.buf.WriteString("        struct.pack_into('<q', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 8\n\n")

	g.buf.WriteString("    def write_float32(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(4)\n")
	g.buf.WriteString("        struct.pack_into('<f', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 4\n\n")

	g.buf.WriteString("    def write_float64(self, v):\n")
	g.buf.WriteString("        self.ensure_capacity(8)\n")
	g.buf.WriteString("        struct.pack_into('<d', self.buffer, self.pos, v)\n")
	g.buf.WriteString("        self.pos += 8\n\n")

	g.buf.WriteString("    def write_string(self, s):\n")
	g.buf.WriteString("        utf8 = s.encode('utf-8')\n")
	g.buf.WriteString("        self.ensure_capacity(2 + len(utf8))\n")
	g.buf.WriteString("        struct.pack_into('<H', self.buffer, self.pos, len(utf8))\n")
	g.buf.WriteString("        self.pos += 2\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+len(utf8)] = utf8\n")
	g.buf.WriteString("        self.pos += len(utf8)\n\n")

	// Bulk array writes - zero-copy using memoryview + typed arrays
	g.buf.WriteString("    def write_int8_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed int8 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'b':\n")
	g.buf.WriteString("            arr = array.array('b', arr)  # Convert to typed array\n")
	g.buf.WriteString("        byte_len = len(arr)\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')  # Zero-copy view\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("    def write_int16_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed int16 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'h':\n")
	g.buf.WriteString("            arr = array.array('h', arr)\n")
	g.buf.WriteString("        byte_len = len(arr) * 2\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("    def write_int32_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed int32 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'i':\n")
	g.buf.WriteString("            arr = array.array('i', arr)\n")
	g.buf.WriteString("        byte_len = len(arr) * 4\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("    def write_int64_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed int64 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'q':\n")
	g.buf.WriteString("            arr = array.array('q', arr)\n")
	g.buf.WriteString("        byte_len = len(arr) * 8\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("    def write_float32_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed float32 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'f':\n")
	g.buf.WriteString("            arr = array.array('f', arr)\n")
	g.buf.WriteString("        byte_len = len(arr) * 4\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("    def write_float64_array(self, arr):\n")
	g.buf.WriteString("        \"\"\"Zero-copy write for typed float64 array\"\"\"\n")
	g.buf.WriteString("        if not isinstance(arr, array.array) or arr.typecode != 'd':\n")
	g.buf.WriteString("            arr = array.array('d', arr)\n")
	g.buf.WriteString("        byte_len = len(arr) * 8\n")
	g.buf.WriteString("        self.ensure_capacity(byte_len)\n")
	g.buf.WriteString("        mv = memoryview(arr).cast('B')\n")
	g.buf.WriteString("        self.buffer[self.pos:self.pos+byte_len] = mv\n")
	g.buf.WriteString("        self.pos += byte_len\n\n")

	g.buf.WriteString("\n")
	return nil
}

func (g *pythonPureGenerator) generateDecoder() error {
	g.buf.WriteString("# Decoder - reads binary wire format using struct module\n")
	g.buf.WriteString("class Decoder:\n")
	g.buf.WriteString("    def __init__(self, data):\n")
	g.buf.WriteString("        self.data = data\n")
	g.buf.WriteString("        self.pos = 0\n\n")

	g.buf.WriteString("    def read_bool(self):\n")
	g.buf.WriteString("        v = self.data[self.pos] != 0\n")
	g.buf.WriteString("        self.pos += 1\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_int8(self):\n")
	g.buf.WriteString("        # Direct byte access with sign extension (1.77x faster than struct)\n")
	g.buf.WriteString("        v = self.data[self.pos]\n")
	g.buf.WriteString("        self.pos += 1\n")
	g.buf.WriteString("        return v if v < 128 else v - 256\n\n")

	g.buf.WriteString("    def read_int16(self):\n")
	g.buf.WriteString("        v = struct.unpack_from('<h', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 2\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_int32(self):\n")
	g.buf.WriteString("        v = struct.unpack_from('<i', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 4\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_int64(self):\n")
	g.buf.WriteString("        v = struct.unpack_from('<q', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 8\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_float32(self):\n")
	g.buf.WriteString("        v = struct.unpack_from('<f', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 4\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_float64(self):\n")
	g.buf.WriteString("        v = struct.unpack_from('<d', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 8\n")
	g.buf.WriteString("        return v\n\n")

	g.buf.WriteString("    def read_string(self):\n")
	g.buf.WriteString("        length = struct.unpack_from('<H', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 2\n")
	g.buf.WriteString("        s = self.data[self.pos:self.pos+length].decode('utf-8')\n")
	g.buf.WriteString("        self.pos += length\n")
	g.buf.WriteString("        return s\n\n")

	// Bulk array reads using memoryview (zero-copy, returns typed arrays!)
	g.buf.WriteString("    def read_int8_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed int8 array\"\"\"\n")
	g.buf.WriteString("        # Create array.array from memoryview (zero-copy if aligned)\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+length]\n")
	g.buf.WriteString("        arr = array.array('b')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += length\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('b')\n\n")

	g.buf.WriteString("    def read_int16_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed int16 array\"\"\"\n")
	g.buf.WriteString("        byte_len = length * 2\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+byte_len]\n")
	g.buf.WriteString("        arr = array.array('h')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += byte_len\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('h')\n\n")

	g.buf.WriteString("    def read_int32_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed int32 array\"\"\"\n")
	g.buf.WriteString("        byte_len = length * 4\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+byte_len]\n")
	g.buf.WriteString("        arr = array.array('i')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += byte_len\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('i')\n\n")

	g.buf.WriteString("    def read_int64_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed int64 array\"\"\"\n")
	g.buf.WriteString("        byte_len = length * 8\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+byte_len]\n")
	g.buf.WriteString("        arr = array.array('q')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += byte_len\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('q')\n\n")

	g.buf.WriteString("    def read_float32_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed float32 array\"\"\"\n")
	g.buf.WriteString("        byte_len = length * 4\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+byte_len]\n")
	g.buf.WriteString("        arr = array.array('f')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += byte_len\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('f')\n\n")

	g.buf.WriteString("    def read_float64_array(self, length):\n")
	g.buf.WriteString("        \"\"\"Zero-copy read returning typed float64 array\"\"\"\n")
	g.buf.WriteString("        byte_len = length * 8\n")
	g.buf.WriteString("        mv = memoryview(self.data)[self.pos:self.pos+byte_len]\n")
	g.buf.WriteString("        arr = array.array('d')\n")
	g.buf.WriteString("        arr.frombytes(mv)\n")
	g.buf.WriteString("        self.pos += byte_len\n")
	g.buf.WriteString("        return arr  # Returns typed array.array('d')\n\n")

	g.buf.WriteString("    def read_array_length(self):\n")
	g.buf.WriteString("        length = struct.unpack_from('<H', self.data, self.pos)[0]\n")
	g.buf.WriteString("        self.pos += 2\n")
	g.buf.WriteString("        return length\n\n")

	g.buf.WriteString("\n")
	return nil
}

func (g *pythonPureGenerator) collectAllStructs() []*schema.StructType {
	seen := make(map[*schema.StructType]bool)
	var result []*schema.StructType

	var visit func(t schema.Type)
	visit = func(t schema.Type) {
		switch typ := t.(type) {
		case *schema.StructType:
			if !seen[typ] {
				seen[typ] = true
				result = append(result, typ)
				for _, field := range typ.Fields {
					visit(field.Type)
				}
			}
		case *schema.ArrayType:
			visit(typ.ElementType)
		case *schema.PrimitiveType:
			// Terminal case
		}
	}

	for _, msg := range g.schema.Messages {
		visit(msg.TargetType)
	}

	return result
}

// collectSliceTypes returns all top-level messages that are array types
func (g *pythonPureGenerator) collectSliceTypes() []schema.MessageType {
	var result []schema.MessageType
	for _, msg := range g.schema.Messages {
		if _, ok := msg.TargetType.(*schema.ArrayType); ok {
			result = append(result, msg)
		}
	}
	return result
}

func (g *pythonPureGenerator) generateStructClass(structType *schema.StructType) error {
	fmt.Fprintf(g.buf, "# %s class\n", structType.Name)
	fmt.Fprintf(g.buf, "class %s:\n", structType.Name)

	// Constructor with type hints
	g.buf.WriteString("    def __init__(self")
	for _, field := range structType.Fields {
		typeHint := g.pythonTypeHint(field.Type)
		fmt.Fprintf(g.buf, ", %s: %s = None", field.Name, typeHint)
	}
	g.buf.WriteString("):\n")

	for _, field := range structType.Fields {
		defaultVal := g.pythonDefaultValue(field.Type)
		fmt.Fprintf(g.buf, "        self.%s = %s if %s is not None else %s\n",
			field.Name, field.Name, field.Name, defaultVal)
	}
	g.buf.WriteString("\n")

	// Encode method
	g.buf.WriteString("    def encode(self) -> bytes:\n")
	g.buf.WriteString("        enc = Encoder()\n")
	for _, field := range structType.Fields {
		g.generateEncodeField(&field)
	}
	g.buf.WriteString("        return enc.to_bytes()\n\n")

	// Decode static method
	fmt.Fprintf(g.buf, "    @staticmethod\n")
	fmt.Fprintf(g.buf, "    def decode(data):\n")
	g.buf.WriteString("        dec = data if isinstance(data, Decoder) else Decoder(data)\n")
	fmt.Fprintf(g.buf, "        obj = %s()\n", structType.Name)
	for _, field := range structType.Fields {
		g.generateDecodeField(&field)
	}
	g.buf.WriteString("        return obj\n\n")

	return nil
}

func (g *pythonPureGenerator) generateEncodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "        if self.%s is not None:\n", field.Name)
			g.buf.WriteString("            enc.write_bool(True)\n")
			g.generatePrimitiveEncode("self."+field.Name, typ.Name, "            ")
			g.buf.WriteString("        else:\n")
			g.buf.WriteString("            enc.write_bool(False)\n")
		} else {
			g.generatePrimitiveEncode("self."+field.Name, typ.Name, "        ")
		}
	case *schema.ArrayType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "        if self.%s is not None:\n", field.Name)
			g.buf.WriteString("            enc.write_bool(True)\n")
			fmt.Fprintf(g.buf, "            enc.write_int16(len(self.%s))\n", field.Name)
			g.generateArrayElementEncode(field.Name, typ.ElementType, "            ")
			g.buf.WriteString("        else:\n")
			g.buf.WriteString("            enc.write_bool(False)\n")
		} else {
			fmt.Fprintf(g.buf, "        enc.write_int16(len(self.%s))\n", field.Name)
			g.generateArrayElementEncode(field.Name, typ.ElementType, "        ")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "        nested = self.%s.encode()\n", field.Name)
		g.buf.WriteString("        enc.buffer[enc.pos:enc.pos+len(nested)] = nested\n")
		g.buf.WriteString("        enc.pos += len(nested)\n")
	}
}

func (g *pythonPureGenerator) generateArrayElementEncode(fieldName string, elementType schema.Type, indent string) {
	switch typ := elementType.(type) {
	case *schema.PrimitiveType:
		// Use typed array bulk operations for performance + type safety
		switch typ.Name {
		case "int8":
			fmt.Fprintf(g.buf, "%senc.write_int8_array(self.%s)\n", indent, fieldName)
		case "int16":
			fmt.Fprintf(g.buf, "%senc.write_int16_array(self.%s)\n", indent, fieldName)
		case "int32":
			fmt.Fprintf(g.buf, "%senc.write_int32_array(self.%s)\n", indent, fieldName)
		case "int64":
			fmt.Fprintf(g.buf, "%senc.write_int64_array(self.%s)\n", indent, fieldName)
		case "float32":
			fmt.Fprintf(g.buf, "%senc.write_float32_array(self.%s)\n", indent, fieldName)
		case "float64":
			fmt.Fprintf(g.buf, "%senc.write_float64_array(self.%s)\n", indent, fieldName)
		default:
			// Element-by-element for bool, string
			fmt.Fprintf(g.buf, "%sfor elem in self.%s:\n", indent, fieldName)
			g.generatePrimitiveEncode("elem", typ.Name, indent+"    ")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "%sfor elem in self.%s:\n", indent, fieldName)
		fmt.Fprintf(g.buf, "%s    nested = elem.encode()\n", indent)
		fmt.Fprintf(g.buf, "%s    enc.buffer[enc.pos:enc.pos+len(nested)] = nested\n", indent)
		fmt.Fprintf(g.buf, "%s    enc.pos += len(nested)\n", indent)
	}
}

func (g *pythonPureGenerator) generateDecodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "        if dec.read_bool():\n")
			fmt.Fprintf(g.buf, "            obj.%s = %s\n", field.Name, g.pythonReadPrimitive(typ.Name))
		} else {
			fmt.Fprintf(g.buf, "        obj.%s = %s\n", field.Name, g.pythonReadPrimitive(typ.Name))
		}
	case *schema.ArrayType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "        if dec.read_bool():\n")
			fmt.Fprintf(g.buf, "            length = dec.read_array_length()\n")
			g.generateArrayElementDecode(field.Name, typ.ElementType, "            ")
		} else {
			fmt.Fprintf(g.buf, "        length = dec.read_array_length()\n")
			g.generateArrayElementDecode(field.Name, typ.ElementType, "        ")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "        obj.%s = %s.decode(dec)\n", field.Name, typ.Name)
	}
}

func (g *pythonPureGenerator) generateArrayElementDecode(fieldName string, elementType schema.Type, indent string) {
	switch typ := elementType.(type) {
	case *schema.PrimitiveType:
		// Use typed array bulk operations for performance + type safety
		switch typ.Name {
		case "int8":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_int8_array(length)  # Returns array.array('b')\n", indent, fieldName)
		case "int16":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_int16_array(length)  # Returns array.array('h')\n", indent, fieldName)
		case "int32":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_int32_array(length)  # Returns array.array('i')\n", indent, fieldName)
		case "int64":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_int64_array(length)  # Returns array.array('q')\n", indent, fieldName)
		case "float32":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_float32_array(length)  # Returns array.array('f')\n", indent, fieldName)
		case "float64":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.read_float64_array(length)  # Returns array.array('d')\n", indent, fieldName)
		default:
			// Element-by-element for bool, string (no typed array equivalent)
			fmt.Fprintf(g.buf, "%sobj.%s = []\n", indent, fieldName)
			fmt.Fprintf(g.buf, "%sfor _ in range(length):\n", indent)
			fmt.Fprintf(g.buf, "%s    obj.%s.append(%s)\n", indent, fieldName, g.pythonReadPrimitive(typ.Name))
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "%sobj.%s = []\n", indent, fieldName)
		fmt.Fprintf(g.buf, "%sfor _ in range(length):\n", indent)
		fmt.Fprintf(g.buf, "%s    obj.%s.append(%s.decode(dec))\n", indent, fieldName, typ.Name)
	}
}

func (g *pythonPureGenerator) generateSliceClass(msg schema.MessageType) error {
	arrayType := msg.TargetType.(*schema.ArrayType)
	elementType := arrayType.ElementType

	fmt.Fprintf(g.buf, "# %s - wrapper for array of %s\n", msg.Name, elementType.TypeName())
	fmt.Fprintf(g.buf, "class %s:\n", msg.Name)

	// Constructor
	g.buf.WriteString("    def __init__(self, data=None):\n")

	// For primitive numeric types, use array.array
	if primType, ok := elementType.(*schema.PrimitiveType); ok {
		switch primType.Name {
		case "int8":
			g.buf.WriteString("        self.data = data if data is not None else array.array('b')\n\n")
		case "int16":
			g.buf.WriteString("        self.data = data if data is not None else array.array('h')\n\n")
		case "int32":
			g.buf.WriteString("        self.data = data if data is not None else array.array('i')\n\n")
		case "int64":
			g.buf.WriteString("        self.data = data if data is not None else array.array('q')\n\n")
		case "float32":
			g.buf.WriteString("        self.data = data if data is not None else array.array('f')\n\n")
		case "float64":
			g.buf.WriteString("        self.data = data if data is not None else array.array('d')\n\n")
		default:
			// String, bool, etc. - use list
			g.buf.WriteString("        self.data = data if data is not None else []\n\n")
		}
	} else {
		// Structs - use list
		g.buf.WriteString("        self.data = data if data is not None else []\n\n")
	}

	// Encode method
	g.buf.WriteString("    def encode(self) -> bytes:\n")
	g.buf.WriteString("        enc = Encoder()\n")
	g.buf.WriteString("        enc.write_int16(len(self.data))\n")
	g.generateArrayElementEncode("data", elementType, "        ")
	g.buf.WriteString("        return enc.to_bytes()\n\n")

	// Decode static method
	g.buf.WriteString("    @staticmethod\n")
	g.buf.WriteString("    def decode(data):\n")
	g.buf.WriteString("        dec = data if isinstance(data, Decoder) else Decoder(data)\n")
	g.buf.WriteString("        length = dec.read_int16()\n")
	fmt.Fprintf(g.buf, "        obj = %s()\n", msg.Name)
	g.generateArrayElementDecode("data", elementType, "        ")
	g.buf.WriteString("        return obj\n\n")

	return nil
}

func (g *pythonPureGenerator) generatePrimitiveEncode(varName, typeName, indent string) {
	method := g.pythonWriteMethod(typeName)
	fmt.Fprintf(g.buf, "%senc.%s(%s)\n", indent, method, varName)
}

func (g *pythonPureGenerator) pythonWriteMethod(typeName string) string {
	switch typeName {
	case "bool":
		return "write_bool"
	case "int8":
		return "write_int8"
	case "int16":
		return "write_int16"
	case "int32":
		return "write_int32"
	case "int64":
		return "write_int64"
	case "float32":
		return "write_float32"
	case "float64":
		return "write_float64"
	case "string":
		return "write_string"
	default:
		return "write_int32"
	}
}

func (g *pythonPureGenerator) pythonReadPrimitive(typeName string) string {
	switch typeName {
	case "bool":
		return "dec.read_bool()"
	case "int8":
		return "dec.read_int8()"
	case "int16":
		return "dec.read_int16()"
	case "int32":
		return "dec.read_int32()"
	case "int64":
		return "dec.read_int64()"
	case "float32":
		return "dec.read_float32()"
	case "float64":
		return "dec.read_float64()"
	case "string":
		return "dec.read_string()"
	default:
		return "dec.read_int32()"
	}
}

func (g *pythonPureGenerator) pythonTypeHint(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		hint := g.pythonPrimitiveType(typ.Name)
		if typ.Optional {
			return "Optional[" + hint + "]"
		}
		return hint
	case *schema.ArrayType:
		elemHint := g.pythonTypeHint(typ.ElementType)
		// Use array.array for typed arrays
		if primType, ok := typ.ElementType.(*schema.PrimitiveType); ok {
			switch primType.Name {
			case "int8", "int16", "int32", "int64", "float32", "float64":
				arrayHint := "array.array"
				if typ.Optional {
					return "Optional[" + arrayHint + "]"
				}
				return arrayHint
			}
		}
		hint := "List[" + elemHint + "]"
		if typ.Optional {
			return "Optional[" + hint + "]"
		}
		return hint
	case *schema.StructType:
		return typ.Name
	}
	return "Any"
}

func (g *pythonPureGenerator) pythonPrimitiveType(typeName string) string {
	switch typeName {
	case "bool":
		return "bool"
	case "int8", "int16", "int32", "int64":
		return "int"
	case "float32", "float64":
		return "float"
	case "string":
		return "str"
	default:
		return "int"
	}
}

func (g *pythonPureGenerator) pythonDefaultValue(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			return "None"
		}
		switch typ.Name {
		case "bool":
			return "False"
		case "int8", "int16", "int32", "int64":
			return "0"
		case "float32", "float64":
			return "0.0"
		case "string":
			return "''"
		}
	case *schema.ArrayType:
		if typ.Optional {
			return "None"
		}
		// Return appropriate typed array for numeric types
		if primType, ok := typ.ElementType.(*schema.PrimitiveType); ok {
			switch primType.Name {
			case "int8":
				return "array.array('b')"
			case "int16":
				return "array.array('h')"
			case "int32":
				return "array.array('i')"
			case "int64":
				return "array.array('q')"
			case "float32":
				return "array.array('f')"
			case "float64":
				return "array.array('d')"
			}
		}
		return "[]"
	case *schema.StructType:
		return "None"
	}
	return "None"
}
