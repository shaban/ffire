package generator

import (
	"bytes"
	"fmt"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateJavaScript generates pure JavaScript encoder/decoder
func GenerateJavaScript(s *schema.Schema) ([]byte, error) {
	s.Canonicalize()

	gen := &jsGenerator{
		schema: s,
		buf:    &bytes.Buffer{},
	}
	return gen.generate()
}

type jsGenerator struct {
	schema *schema.Schema
	buf    *bytes.Buffer
}

func (g *jsGenerator) generate() ([]byte, error) {
	g.buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n")
	g.buf.WriteString("// Pure JavaScript implementation - no native bindings\n\n")

	// Generate encoder class
	if err := g.generateEncoder(); err != nil {
		return nil, err
	}

	// Generate decoder class
	if err := g.generateDecoder(); err != nil {
		return nil, err
	}

	// First, generate classes for ALL struct types (including nested ones)
	structTypes := g.collectAllStructs()
	for _, structType := range structTypes {
		if err := g.generateStructClass(structType); err != nil {
			return nil, err
		}
	}

	// Export ALL struct classes (including nested ones, for usability)
	if len(structTypes) > 0 {
		g.buf.WriteString("\nmodule.exports = {\n")
		for i, structType := range structTypes {
			if i > 0 {
				g.buf.WriteString(",\n")
			}
			fmt.Fprintf(g.buf, "  %s", structType.Name)
		}
		g.buf.WriteString("\n};\n")
	}

	return g.buf.Bytes(), nil
}

func (g *jsGenerator) generateEncoder() error {
	g.buf.WriteString("// Encoder - writes binary wire format using DataView + ArrayBuffer\n")
	g.buf.WriteString("class Encoder {\n")
	g.buf.WriteString("  constructor(estimatedSize = 256) {\n")
	g.buf.WriteString("    this.buffer = new ArrayBuffer(estimatedSize);\n")
	g.buf.WriteString("    this.view = new DataView(this.buffer);\n")
	g.buf.WriteString("    this.bytes = new Uint8Array(this.buffer);\n")
	g.buf.WriteString("    this.pos = 0;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  ensureCapacity(needed) {\n")
	g.buf.WriteString("    if (this.pos + needed > this.buffer.byteLength) {\n")
	g.buf.WriteString("      const newSize = Math.max(this.buffer.byteLength * 2, this.pos + needed);\n")
	g.buf.WriteString("      const newBuffer = new ArrayBuffer(newSize);\n")
	g.buf.WriteString("      new Uint8Array(newBuffer).set(this.bytes);\n")
	g.buf.WriteString("      this.buffer = newBuffer;\n")
	g.buf.WriteString("      this.view = new DataView(this.buffer);\n")
	g.buf.WriteString("      this.bytes = new Uint8Array(this.buffer);\n")
	g.buf.WriteString("    }\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  toBuffer() {\n")
	g.buf.WriteString("    return Buffer.from(this.buffer, 0, this.pos);\n")
	g.buf.WriteString("  }\n\n")

	// Write primitives using DataView
	g.buf.WriteString("  writeBool(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(1);\n")
	g.buf.WriteString("    this.view.setUint8(this.pos++, v ? 1 : 0);\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeInt8(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(1);\n")
	g.buf.WriteString("    this.view.setInt8(this.pos++, v);\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeInt16(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(2);\n")
	g.buf.WriteString("    this.view.setInt16(this.pos, v, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 2;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeInt32(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(4);\n")
	g.buf.WriteString("    this.view.setInt32(this.pos, v, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 4;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeInt64(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(8);\n")
	g.buf.WriteString("    this.view.setBigInt64(this.pos, v, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 8;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeFloat32(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(4);\n")
	g.buf.WriteString("    this.view.setFloat32(this.pos, v, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 4;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeFloat64(v) {\n")
	g.buf.WriteString("    this.ensureCapacity(8);\n")
	g.buf.WriteString("    this.view.setFloat64(this.pos, v, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 8;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeString(s) {\n")
	g.buf.WriteString("    const utf8 = Buffer.from(s, 'utf8');\n")
	g.buf.WriteString("    this.ensureCapacity(2 + utf8.length);\n")
	g.buf.WriteString("    this.view.setUint16(this.pos, utf8.length, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 2;\n")
	g.buf.WriteString("    this.bytes.set(utf8, this.pos);\n")
	g.buf.WriteString("    this.pos += utf8.length;\n")
	g.buf.WriteString("  }\n\n")

	// Bulk array writes - zero-copy using TypedArray views
	g.buf.WriteString("  writeInt32Array(arr) {\n")
	g.buf.WriteString("    const byteLen = arr.length * 4;\n")
	g.buf.WriteString("    this.ensureCapacity(byteLen);\n")
	g.buf.WriteString("    const view = new Uint8Array(arr.buffer, arr.byteOffset, byteLen);\n")
	g.buf.WriteString("    this.bytes.set(view, this.pos);\n")
	g.buf.WriteString("    this.pos += byteLen;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeFloat32Array(arr) {\n")
	g.buf.WriteString("    const byteLen = arr.length * 4;\n")
	g.buf.WriteString("    this.ensureCapacity(byteLen);\n")
	g.buf.WriteString("    const view = new Uint8Array(arr.buffer, arr.byteOffset, byteLen);\n")
	g.buf.WriteString("    this.bytes.set(view, this.pos);\n")
	g.buf.WriteString("    this.pos += byteLen;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  writeFloat64Array(arr) {\n")
	g.buf.WriteString("    const byteLen = arr.length * 8;\n")
	g.buf.WriteString("    this.ensureCapacity(byteLen);\n")
	g.buf.WriteString("    const view = new Uint8Array(arr.buffer, arr.byteOffset, byteLen);\n")
	g.buf.WriteString("    this.bytes.set(view, this.pos);\n")
	g.buf.WriteString("    this.pos += byteLen;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("}\n\n")
	return nil
}

func (g *jsGenerator) generateDecoder() error {
	g.buf.WriteString("// Decoder - reads binary wire format using DataView for optimal performance\n")
	g.buf.WriteString("class Decoder {\n")
	g.buf.WriteString("  constructor(buffer) {\n")
	g.buf.WriteString("    // Support both Buffer and Uint8Array\n")
	g.buf.WriteString("    this.data = buffer;\n")
	g.buf.WriteString("    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n")
	g.buf.WriteString("    this.pos = 0;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readBool() {\n")
	g.buf.WriteString("    return this.view.getUint8(this.pos++) !== 0;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readInt8() {\n")
	g.buf.WriteString("    return this.view.getInt8(this.pos++);\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readInt16() {\n")
	g.buf.WriteString("    const v = this.view.getInt16(this.pos, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 2;\n")
	g.buf.WriteString("    return v;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readInt32() {\n")
	g.buf.WriteString("    const v = this.view.getInt32(this.pos, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 4;\n")
	g.buf.WriteString("    return v;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readInt64() {\n")
	g.buf.WriteString("    const v = this.view.getBigInt64(this.pos, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 8;\n")
	g.buf.WriteString("    return v;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readFloat32() {\n")
	g.buf.WriteString("    const v = this.view.getFloat32(this.pos, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 4;\n")
	g.buf.WriteString("    return v;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readFloat64() {\n")
	g.buf.WriteString("    const v = this.view.getFloat64(this.pos, true); // little-endian\n")
	g.buf.WriteString("    this.pos += 8;\n")
	g.buf.WriteString("    return v;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readString() {\n")
	g.buf.WriteString("    const len = this.view.getUint16(this.pos, true); // little-endian uint16\n")
	g.buf.WriteString("    this.pos += 2;\n")
	g.buf.WriteString("    const bytes = this.data.subarray(this.pos, this.pos + len);\n")
	g.buf.WriteString("    this.pos += len;\n")
	g.buf.WriteString("    return Buffer.from(bytes).toString('utf8');\n")
	g.buf.WriteString("  }\n\n")

	// Bulk array reads using TypedArray views (zero-copy!)
	g.buf.WriteString("  readInt32Array(len) {\n")
	g.buf.WriteString("    // Zero-copy TypedArray view directly on ArrayBuffer\n")
	g.buf.WriteString("    const byteOffset = this.data.byteOffset + this.pos;\n")
	g.buf.WriteString("    const arr = new Int32Array(this.data.buffer, byteOffset, len);\n")
	g.buf.WriteString("    this.pos += len * 4;\n")
	g.buf.WriteString("    return arr;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readFloat32Array(len) {\n")
	g.buf.WriteString("    const byteOffset = this.data.byteOffset + this.pos;\n")
	g.buf.WriteString("    const arr = new Float32Array(this.data.buffer, byteOffset, len);\n")
	g.buf.WriteString("    this.pos += len * 4;\n")
	g.buf.WriteString("    return arr;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readFloat64Array(len) {\n")
	g.buf.WriteString("    const byteOffset = this.data.byteOffset + this.pos;\n")
	g.buf.WriteString("    const arr = new Float64Array(this.data.buffer, byteOffset, len);\n")
	g.buf.WriteString("    this.pos += len * 8;\n")
	g.buf.WriteString("    return arr;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("  readArrayLength() {\n")
	g.buf.WriteString("    const len = this.view.getUint16(this.pos, true); // little-endian uint16\n")
	g.buf.WriteString("    this.pos += 2;\n")
	g.buf.WriteString("    return len;\n")
	g.buf.WriteString("  }\n\n")

	g.buf.WriteString("}\n\n")
	return nil
}

// collectAllStructs walks the schema and collects all struct types (including nested ones)
func (g *jsGenerator) collectAllStructs() []*schema.StructType {
	seen := make(map[*schema.StructType]bool)
	var result []*schema.StructType

	var visit func(t schema.Type)
	visit = func(t schema.Type) {
		switch typ := t.(type) {
		case *schema.StructType:
			if !seen[typ] {
				seen[typ] = true
				result = append(result, typ)
				// Visit fields recursively
				for _, field := range typ.Fields {
					visit(field.Type)
				}
			}
		case *schema.ArrayType:
			visit(typ.ElementType)
		case *schema.PrimitiveType:
			// Terminal case
		}
	}

	// Start from root messages
	for _, msg := range g.schema.Messages {
		visit(msg.TargetType)
	}

	return result
}

// generateStructClass generates a class for a struct type
func (g *jsGenerator) generateStructClass(structType *schema.StructType) error {
	fmt.Fprintf(g.buf, "// %s class\n", structType.Name)
	fmt.Fprintf(g.buf, "class %s {\n", structType.Name)

	// Constructor
	g.buf.WriteString("  constructor(data = {}) {\n")
	for _, field := range structType.Fields {
		defaultVal := g.jsDefaultValue(field.Type)
		fmt.Fprintf(g.buf, "    this.%s = data.%s !== undefined ? data.%s : %s;\n",
			field.Name, field.Name, field.Name, defaultVal)
	}
	g.buf.WriteString("  }\n\n")

	// Encode method
	g.buf.WriteString("  encode() {\n")
	g.buf.WriteString("    const enc = new Encoder();\n")
	for _, field := range structType.Fields {
		g.generateEncodeField(&field)
	}
	g.buf.WriteString("    return enc.toBuffer();\n")
	g.buf.WriteString("  }\n\n")

	// Decode static method (accepts Decoder or Buffer)
	fmt.Fprintf(g.buf, "  static decode(input) {\n")
	g.buf.WriteString("    const dec = input instanceof Decoder ? input : new Decoder(input);\n")
	fmt.Fprintf(g.buf, "    const obj = new %s();\n", structType.Name)
	for _, field := range structType.Fields {
		g.generateDecodeField(&field)
	}
	g.buf.WriteString("    return obj;\n")
	g.buf.WriteString("  }\n")

	g.buf.WriteString("}\n\n")
	return nil
}

func (g *jsGenerator) generateEncodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "    if (this.%s !== null && this.%s !== undefined) {\n", field.Name, field.Name)
			g.buf.WriteString("      enc.writeBool(true);\n")
			g.generatePrimitiveEncode("this."+field.Name, typ.Name, "      ")
			g.buf.WriteString("    } else {\n")
			g.buf.WriteString("      enc.writeBool(false);\n")
			g.buf.WriteString("    }\n")
		} else {
			g.generatePrimitiveEncode("this."+field.Name, typ.Name, "    ")
		}
	case *schema.ArrayType:
		if typ.Optional {
			// Optional array: write presence flag first
			fmt.Fprintf(g.buf, "    if (this.%s !== null && this.%s !== undefined) {\n", field.Name, field.Name)
			g.buf.WriteString("      enc.writeBool(true);\n")
			fmt.Fprintf(g.buf, "      enc.writeInt16(this.%s.length);\n", field.Name)
			g.generateArrayElementEncode(field.Name, typ.ElementType, "      ")
			g.buf.WriteString("    } else {\n")
			g.buf.WriteString("      enc.writeBool(false);\n")
			g.buf.WriteString("    }\n")
		} else {
			// Regular array
			fmt.Fprintf(g.buf, "    enc.writeInt16(this.%s.length);\n", field.Name)
			g.generateArrayElementEncode(field.Name, typ.ElementType, "    ")
		}
	case *schema.StructType:
		// Nested struct: encode it inline
		fmt.Fprintf(g.buf, "    {\n")
		fmt.Fprintf(g.buf, "      const nested = this.%s.encode();\n", field.Name)
		g.buf.WriteString("      enc.bytes.set(nested, enc.pos);\n")
		g.buf.WriteString("      enc.pos += nested.length;\n")
		g.buf.WriteString("    }\n")
	}
}

func (g *jsGenerator) generateArrayElementEncode(fieldName string, elementType schema.Type, indent string) {
	switch typ := elementType.(type) {
	case *schema.PrimitiveType:
		// Check for bulk optimization
		switch typ.Name {
		case "int32":
			fmt.Fprintf(g.buf, "%senc.writeInt32Array(this.%s);\n", indent, fieldName)
		case "float32":
			fmt.Fprintf(g.buf, "%senc.writeFloat32Array(this.%s);\n", indent, fieldName)
		case "float64":
			fmt.Fprintf(g.buf, "%senc.writeFloat64Array(this.%s);\n", indent, fieldName)
		default:
			fmt.Fprintf(g.buf, "%sfor (const elem of this.%s) {\n", indent, fieldName)
			g.generatePrimitiveEncode("elem", typ.Name, indent+"  ")
			fmt.Fprintf(g.buf, "%s}\n", indent)
		}
	case *schema.StructType:
		// Array of structs
		fmt.Fprintf(g.buf, "%sfor (const elem of this.%s) {\n", indent, fieldName)
		fmt.Fprintf(g.buf, "%s  const nested = elem.encode();\n", indent)
		fmt.Fprintf(g.buf, "%s  enc.bytes.set(nested, enc.pos);\n", indent)
		fmt.Fprintf(g.buf, "%s  enc.pos += nested.length;\n", indent)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *jsGenerator) generateDecodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "    if (dec.readBool()) {\n")
			fmt.Fprintf(g.buf, "      obj.%s = %s;\n", field.Name, g.jsReadPrimitive(typ.Name))
			g.buf.WriteString("    }\n")
		} else {
			fmt.Fprintf(g.buf, "    obj.%s = %s;\n", field.Name, g.jsReadPrimitive(typ.Name))
		}
	case *schema.ArrayType:
		if typ.Optional {
			// Optional array: check presence flag
			fmt.Fprintf(g.buf, "    if (dec.readBool()) {\n")
			fmt.Fprintf(g.buf, "      const len = dec.readArrayLength();\n")
			g.generateArrayElementDecode(field.Name, typ.ElementType, "      ")
			g.buf.WriteString("    }\n")
		} else {
			// Regular array
			fmt.Fprintf(g.buf, "    {\n")
			fmt.Fprintf(g.buf, "      const len = dec.readArrayLength();\n")
			g.generateArrayElementDecode(field.Name, typ.ElementType, "      ")
			g.buf.WriteString("    }\n")
		}
	case *schema.StructType:
		// Nested struct: decode inline by passing decoder
		fmt.Fprintf(g.buf, "    obj.%s = %s.decode(dec);\n", field.Name, typ.Name)
	}
}

func (g *jsGenerator) generateArrayElementDecode(fieldName string, elementType schema.Type, indent string) {
	switch typ := elementType.(type) {
	case *schema.PrimitiveType:
		// Check for bulk optimization
		switch typ.Name {
		case "int32":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.readInt32Array(len);\n", indent, fieldName)
		case "float32":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.readFloat32Array(len);\n", indent, fieldName)
		case "float64":
			fmt.Fprintf(g.buf, "%sobj.%s = dec.readFloat64Array(len);\n", indent, fieldName)
		default:
			fmt.Fprintf(g.buf, "%sobj.%s = new Array(len);\n", indent, fieldName)
			fmt.Fprintf(g.buf, "%sfor (let i = 0; i < len; i++) {\n", indent)
			fmt.Fprintf(g.buf, "%s  obj.%s[i] = %s;\n", indent, fieldName, g.jsReadPrimitive(typ.Name))
			fmt.Fprintf(g.buf, "%s}\n", indent)
		}
	case *schema.StructType:
		// Array of structs
		fmt.Fprintf(g.buf, "%sobj.%s = new Array(len);\n", indent, fieldName)
		fmt.Fprintf(g.buf, "%sfor (let i = 0; i < len; i++) {\n", indent)
		fmt.Fprintf(g.buf, "%s  obj.%s[i] = %s.decode(dec);\n", indent, fieldName, typ.Name)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *jsGenerator) generatePrimitiveEncode(varName, typeName, indent string) {
	method := g.jsWriteMethod(typeName)
	// For loop variables (elem), don't prepend 'this.'
	// For fields, caller already includes 'this.'
	fmt.Fprintf(g.buf, "%senc.%s(%s);\n", indent, method, varName)
}

func (g *jsGenerator) jsWriteMethod(typeName string) string {
	switch typeName {
	case "bool":
		return "writeBool"
	case "int8":
		return "writeInt8"
	case "int16":
		return "writeInt16"
	case "int32":
		return "writeInt32"
	case "int64":
		return "writeInt64"
	case "float32":
		return "writeFloat32"
	case "float64":
		return "writeFloat64"
	case "string":
		return "writeString"
	default:
		return "writeInt32"
	}
}

func (g *jsGenerator) jsReadPrimitive(typeName string) string {
	switch typeName {
	case "bool":
		return "dec.readBool()"
	case "int8":
		return "dec.readInt8()"
	case "int16":
		return "dec.readInt16()"
	case "int32":
		return "dec.readInt32()"
	case "int64":
		return "dec.readInt64()"
	case "float32":
		return "dec.readFloat32()"
	case "float64":
		return "dec.readFloat64()"
	case "string":
		return "dec.readString()"
	default:
		return "dec.readInt32()"
	}
}

func (g *jsGenerator) jsDefaultValue(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			return "null"
		}
		switch typ.Name {
		case "bool":
			return "false"
		case "int8", "int16", "int32", "float32", "float64":
			return "0"
		case "int64":
			return "0n"
		case "string":
			return "''"
		}
	case *schema.ArrayType:
		// Optional arrays (*[]T) should default to null
		if typ.Optional {
			return "null"
		}
		return "[]"
	case *schema.StructType:
		return "null"
	}
	return "null"
}
