package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateZigPackage generates a complete Zig package with C ABI bindings
func GenerateZigPackage(config *PackageConfig) error {
	return orchestrateTierBPackage(
		config,
		ZigLayout,
		generateZigWrapperOrchestrated,
		generateZigMetadataOrchestrated,
		printZigInstructions,
	)
}

var ZigLayout = DirectoryLayout{
	Name:         "zig",
	LibInPackage: false, // Zig: lib/libffire.dylib
}

func generateZigWrapperOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Create Zig src directory
	srcDir := filepath.Join(paths.Root, "src")
	if err := os.MkdirAll(srcDir, 0755); err != nil {
		return fmt.Errorf("failed to create src directory: %w", err)
	}

	// Generate Zig bindings
	return generateZigFiles(config, srcDir, paths.Lib)
}

func generateZigMetadataOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate build.zig
	if err := generateZigBuild(config, paths.Root); err != nil {
		return err
	}

	// Generate README.md
	return generateZigReadme(config, paths.Root)
}

func printZigInstructions(config *PackageConfig, paths *PackagePaths) {
	fmt.Printf("\n✅ Zig package ready at: %s\n\n", paths.Root)
	fmt.Println("Build:")
	fmt.Printf("  cd %s\n", paths.Root)
	fmt.Println("  zig build")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  const %s = @import(\"%s\");\n", config.Namespace, config.Namespace)
	fmt.Println("  const msg = Message.decode(data);")
	fmt.Println("  const encoded = msg.encode();")
	fmt.Println()
}

func generateZigFiles(config *PackageConfig, srcDir, libDir string) error {
	// Generate main library file
	buf := &bytes.Buffer{}

	// Generated code header
	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")
	buf.WriteString("const std = @import(\"std\");\n\n")

	// C library bindings
	fmt.Fprintf(buf, "const c = @cImport({});\n\n")

	// Error type
	buf.WriteString("pub const FFireError = error{\n")
	buf.WriteString("    DecodeFailed,\n")
	buf.WriteString("    EncodeFailed,\n")
	buf.WriteString("    NullPointer,\n")
	buf.WriteString("};\n\n")

	// Generate extern declarations and wrapper types for each message
	for _, msg := range config.Schema.Messages {
		if err := generateZigMessageBindings(buf, config.Schema, &msg, config.Namespace); err != nil {
			return err
		}
	}

	filePath := filepath.Join(srcDir, config.Namespace+".zig")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write Zig library: %w", err)
	}

	fmt.Printf("✓ Generated %s.zig\n", config.Namespace)
	return nil
}

func generateZigMessageBindings(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType, namespace string) error {
	baseName := strings.ToLower(msg.Name) // All lowercase to match C ABI
	typeName := msg.Name + "Message"      // Add Message suffix to avoid keyword collisions

	// External C function declarations
	buf.WriteString("// External C ABI functions\n")
	fmt.Fprintf(buf, "extern fn %s_decode(data: [*]const u8, len: i32, err: *?[*:0]u8) ?*anyopaque;\n", baseName)
	fmt.Fprintf(buf, "extern fn %s_encode(handle: *anyopaque, out: *[*]u8, err: *?[*:0]u8) usize;\n", baseName)
	fmt.Fprintf(buf, "extern fn %s_free(handle: *anyopaque) void;\n", baseName)
	fmt.Fprintf(buf, "extern fn %s_free_data(data: [*]u8) void;\n", baseName)
	fmt.Fprintf(buf, "extern fn %s_free_error(err: [*:0]u8) void;\n\n", baseName)

	// Wrapper struct
	fmt.Fprintf(buf, "pub const %s = struct {\n", typeName)
	buf.WriteString("    handle: *anyopaque,\n\n")

	// Decode function
	buf.WriteString("    /// Decode a message from binary wire format\n")
	buf.WriteString("    pub fn decode(data: []const u8) FFireError!@This() {\n")
	buf.WriteString("        var err_ptr: ?[*:0]u8 = null;\n")
	fmt.Fprintf(buf, "        const handle = %s_decode(data.ptr, @intCast(data.len), &err_ptr);\n", baseName)
	buf.WriteString("        \n")
	buf.WriteString("        if (handle == null) {\n")
	buf.WriteString("            if (err_ptr) |err| {\n")
	fmt.Fprintf(buf, "                %s_free_error(err);\n", baseName)
	buf.WriteString("            }\n")
	buf.WriteString("            return FFireError.DecodeFailed;\n")
	buf.WriteString("        }\n")
	buf.WriteString("        \n")
	buf.WriteString("        return .{ .handle = handle.? };\n")
	buf.WriteString("    }\n\n")

	// Encode function
	buf.WriteString("    /// Encode the message to binary wire format\n")
	buf.WriteString("    /// Caller must free the returned slice with freeEncodedData()\n")
	buf.WriteString("    pub fn encode(self: @This()) FFireError![]u8 {\n")
	buf.WriteString("        var out_ptr: [*]u8 = undefined;\n")
	buf.WriteString("        var err_ptr: ?[*:0]u8 = null;\n")
	fmt.Fprintf(buf, "        const size = %s_encode(self.handle, &out_ptr, &err_ptr);\n", baseName)
	buf.WriteString("        \n")
	buf.WriteString("        if (size == 0 and err_ptr != null) {\n")
	buf.WriteString("            if (err_ptr) |err| {\n")
	fmt.Fprintf(buf, "                %s_free_error(err);\n", baseName)
	buf.WriteString("            }\n")
	buf.WriteString("            return FFireError.EncodeFailed;\n")
	buf.WriteString("        }\n")
	buf.WriteString("        \n")
	buf.WriteString("        return out_ptr[0..size];\n")
	buf.WriteString("    }\n\n")

	// Free encoded data
	buf.WriteString("    /// Free data returned by encode()\n")
	buf.WriteString("    pub fn freeEncodedData(data: []u8) void {\n")
	fmt.Fprintf(buf, "        %s_free_data(data.ptr);\n", baseName)
	buf.WriteString("    }\n\n")

	// Deinit function
	buf.WriteString("    /// Free the message handle\n")
	buf.WriteString("    pub fn deinit(self: @This()) void {\n")
	fmt.Fprintf(buf, "        %s_free(self.handle);\n", baseName)
	buf.WriteString("    }\n")

	buf.WriteString("};\n\n")

	return nil
}

func generateZigBuild(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("const std = @import(\"std\");\n\n")
	buf.WriteString("pub fn build(b: *std.Build) void {\n")
	buf.WriteString("    const target = b.standardTargetOptions(.{});\n")
	buf.WriteString("    const optimize = b.standardOptimizeOption(.{});\n\n")

	// Library module
	fmt.Fprintf(buf, "    const lib = b.addModule(\"%s\", .{\n", config.Namespace)
	fmt.Fprintf(buf, "        .root_source_file = b.path(\"src/%s.zig\"),\n", config.Namespace)
	buf.WriteString("    });\n\n")

	// Executable (for benchmarks/examples) - Zig 0.14+ uses root_module
	buf.WriteString("    const exe = b.addExecutable(.{\n")
	buf.WriteString("        .name = \"bench\",\n")
	buf.WriteString("        .root_module = b.createModule(.{\n")
	buf.WriteString("            .root_source_file = b.path(\"src/main.zig\"),\n")
	buf.WriteString("            .target = target,\n")
	buf.WriteString("            .optimize = optimize,\n")
	buf.WriteString("        }),\n")
	buf.WriteString("    });\n\n")

	// Link against the C library
	fmt.Fprintf(buf, "    exe.root_module.addLibraryPath(b.path(\"lib\"));\n")
	fmt.Fprintf(buf, "    exe.root_module.linkSystemLibrary(\"%s\", .{});\n", config.Schema.Package)
	buf.WriteString("    exe.linkLibC();\n\n")

	// Add the module as a dependency
	fmt.Fprintf(buf, "    exe.root_module.addImport(\"%s\", lib);\n\n", config.Namespace)

	buf.WriteString("    b.installArtifact(exe);\n\n")

	// Run step
	buf.WriteString("    const run_cmd = b.addRunArtifact(exe);\n")
	buf.WriteString("    run_cmd.step.dependOn(b.getInstallStep());\n\n")

	buf.WriteString("    const run_step = b.step(\"run\", \"Run the benchmark\");\n")
	buf.WriteString("    run_step.dependOn(&run_cmd.step);\n")
	buf.WriteString("}\n")

	filePath := filepath.Join(rootDir, "build.zig")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write build.zig: %w", err)
	}

	fmt.Printf("✓ Generated build.zig\n")
	return nil
}

func generateZigReadme(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, "# %s - Zig FFI Bindings\n\n", config.Namespace)
	buf.WriteString("Zig bindings for ffire serialization via C ABI.\n\n")

	buf.WriteString("## Building\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("zig build\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Usage\n\n")
	buf.WriteString("```zig\n")
	fmt.Fprintf(buf, "const %s = @import(\"%s\");\n\n", config.Namespace, config.Namespace)
	buf.WriteString("pub fn main() !void {\n")
	buf.WriteString("    const data: []const u8 = // ... binary data\n")
	buf.WriteString("    \n")
	buf.WriteString("    // Decode\n")
	buf.WriteString("    const msg = try Message.decode(data);\n")
	buf.WriteString("    defer msg.deinit();\n")
	buf.WriteString("    \n")
	buf.WriteString("    // Encode\n")
	buf.WriteString("    const encoded = try msg.encode();\n")
	buf.WriteString("    defer Message.freeEncodedData(encoded);\n")
	buf.WriteString("}\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Requirements\n\n")
	buf.WriteString("- Zig 0.11.0 or later\n")
	buf.WriteString("- The native library (`lib/lib*.dylib` or `lib/lib*.so`)\n")

	filePath := filepath.Join(rootDir, "README.md")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	fmt.Printf("✓ Generated README.md\n")
	return nil
}
