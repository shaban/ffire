package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/shaban/ffire/pkg/generator/igniffi"
	"github.com/shaban/ffire/pkg/schema"
)

// GenerateIgniffiPythonPackage generates a Python package using CFFI bindings
// to the igniffi C API. Uses CFFI API mode for maximum performance:
// - Compiles C extension at pip install time
// - ~10-50x faster than ctypes
// - Zero-copy buffer access via ffi.buffer()
// - Full type precision (int8, int16, int32, int64, float32, float64)
func GenerateIgniffiPythonPackage(config *PackageConfig) error {
	if config.Verbose {
		fmt.Println("Generating igniffi Python package (CFFI API mode)")
	}

	// Directory structure:
	// python/
	//   {package}/
	//     __init__.py       - Main Python API
	//     _ffi_build.py     - CFFI builder script
	//     _cffi_defs.h      - C declarations for CFFI
	//   src/                - igniffi C source
	//   include/            - igniffi headers
	//   pyproject.toml      - Modern Python packaging
	//   setup.py            - Build script with CFFI
	//   README.md           - Usage documentation

	pyDir := filepath.Join(config.OutputDir, "python")
	pkgName := toPythonIdentifier(config.Schema.Package)
	pkgDir := filepath.Join(pyDir, pkgName)
	srcDir := filepath.Join(pyDir, "src")
	includeDir := filepath.Join(pyDir, "include")

	for _, dir := range []string{pyDir, pkgDir, srcDir, includeDir} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Step 1: Generate igniffi C code
	igniffiDir := pyDir // igniffi.Generate expects root dir, creates include/ and src/
	if err := igniffi.Generate(config.Schema, igniffiDir); err != nil {
		return fmt.Errorf("failed to generate igniffi code: %w", err)
	}

	// Step 2: Generate CFFI definitions header
	if err := generateCFFIDefs(config, pkgDir); err != nil {
		return fmt.Errorf("failed to generate CFFI defs: %w", err)
	}

	// Step 3: Generate CFFI builder script
	if err := generateCFFIBuilder(config, pkgDir, pkgName); err != nil {
		return fmt.Errorf("failed to generate CFFI builder: %w", err)
	}

	// Step 4: Generate Python wrapper module
	if err := generatePythonWrapper(config, pkgDir, pkgName); err != nil {
		return fmt.Errorf("failed to generate Python wrapper: %w", err)
	}

	// Step 5: Generate pyproject.toml
	if err := generatePyProjectTOML(config, pyDir, pkgName); err != nil {
		return fmt.Errorf("failed to generate pyproject.toml: %w", err)
	}

	// Step 6: Generate setup.py
	if err := generateSetupPy(config, pyDir, pkgName); err != nil {
		return fmt.Errorf("failed to generate setup.py: %w", err)
	}

	// Step 7: Generate README
	if err := generatePythonReadme(config, pyDir, pkgName); err != nil {
		return fmt.Errorf("failed to generate README: %w", err)
	}

	// Step 8: Optionally compile the extension
	if !config.NoCompile {
		if err := compilePythonExtension(config, pyDir); err != nil {
			// Don't fail - user can compile manually
			fmt.Printf("⚠ Could not compile extension (user can run 'pip install .'): %v\n", err)
		}
	}

	printPythonInstructions(config, pyDir, pkgName)

	return nil
}

// generateCFFIDefs generates a header file with C declarations for CFFI
func generateCFFIDefs(config *PackageConfig, pkgDir string) error {
	s := config.Schema
	buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n")
	buf.WriteString("// CFFI definitions for igniffi Python bindings\n\n")

	// Core types
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Core Types\n")
	buf.WriteString("// ============================================================================\n\n")

	buf.WriteString("typedef struct igniffi_Arena igniffi_Arena;\n\n")

	buf.WriteString("typedef struct {\n")
	buf.WriteString("    const char* data;\n")
	buf.WriteString("    size_t size;\n")
	buf.WriteString("} igniffi_StringView;\n\n")

	buf.WriteString("typedef struct {\n")
	buf.WriteString("    bool ok;\n")
	buf.WriteString("    const char* message;\n")
	buf.WriteString("} igniffi_Status;\n\n")

	// Generate struct types in topological order
	sortedTypes := topSortStructTypes(s.Types)
	for _, structType := range sortedTypes {
		generateCFFIStructType(buf, s, structType)
	}

	// Generate message wrapper types (for arrays, primitives)
	for _, msg := range s.Messages {
		generateCFFIMessageType(buf, s, &msg)
	}

	// Arena functions
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Arena Management\n")
	buf.WriteString("// ============================================================================\n\n")

	buf.WriteString("igniffi_Arena* igniffi_arena_new(void);\n")
	buf.WriteString("igniffi_Arena* igniffi_arena_new_sized(size_t initial_size);\n")
	buf.WriteString("void igniffi_arena_free(igniffi_Arena* arena);\n\n")

	// Encode/Decode functions
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Encode/Decode Functions\n")
	buf.WriteString("// ============================================================================\n\n")

	for _, msg := range s.Messages {
		msgName := toCIdentifier(msg.Name)
		structName := fmt.Sprintf("igniffi_%s", msgName)

		fmt.Fprintf(buf, "%s* igniffi_decode_%s(const uint8_t* data, size_t len, igniffi_Arena* arena, igniffi_Status* status);\n",
			structName, msgName)
		fmt.Fprintf(buf, "uint8_t* igniffi_encode_%s(const %s* msg, size_t* out_len, igniffi_Arena* arena, igniffi_Status* status);\n\n",
			msgName, structName)
	}

	filePath := filepath.Join(pkgDir, "_cffi_defs.h")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write _cffi_defs.h: %w", err)
	}

	fmt.Println("✓ Generated _cffi_defs.h (CFFI declarations)")
	return nil
}

func generateCFFIStructType(buf *bytes.Buffer, s *schema.Schema, structType *schema.StructType) {
	structName := fmt.Sprintf("igniffi_%s", toCIdentifier(structType.Name))
	fmt.Fprintf(buf, "typedef struct {\n")

	for _, field := range structType.Fields {
		fieldName := toCIdentifier(field.Name)
		cType := cffiCTypeForField(&field)
		
		// Generate field
		fmt.Fprintf(buf, "    %s %s;\n", cType, fieldName)
		
		// If it's an array, add length field (matches igniffi C layout)
		if _, isArray := field.Type.(*schema.ArrayType); isArray {
			fmt.Fprintf(buf, "    uint16_t %s_len;\n", fieldName)
		}
		
		// If it's optional, add has_{field} boolean (matches igniffi C layout)
		if field.Type.IsOptional() {
			fmt.Fprintf(buf, "    bool has_%s;\n", fieldName)
		}
	}

	fmt.Fprintf(buf, "} %s;\n\n", structName)
}

func generateCFFIMessageType(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType) {
	msgName := toCIdentifier(msg.Name)
	structName := fmt.Sprintf("igniffi_%s", msgName)

	switch t := msg.TargetType.(type) {
	case *schema.StructType:
		// Struct messages - already defined in struct types, but we need the wrapper
		// Check if this struct is in Types or if it's anonymous
		found := false
		for _, typ := range s.Types {
			if st, ok := typ.(*schema.StructType); ok && st.Name == t.Name {
				found = true
				break
			}
		}
		if !found {
			// Anonymous struct, generate it here
			fmt.Fprintf(buf, "typedef struct {\n")
			for _, field := range t.Fields {
				fieldName := toCIdentifier(field.Name)
				cType := cffiCTypeForField(&field)
				fmt.Fprintf(buf, "    %s %s;\n", cType, fieldName)
				if _, isArray := field.Type.(*schema.ArrayType); isArray {
					fmt.Fprintf(buf, "    uint16_t %s_len;\n", fieldName)
				}
				if field.Type.IsOptional() {
					fmt.Fprintf(buf, "    bool has_%s;\n", fieldName)
				}
			}
			fmt.Fprintf(buf, "} %s;\n\n", structName)
		}

	case *schema.ArrayType:
		elemType := cffiCTypeForSchemaType(t.ElementType)
		fmt.Fprintf(buf, "typedef struct {\n")
		fmt.Fprintf(buf, "    %s* items;\n", elemType)
		fmt.Fprintf(buf, "    uint16_t len;\n")
		fmt.Fprintf(buf, "} %s;\n\n", structName)

	case *schema.PrimitiveType:
		primType := cffiCTypeForPrimitive(t)
		fmt.Fprintf(buf, "typedef struct {\n")
		fmt.Fprintf(buf, "    %s value;\n", primType)
		fmt.Fprintf(buf, "} %s;\n\n", structName)
	}
}

// generateCFFIBuilder generates the _ffi_build.py script
func generateCFFIBuilder(config *PackageConfig, pkgDir, pkgName string) error {
	buf := &bytes.Buffer{}
	schemaName := config.Schema.Package

	buf.WriteString(`# Code generated by ffire. DO NOT EDIT.
# CFFI builder script for igniffi Python bindings

from cffi import FFI
import os

ffibuilder = FFI()

# Read the C declarations
here = os.path.dirname(os.path.abspath(__file__))
with open(os.path.join(here, '_cffi_defs.h'), 'r') as f:
    cdef = f.read()

ffibuilder.cdef(cdef)

# Source code to compile
ffibuilder.set_source(
`)
	fmt.Fprintf(buf, "    '%s._igniffi',\n", pkgName)
	buf.WriteString(`    '''
    #include "igniffi.h"
    ''',
    include_dirs=['include'],
    sources=[
        'src/igniffi_arena.c',
`)
	fmt.Fprintf(buf, "        'src/igniffi_%s.c',\n", schemaName)
	buf.WriteString(`    ],
    extra_compile_args=['-O2'],
)

if __name__ == '__main__':
    ffibuilder.compile(verbose=True)
`)

	filePath := filepath.Join(pkgDir, "_ffi_build.py")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write _ffi_build.py: %w", err)
	}

	fmt.Println("✓ Generated _ffi_build.py (CFFI builder)")
	return nil
}

// generatePythonWrapper generates the main Python API module
func generatePythonWrapper(config *PackageConfig, pkgDir, pkgName string) error {
	s := config.Schema
	buf := &bytes.Buffer{}

	buf.WriteString(`"""
Code generated by ffire. DO NOT EDIT.
High-performance binary serialization using ffire format with CFFI.
"""

from __future__ import annotations
from typing import Optional, List, Union, Any
from dataclasses import dataclass
import numpy as np

# Import the compiled CFFI extension
from ._igniffi import ffi, lib


class FFIError(Exception):
    """Exception raised for FFI-related errors."""
    pass


class Arena:
    """Memory arena for zero-copy operations."""
    
    __slots__ = ('_ptr', '_disposed')
    
    def __init__(self, initial_size: int = 0):
        if initial_size > 0:
            self._ptr = lib.igniffi_arena_new_sized(initial_size)
        else:
            self._ptr = lib.igniffi_arena_new()
        self._disposed = False
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.dispose()
        return False
    
    def dispose(self):
        if not self._disposed and self._ptr != ffi.NULL:
            lib.igniffi_arena_free(self._ptr)
            self._ptr = ffi.NULL
            self._disposed = True
    
    def __del__(self):
        self.dispose()


def _check_status(status) -> None:
    """Check FFI status and raise exception if failed."""
    if not status.ok:
        msg = ffi.string(status.message).decode('utf-8') if status.message != ffi.NULL else 'Unknown error'
        raise FFIError(msg)


def _string_to_view(s: str, arena) -> 'ffi.CData':
    """Convert Python string to StringView (arena-allocated)."""
    encoded = s.encode('utf-8')
    data = ffi.from_buffer(encoded)
    view = ffi.new('igniffi_StringView*')
    view.data = data
    view.size = len(encoded)
    return view[0]


def _view_to_string(view) -> str:
    """Convert StringView to Python string."""
    if view.data == ffi.NULL or view.size == 0:
        return ''
    return ffi.buffer(view.data, view.size)[:].decode('utf-8')

`)

	// Generate struct dataclasses for pure Python representation
	sortedTypes := topSortStructTypes(s.Types)
	for _, structType := range sortedTypes {
		generatePythonDataclass(buf, s, structType)
	}

	// Generate message classes
	for _, msg := range s.Messages {
		generatePythonMessageClass(buf, s, &msg, pkgName)
	}

	// Write __init__.py
	filePath := filepath.Join(pkgDir, "__init__.py")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write __init__.py: %w", err)
	}

	fmt.Println("✓ Generated __init__.py (Python API)")
	return nil
}

func generatePythonDataclass(buf *bytes.Buffer, s *schema.Schema, structType *schema.StructType) {
	className := structType.Name
	fmt.Fprintf(buf, "\n@dataclass\n")
	fmt.Fprintf(buf, "class %s:\n", className)
	fmt.Fprintf(buf, "    \"\"\"%s data structure.\"\"\"\n", className)

	if len(structType.Fields) == 0 {
		buf.WriteString("    pass\n")
		return
	}

	for _, field := range structType.Fields {
		pyType := pythonTypeForField(s, &field)
		if field.Type.IsOptional() {
			fmt.Fprintf(buf, "    %s: Optional[%s] = None\n", field.Name, pyType)
		} else {
			defaultVal := pythonDefaultForType(s, field.Type)
			fmt.Fprintf(buf, "    %s: %s = %s\n", field.Name, pyType, defaultVal)
		}
	}
	buf.WriteString("\n")
}

func generatePythonMessageClass(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType, pkgName string) {
	className := msg.Name + "Message"
	msgName := toCIdentifier(msg.Name)
	structName := fmt.Sprintf("igniffi_%s", msgName)

	fmt.Fprintf(buf, "\nclass %s:\n", className)
	fmt.Fprintf(buf, "    \"\"\"\n")
	fmt.Fprintf(buf, "    %s encoder/decoder.\n", msg.Name)
	fmt.Fprintf(buf, "    \n")
	fmt.Fprintf(buf, "    This class provides high-performance encoding/decoding of %s messages\n", msg.Name)
	fmt.Fprintf(buf, "    using the ffire wire format via CFFI bindings.\n")
	fmt.Fprintf(buf, "    \"\"\"\n\n")

	fmt.Fprintf(buf, "    __slots__ = ('_arena', '_handle', '_disposed')\n\n")

	// Constructor
	buf.WriteString("    def __init__(self, handle, arena: Arena):\n")
	buf.WriteString("        self._handle = handle\n")
	buf.WriteString("        self._arena = arena\n")
	buf.WriteString("        self._disposed = False\n\n")

	// Static decode method
	buf.WriteString("    @classmethod\n")
	fmt.Fprintf(buf, "    def decode(cls, data: Union[bytes, bytearray, memoryview]) -> '%s':\n", className)
	buf.WriteString("        \"\"\"\n")
	buf.WriteString("        Decode binary data into a message.\n")
	buf.WriteString("        \n")
	buf.WriteString("        Args:\n")
	buf.WriteString("            data: Binary data to decode (bytes, bytearray, or memoryview)\n")
	buf.WriteString("        \n")
	buf.WriteString("        Returns:\n")
	fmt.Fprintf(buf, "            %s: Decoded message\n", className)
	buf.WriteString("        \n")
	buf.WriteString("        Raises:\n")
	buf.WriteString("            FFIError: If decoding fails\n")
	buf.WriteString("        \"\"\"\n")
	buf.WriteString("        if isinstance(data, memoryview):\n")
	buf.WriteString("            data = bytes(data)\n")
	buf.WriteString("        \n")
	buf.WriteString("        arena = Arena(len(data) * 2)\n")
	buf.WriteString("        status = ffi.new('igniffi_Status*')\n")
	buf.WriteString("        \n")
	fmt.Fprintf(buf, "        handle = lib.igniffi_decode_%s(data, len(data), arena._ptr, status)\n", msgName)
	buf.WriteString("        _check_status(status[0])\n")
	buf.WriteString("        \n")
	buf.WriteString("        if handle == ffi.NULL:\n")
	buf.WriteString("            arena.dispose()\n")
	buf.WriteString("            raise FFIError('Decode returned null')\n")
	buf.WriteString("        \n")
	fmt.Fprintf(buf, "        return cls(handle, arena)\n\n")

	// Encode method
	buf.WriteString("    def encode(self) -> bytes:\n")
	buf.WriteString("        \"\"\"\n")
	buf.WriteString("        Encode message to binary data.\n")
	buf.WriteString("        \n")
	buf.WriteString("        Returns:\n")
	buf.WriteString("            bytes: Encoded binary data\n")
	buf.WriteString("        \n")
	buf.WriteString("        Raises:\n")
	buf.WriteString("            FFIError: If encoding fails or message is disposed\n")
	buf.WriteString("        \"\"\"\n")
	buf.WriteString("        if self._disposed:\n")
	buf.WriteString("            raise FFIError('Message has been disposed')\n")
	buf.WriteString("        \n")
	buf.WriteString("        out_len = ffi.new('size_t*')\n")
	buf.WriteString("        status = ffi.new('igniffi_Status*')\n")
	buf.WriteString("        \n")
	fmt.Fprintf(buf, "        data_ptr = lib.igniffi_encode_%s(self._handle, out_len, self._arena._ptr, status)\n", msgName)
	buf.WriteString("        _check_status(status[0])\n")
	buf.WriteString("        \n")
	buf.WriteString("        if data_ptr == ffi.NULL:\n")
	buf.WriteString("            raise FFIError('Encode returned null')\n")
	buf.WriteString("        \n")
	buf.WriteString("        # Zero-copy view of arena memory\n")
	buf.WriteString("        return bytes(ffi.buffer(data_ptr, out_len[0]))\n\n")

	// Generate accessor properties based on target type
	generatePythonAccessors(buf, s, msg, structName)

	// Context manager support
	buf.WriteString("    def __enter__(self):\n")
	buf.WriteString("        return self\n\n")

	buf.WriteString("    def __exit__(self, exc_type, exc_val, exc_tb):\n")
	buf.WriteString("        self.dispose()\n")
	buf.WriteString("        return False\n\n")

	// Dispose method
	buf.WriteString("    def dispose(self):\n")
	buf.WriteString("        \"\"\"Free native resources. Call when done with the message.\"\"\"\n")
	buf.WriteString("        if not self._disposed:\n")
	buf.WriteString("            self._arena.dispose()\n")
	buf.WriteString("            self._handle = None\n")
	buf.WriteString("            self._disposed = True\n\n")

	buf.WriteString("    def __del__(self):\n")
	buf.WriteString("        self.dispose()\n\n")
}

func generatePythonAccessors(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType, structName string) {
	switch t := msg.TargetType.(type) {
	case *schema.StructType:
		// Generate property accessors for each field
		for _, field := range t.Fields {
			generatePythonFieldAccessor(buf, s, &field)
		}

	case *schema.ArrayType:
		// Array accessor
		elemPyType := pythonTypeForSchemaType(s, t.ElementType)
		buf.WriteString("    @property\n")
		fmt.Fprintf(buf, "    def items(self) -> List[%s]:\n", elemPyType)
		buf.WriteString("        \"\"\"Get array items.\"\"\"\n")
		buf.WriteString("        if self._disposed:\n")
		buf.WriteString("            raise FFIError('Message has been disposed')\n")
		buf.WriteString("        count = self._handle.len\n")
		buf.WriteString("        result = []\n")
		buf.WriteString("        for i in range(count):\n")
		generatePythonElementConversion(buf, s, t.ElementType, "self._handle.items[i]", "            ")
		buf.WriteString("            result.append(elem)\n")
		buf.WriteString("        return result\n\n")

		buf.WriteString("    def __len__(self) -> int:\n")
		buf.WriteString("        if self._disposed:\n")
		buf.WriteString("            raise FFIError('Message has been disposed')\n")
		buf.WriteString("        return self._handle.len\n\n")

		buf.WriteString("    def __iter__(self):\n")
		buf.WriteString("        return iter(self.items)\n\n")

	case *schema.PrimitiveType:
		pyType := pythonTypeForPrimitive(t)
		buf.WriteString("    @property\n")
		fmt.Fprintf(buf, "    def value(self) -> %s:\n", pyType)
		buf.WriteString("        \"\"\"Get the primitive value.\"\"\"\n")
		buf.WriteString("        if self._disposed:\n")
		buf.WriteString("            raise FFIError('Message has been disposed')\n")
		if t.Name == "string" {
			buf.WriteString("        return _view_to_string(self._handle.value)\n\n")
		} else {
			buf.WriteString("        return self._handle.value\n\n")
		}
	}
}

func generatePythonFieldAccessor(buf *bytes.Buffer, s *schema.Schema, field *schema.Field) {
	pyType := pythonTypeForField(s, field)
	pyFieldName := field.Name                  // Python property name (PascalCase for nice API)
	cFieldName := toCIdentifier(field.Name)    // C struct field name (snake_case)
	isOptional := field.Type.IsOptional()

	buf.WriteString("    @property\n")
	if isOptional {
		fmt.Fprintf(buf, "    def %s(self) -> Optional[%s]:\n", pyFieldName, pyType)
	} else {
		fmt.Fprintf(buf, "    def %s(self) -> %s:\n", pyFieldName, pyType)
	}
	fmt.Fprintf(buf, "        \"\"\"Get %s field.\"\"\"\n", pyFieldName)
	buf.WriteString("        if self._disposed:\n")
	buf.WriteString("            raise FFIError('Message has been disposed')\n")

	if isOptional {
		fmt.Fprintf(buf, "        if not self._handle.has_%s:\n", cFieldName)
		buf.WriteString("            return None\n")
	}

	// Convert from C type to Python type
	cAccess := fmt.Sprintf("self._handle.%s", cFieldName)
	generatePythonValueConversion(buf, s, field.Type, cAccess, "        ")
	buf.WriteString("\n")
}

func generatePythonValueConversion(buf *bytes.Buffer, s *schema.Schema, t schema.Type, cAccess, indent string) {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		if typ.Name == "string" {
			fmt.Fprintf(buf, "%sreturn _view_to_string(%s)\n", indent, cAccess)
		} else {
			fmt.Fprintf(buf, "%sreturn %s\n", indent, cAccess)
		}

	case *schema.StructType:
		// Return nested struct as dataclass
		className := typ.Name
		fmt.Fprintf(buf, "%sreturn %s(\n", indent, className)
		for i, field := range typ.Fields {
			cFieldName := toCIdentifier(field.Name)
			fieldAccess := fmt.Sprintf("%s.%s", cAccess, cFieldName)
			comma := ","
			if i == len(typ.Fields)-1 {
				comma = ""
			}
			if _, ok := field.Type.(*schema.PrimitiveType); ok {
				if field.Type.(*schema.PrimitiveType).Name == "string" {
					fmt.Fprintf(buf, "%s    %s=_view_to_string(%s)%s\n", indent, field.Name, fieldAccess, comma)
				} else {
					fmt.Fprintf(buf, "%s    %s=%s%s\n", indent, field.Name, fieldAccess, comma)
				}
			} else {
				// Nested complex type - simplified for now
				fmt.Fprintf(buf, "%s    %s=%s%s  # TODO: deep conversion\n", indent, field.Name, fieldAccess, comma)
			}
		}
		fmt.Fprintf(buf, "%s)\n", indent)

	case *schema.ArrayType:
		// Convert array
		fmt.Fprintf(buf, "%s_arr = []\n", indent)
		fmt.Fprintf(buf, "%sfor _i in range(%s.len):\n", indent, cAccess)
		generatePythonElementConversion(buf, s, typ.ElementType, fmt.Sprintf("%s.items[_i]", cAccess), indent+"    ")
		fmt.Fprintf(buf, "%s    _arr.append(elem)\n", indent)
		fmt.Fprintf(buf, "%sreturn _arr\n", indent)
	}
}

func generatePythonElementConversion(buf *bytes.Buffer, s *schema.Schema, elemType schema.Type, cAccess, indent string) {
	switch typ := elemType.(type) {
	case *schema.PrimitiveType:
		if typ.Name == "string" {
			fmt.Fprintf(buf, "%selem = _view_to_string(%s)\n", indent, cAccess)
		} else {
			fmt.Fprintf(buf, "%selem = %s\n", indent, cAccess)
		}
	case *schema.StructType:
		className := typ.Name
		fmt.Fprintf(buf, "%selem = %s(", indent, className)
		for i, field := range typ.Fields {
			comma := ", "
			if i == len(typ.Fields)-1 {
				comma = ""
			}
			cFieldName := toCIdentifier(field.Name)
			fieldAccess := fmt.Sprintf("%s.%s", cAccess, cFieldName)
			if prim, ok := field.Type.(*schema.PrimitiveType); ok && prim.Name == "string" {
				fmt.Fprintf(buf, "%s=_view_to_string(%s)%s", field.Name, fieldAccess, comma)
			} else {
				fmt.Fprintf(buf, "%s=%s%s", field.Name, fieldAccess, comma)
			}
		}
		buf.WriteString(")\n")
	default:
		fmt.Fprintf(buf, "%selem = %s  # complex type\n", indent, cAccess)
	}
}

// generatePyProjectTOML generates pyproject.toml for modern Python packaging
func generatePyProjectTOML(config *PackageConfig, pyDir, pkgName string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("[build-system]\n")
	buf.WriteString("requires = [\"setuptools>=45\", \"wheel\", \"cffi>=1.0.0\"]\n")
	buf.WriteString("build-backend = \"setuptools.build_meta\"\n\n")

	buf.WriteString("[project]\n")
	fmt.Fprintf(buf, "name = \"%s\"\n", pkgName)
	buf.WriteString("version = \"1.0.0\"\n")
	buf.WriteString("description = \"ffire serialization bindings via CFFI\"\n")
	buf.WriteString("readme = \"README.md\"\n")
	buf.WriteString("requires-python = \">=3.8\"\n")
	buf.WriteString("license = \"MIT\"\n")
	buf.WriteString("keywords = [\"ffire\", \"serialization\", \"binary\", \"ffi\"]\n\n")

	buf.WriteString("dependencies = [\n")
	buf.WriteString("    \"cffi>=1.0.0\",\n")
	buf.WriteString("    \"numpy>=1.19.0\",\n")
	buf.WriteString("]\n\n")

	buf.WriteString("[project.optional-dependencies]\n")
	buf.WriteString("dev = [\n")
	buf.WriteString("    \"pytest>=6.0.0\",\n")
	buf.WriteString("    \"pytest-benchmark>=3.4.0\",\n")
	buf.WriteString("]\n")

	filePath := filepath.Join(pyDir, "pyproject.toml")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write pyproject.toml: %w", err)
	}

	fmt.Println("✓ Generated pyproject.toml")
	return nil
}

// generateSetupPy generates setup.py for CFFI compilation
func generateSetupPy(config *PackageConfig, pyDir, pkgName string) error {
	buf := &bytes.Buffer{}

	buf.WriteString(`# Code generated by ffire. DO NOT EDIT.
from setuptools import setup, find_packages

# CFFI compilation happens at install time
setup(
`)
	fmt.Fprintf(buf, "    name='%s',\n", pkgName)
	buf.WriteString(`    version='1.0.0',
    packages=find_packages(),
    install_requires=['cffi>=1.0.0', 'numpy>=1.19.0'],
    setup_requires=['cffi>=1.0.0'],
    cffi_modules=[
`)
	fmt.Fprintf(buf, "        '%s/_ffi_build.py:ffibuilder',\n", pkgName)
	buf.WriteString(`    ],
    zip_safe=False,
)
`)

	filePath := filepath.Join(pyDir, "setup.py")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write setup.py: %w", err)
	}

	fmt.Println("✓ Generated setup.py")
	return nil
}

// generatePythonReadme generates README.md
func generatePythonReadme(config *PackageConfig, pyDir, pkgName string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, "# %s - ffire Python Bindings\n\n", pkgName)
	buf.WriteString("High-performance binary serialization using ffire format with CFFI.\n\n")

	buf.WriteString("## Installation\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("pip install .\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Requirements\n\n")
	buf.WriteString("- Python 3.8+\n")
	buf.WriteString("- C compiler (for building the extension)\n")
	buf.WriteString("- CFFI library (installed automatically)\n\n")

	buf.WriteString("## Usage\n\n")
	buf.WriteString("```python\n")
	fmt.Fprintf(buf, "from %s import %sMessage\n\n", pkgName, config.Schema.Messages[0].Name)

	buf.WriteString("# Decode binary data\n")
	buf.WriteString("with open('data.bin', 'rb') as f:\n")
	buf.WriteString("    data = f.read()\n\n")

	fmt.Fprintf(buf, "with %sMessage.decode(data) as msg:\n", config.Schema.Messages[0].Name)
	buf.WriteString("    # Access fields\n")
	buf.WriteString("    print(msg)  # Message is auto-disposed on exit\n\n")

	buf.WriteString("# Or manual management\n")
	fmt.Fprintf(buf, "msg = %sMessage.decode(data)\n", config.Schema.Messages[0].Name)
	buf.WriteString("encoded = msg.encode()\n")
	buf.WriteString("msg.dispose()  # Free native resources\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## API\n\n")
	for _, msg := range config.Schema.Messages {
		className := msg.Name + "Message"
		fmt.Fprintf(buf, "### %s\n\n", className)
		fmt.Fprintf(buf, "- **`decode(data: bytes) -> %s`** - Decode binary data\n", className)
		buf.WriteString("- **`encode() -> bytes`** - Encode to binary\n")
		buf.WriteString("- **`dispose()`** - Free native resources\n")
		buf.WriteString("- Context manager support (`with` statement)\n\n")
	}

	buf.WriteString("## Performance\n\n")
	buf.WriteString("CFFI API mode provides near-native performance:\n")
	buf.WriteString("- ~10-50x faster than ctypes\n")
	buf.WriteString("- Zero-copy buffer access via `ffi.buffer()`\n")
	buf.WriteString("- GIL released during native calls for true parallelism\n\n")

	buf.WriteString("## Type Precision\n\n")
	buf.WriteString("Full type precision is maintained:\n")
	buf.WriteString("- `int8`, `int16`, `int32`, `int64`\n")
	buf.WriteString("- `uint8`, `uint16`, `uint32`, `uint64`\n")
	buf.WriteString("- `float32`, `float64`\n")
	buf.WriteString("- `bool`, `string`\n\n")

	buf.WriteString("## License\n\n")
	buf.WriteString("Generated by ffire\n")

	filePath := filepath.Join(pyDir, "README.md")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	fmt.Println("✓ Generated README.md")
	return nil
}

func compilePythonExtension(config *PackageConfig, pyDir string) error {
	// Try to find python3
	pythonCmd := "python3"
	if _, err := exec.LookPath(pythonCmd); err != nil {
		pythonCmd = "python"
		if _, err := exec.LookPath(pythonCmd); err != nil {
			return fmt.Errorf("python not found in PATH")
		}
	}

	// Run pip install in development mode
	cmd := exec.Command(pythonCmd, "-m", "pip", "install", "-e", ".")
	cmd.Dir = pyDir

	// On macOS, we might need to set architecture
	if runtime.GOOS == "darwin" {
		cmd.Env = append(os.Environ(), fmt.Sprintf("ARCHFLAGS=-arch %s", runtime.GOARCH))
	}

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("pip install failed: %w\nOutput: %s", err, string(output))
	}

	fmt.Println("✓ Compiled Python extension")
	return nil
}

func printPythonInstructions(config *PackageConfig, pyDir, pkgName string) {
	fmt.Printf("\n✅ Python package ready at: %s\n\n", pyDir)
	fmt.Println("Install the package:")
	fmt.Printf("  cd %s\n", pyDir)
	fmt.Println("  pip install .")
	fmt.Println()
	fmt.Println("Or install in development mode:")
	fmt.Println("  pip install -e .")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  from %s import %sMessage\n", pkgName, config.Schema.Messages[0].Name)
	fmt.Println()
	fmt.Printf("  with %sMessage.decode(data) as msg:\n", config.Schema.Messages[0].Name)
	fmt.Println("      encoded = msg.encode()")
	fmt.Println()
}

// Helper functions

func toPythonIdentifier(name string) string {
	// Python package names should be lowercase with underscores
	var result strings.Builder
	for i, r := range name {
		if r >= 'A' && r <= 'Z' {
			if i > 0 {
				result.WriteRune('_')
			}
			result.WriteRune(r + 32) // lowercase
		} else if r == '-' {
			result.WriteRune('_')
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func cffiCTypeForField(field *schema.Field) string {
	return cffiCTypeForSchemaType(field.Type)
}

func cffiCTypeForSchemaType(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return cffiCTypeForPrimitive(typ)
	case *schema.StructType:
		return fmt.Sprintf("igniffi_%s", toCIdentifier(typ.Name))
	case *schema.ArrayType:
		// Arrays are represented as struct with items pointer + count
		return "void*" // Simplified - actual type depends on context
	default:
		return "void*"
	}
}

func cffiCTypeForPrimitive(p *schema.PrimitiveType) string {
	switch p.Name {
	case "bool":
		return "bool"
	case "int8":
		return "int8_t"
	case "int16":
		return "int16_t"
	case "int32":
		return "int32_t"
	case "int64":
		return "int64_t"
	case "uint8":
		return "uint8_t"
	case "uint16":
		return "uint16_t"
	case "uint32":
		return "uint32_t"
	case "uint64":
		return "uint64_t"
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "string":
		return "igniffi_StringView"
	default:
		return "void*"
	}
}

func pythonTypeForField(s *schema.Schema, field *schema.Field) string {
	return pythonTypeForSchemaType(s, field.Type)
}

func pythonTypeForSchemaType(s *schema.Schema, t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return pythonTypeForPrimitive(typ)
	case *schema.StructType:
		return typ.Name
	case *schema.ArrayType:
		elemType := pythonTypeForSchemaType(s, typ.ElementType)
		return fmt.Sprintf("List[%s]", elemType)
	default:
		return "Any"
	}
}

func pythonTypeForPrimitive(p *schema.PrimitiveType) string {
	switch p.Name {
	case "bool":
		return "bool"
	case "int8", "int16", "int32", "int64":
		return "int"
	case "uint8", "uint16", "uint32", "uint64":
		return "int"
	case "float32", "float64":
		return "float"
	case "string":
		return "str"
	default:
		return "Any"
	}
}

func pythonDefaultForType(s *schema.Schema, t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			return "False"
		case "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64":
			return "0"
		case "float32", "float64":
			return "0.0"
		case "string":
			return "''"
		}
	case *schema.ArrayType:
		return "None"  // Use None for mutable default
	case *schema.StructType:
		return "None"  // Use factory for mutable defaults
	}
	return "None"
}
