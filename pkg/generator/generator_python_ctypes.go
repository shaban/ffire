package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// generatePythonWrapper generates the ctypes wrapper module
func generatePythonWrapper(config *PackageConfig, packageDir string) error {
	buf := &bytes.Buffer{}

	// Generated code header
	buf.WriteString("# Code generated by ffire. DO NOT EDIT.\n\n")

	// Module docstring
	fmt.Fprintf(buf, `"""
FFire %s bindings using ctypes.

This module provides Python bindings to the FFire binary serialization library
via a C ABI dynamic library.
"""

import ctypes
import os
import platform
from typing import List, Optional

`, config.Schema.Package)

	// Determine library name based on platform
	buf.WriteString("# Determine library name based on platform\n")
	buf.WriteString("_lib_name = {\n")
	fmt.Fprintf(buf, "    'Darwin': 'lib%s.dylib',\n", config.Schema.Package)
	fmt.Fprintf(buf, "    'Linux': 'lib%s.so',\n", config.Schema.Package)
	fmt.Fprintf(buf, "    'Windows': '%s.dll'\n", config.Schema.Package)
	fmt.Fprintf(buf, "}.get(platform.system(), 'lib%s.so')\n\n", config.Schema.Package)

	// Load library
	buf.WriteString("# Load the C library\n")
	buf.WriteString("_lib_path = os.path.join(os.path.dirname(__file__), _lib_name)\n")
	buf.WriteString("_lib = ctypes.CDLL(_lib_path)\n\n")

	// Generate bindings for each message type
	for _, msg := range config.Schema.Messages {
		if err := generatePythonMessageBindings(buf, config.Schema, &msg); err != nil {
			return err
		}
	}

	// Write to file
	wrapperPath := filepath.Join(packageDir, "bindings.py")
	if err := os.WriteFile(wrapperPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write Python wrapper: %w", err)
	}

	fmt.Printf("✓ Generated Python bindings: %s\n", wrapperPath)
	return nil
}

func generatePythonMessageBindings(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType) error {
	handleName := msg.Name + "Handle"
	baseName := strings.ToLower(msg.Name) // All lowercase to match C ABI

	// Define C types
	buf.WriteString("# Handle type\n")
	fmt.Fprintf(buf, "%s = ctypes.c_void_p\n\n", handleName)

	// Define function signatures
	buf.WriteString("# Decode function\n")
	fmt.Fprintf(buf, "_lib.%s_decode.argtypes = [ctypes.POINTER(ctypes.c_uint8), ctypes.c_size_t, ctypes.POINTER(ctypes.c_char_p)]\n", baseName)
	fmt.Fprintf(buf, "_lib.%s_decode.restype = %s\n\n", baseName, handleName)

	buf.WriteString("# Encode function\n")
	fmt.Fprintf(buf, "_lib.%s_encode.argtypes = [%s, ctypes.POINTER(ctypes.POINTER(ctypes.c_uint8)), ctypes.POINTER(ctypes.c_char_p)]\n", baseName, handleName)
	fmt.Fprintf(buf, "_lib.%s_encode.restype = ctypes.c_size_t\n\n", baseName)

	buf.WriteString("# Memory management functions\n")
	fmt.Fprintf(buf, "_lib.%s_free.argtypes = [%s]\n", baseName, handleName)
	fmt.Fprintf(buf, "_lib.%s_free.restype = None\n", baseName)
	fmt.Fprintf(buf, "_lib.%s_free_data.argtypes = [ctypes.POINTER(ctypes.c_uint8)]\n", baseName)
	fmt.Fprintf(buf, "_lib.%s_free_data.restype = None\n", baseName)
	fmt.Fprintf(buf, "_lib.%s_free_error.argtypes = [ctypes.c_char_p]\n", baseName)
	fmt.Fprintf(buf, "_lib.%s_free_error.restype = None\n\n", baseName)

	// Generate Python class wrapper with Message suffix to avoid keyword collisions
	className := msg.Name + "Message"
	fmt.Fprintf(buf, "class %s:\n", className)
	fmt.Fprintf(buf, `    """Wrapper for %s message type."""
    
    def __init__(self, handle: %s):
        self._handle = handle
    
    def __del__(self):
        if hasattr(self, '_handle') and self._handle:
            _lib.%s_free(self._handle)
    
    @staticmethod
    def decode(data: bytes) -> '%s':
        """Decode a %s from binary data."""
        data_array = (ctypes.c_uint8 * len(data)).from_buffer_copy(data)
        error = ctypes.c_char_p()
        
        handle = _lib.%s_decode(data_array, len(data), ctypes.byref(error))
        
        if not handle:
            error_msg = error.value.decode('utf-8') if error.value else 'Unknown error'
            if error:
                _lib.%s_free_error(error)
            raise RuntimeError(f"Failed to decode %s: {error_msg}")
        
        return %s(handle)
    
    def encode(self) -> bytes:
        """Encode this %s to binary data."""
        encoded_data = ctypes.POINTER(ctypes.c_uint8)()
        error = ctypes.c_char_p()
        
        size = _lib.%s_encode(self._handle, ctypes.byref(encoded_data), ctypes.byref(error))
        
        if size == 0:
            error_msg = error.value.decode('utf-8') if error.value else 'Unknown error'
            if error:
                _lib.%s_free_error(error)
            raise RuntimeError(f"Failed to encode %s: {error_msg}")
        
        # Copy data to Python bytes
        result = bytes(encoded_data[:size])
        _lib.%s_free_data(encoded_data)
        
        return result

`, className, handleName, baseName, className, className, baseName, baseName, className, className, className, baseName, baseName, className, baseName)

	return nil
}

// generatePythonSetup generates setup.py for the package
func generatePythonSetup(config *PackageConfig, langDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `from setuptools import setup, find_packages
import platform

# Determine which library to include based on platform
data_files = []
system = platform.system()
if system == 'Darwin':
    data_files = ['%%s/lib%s.dylib']
elif system == 'Linux':
    data_files = ['%%s/lib%s.so']
elif system == 'Windows':
    data_files = ['%%s/%s.dll']

setup(
    name='%s',
    version='1.0.0',
    description='FFire binary serialization library - %s schema',
    author='Generated by FFire',
    packages=find_packages(),
    package_data={
        '%s': data_files,
    },
    python_requires='>=3.7',
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
    ],
)
`, config.Namespace, config.Namespace, config.Namespace, config.Namespace, config.Schema.Package, config.Namespace)

	setupPath := filepath.Join(langDir, "setup.py")
	if err := os.WriteFile(setupPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write setup.py: %w", err)
	}

	fmt.Printf("✓ Generated setup.py: %s\n", setupPath)
	return nil
}

// generatePythonInit generates __init__.py for the package
func generatePythonInit(config *PackageConfig, packageDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `"""
%s - FFire bindings for %s schema.
"""

from .bindings import (
`, config.Namespace, config.Schema.Package)

	// Import all message types (with Message suffix)
	for i, msg := range config.Schema.Messages {
		if i > 0 {
			buf.WriteString(",\n")
		}
		fmt.Fprintf(buf, "    %sMessage", msg.Name)
	}

	buf.WriteString(",\n)\n\n__all__ = [\n")

	for i, msg := range config.Schema.Messages {
		if i > 0 {
			buf.WriteString(",\n")
		}
		fmt.Fprintf(buf, "    '%sMessage'", msg.Name)
	}

	buf.WriteString(",\n]\n")

	initPath := filepath.Join(packageDir, "__init__.py")
	if err := os.WriteFile(initPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write __init__.py: %w", err)
	}

	fmt.Printf("✓ Generated __init__.py: %s\n", initPath)
	return nil
}

// GeneratePythonCtypesPackage generates a complete Python package using ctypes (fallback option)
func GeneratePythonCtypesPackage(config *PackageConfig) error {
	return orchestrateTierBPackage(
		config,
		PythonLayout,
		generatePythonWrapperOrchestrated,
		generatePythonMetadataOrchestrated,
		printPythonInstructions,
	)
}

func generatePythonWrapperOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate Python bindings
	if err := generatePythonWrapper(config, paths.Package); err != nil {
		return err
	}

	// Generate __init__.py
	if err := generatePythonInit(config, paths.Package); err != nil {
		return err
	}

	return nil
}

func generatePythonMetadataOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate setup.py
	if err := generatePythonSetup(config, paths.Root); err != nil {
		return err
	}

	// Generate README.md
	if err := generatePythonReadme(config, paths.Root); err != nil {
		return err
	}

	return nil
}

func printPythonInstructions(config *PackageConfig, paths *PackagePaths) {
	fmt.Printf("\n✅ Python package ready at: %s\n\n", paths.Root)
	fmt.Println("Installation:")
	fmt.Printf("  cd %s\n\n", paths.Root)
	fmt.Println("  # Recommended: Use a virtual environment")
	fmt.Println("  python3 -m venv venv")
	fmt.Println("  source venv/bin/activate  # On Windows: venv\\Scripts\\activate")
	fmt.Println("  pip install .")
	fmt.Println()
	fmt.Println("  # Alternative: Install for current user only")
	fmt.Println("  pip install --user .")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  from %s import Message\n", config.Namespace)
	fmt.Println("  msg = Message.decode(data)")
	fmt.Println("  encoded = msg.encode()")
	fmt.Println()
}

// generatePythonReadme generates a comprehensive README for the Python package
func generatePythonReadme(config *PackageConfig, langDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `# %s - FFire Python Bindings

Python bindings for the %s schema, generated by [FFire](https://github.com/shaban/ffire).

## Installation

### Recommended: Virtual Environment

`, config.Namespace, config.Schema.Package)

	buf.WriteString("```bash\n")
	fmt.Fprintf(buf, "cd %s\n", filepath.Base(langDir))
	buf.WriteString("python3 -m venv venv\n")
	buf.WriteString("source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n")
	buf.WriteString("pip install .\n")
	buf.WriteString("```\n\n")

	buf.WriteString("### Alternative: User Installation\n\n")
	buf.WriteString("If you don't want to use a virtual environment:\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("pip install --user .\n")
	buf.WriteString("```\n\n")

	buf.WriteString("### System Python Warning\n\n")
	buf.WriteString("If you see a warning about \"externally managed environment\" (PEP 668), this is normal on some systems (Homebrew Python, modern Linux). Use one of the methods above - the virtual environment approach is recommended.\n\n")

	buf.WriteString("## Usage\n\n")
	buf.WriteString("```python\n")
	fmt.Fprintf(buf, "from %s import Message\n\n", config.Namespace)
	buf.WriteString("# Decode from binary\n")
	buf.WriteString("with open('data.bin', 'rb') as f:\n")
	buf.WriteString("    data = f.read()\n\n")
	buf.WriteString("msg = Message.decode(data)\n\n")
	buf.WriteString("# Encode back to binary\n")
	buf.WriteString("encoded = msg.encode()\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## API\n\n")

	for _, msg := range config.Schema.Messages {
		fmt.Fprintf(buf, "### `%s`\n\n", msg.Name)
		fmt.Fprintf(buf, "**`%s.decode(data: bytes) -> %s`**\n\n", msg.Name, msg.Name)
		fmt.Fprintf(buf, "Decode a `%s` from binary data.\n\n", msg.Name)
		buf.WriteString("- **Parameters:** `data` - Binary data (bytes)\n")
		fmt.Fprintf(buf, "- **Returns:** `%s` object\n", msg.Name)
		buf.WriteString("- **Raises:** `RuntimeError` if decoding fails\n\n")

		fmt.Fprintf(buf, "**`%s.encode() -> bytes`**\n\n", msg.Name)
		fmt.Fprintf(buf, "Encode this `%s` to binary data.\n\n", msg.Name)
		buf.WriteString("- **Returns:** Binary data (bytes)\n")
		buf.WriteString("- **Raises:** `RuntimeError` if encoding fails\n\n")
	}

	buf.WriteString("## Platform Support\n\n")
	buf.WriteString("This package includes pre-compiled libraries for:\n\n")
	fmt.Fprintf(buf, "- macOS (Darwin): `lib%s.dylib`\n", config.Schema.Package)
	fmt.Fprintf(buf, "- Linux: `lib%s.so`\n", config.Schema.Package)
	fmt.Fprintf(buf, "- Windows: `%s.dll`\n\n", config.Schema.Package)
	buf.WriteString("The correct library is automatically loaded based on your platform.\n\n")

	buf.WriteString("## Requirements\n\n")
	buf.WriteString("- Python 3.7 or higher\n")
	buf.WriteString("- ctypes (included in Python standard library)\n\n")

	buf.WriteString("## License\n\n")
	buf.WriteString("Generated by FFire. See your schema's license for terms.\n")

	readmePath := filepath.Join(langDir, "README.md")
	if err := os.WriteFile(readmePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	fmt.Printf("✓ Generated README.md: %s\n", readmePath)
	return nil
}
