package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateJavaScriptPackage generates a complete Node.js package with N-API bindings
func GenerateJavaScriptPackage(config *PackageConfig) error {
	return orchestrateTierBPackage(
		config,
		JavaScriptLayout,
		generateJavaScriptWrapperOrchestrated,
		generateJavaScriptMetadataOrchestrated,
		printJavaScriptInstructions,
	)
}

func generateJavaScriptWrapperOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate N-API C++ binding
	if err := generateNAPIBinding(config, paths); err != nil {
		return err
	}

	// Generate JavaScript wrapper
	if err := generateJavaScriptWrapper(config, paths.Root); err != nil {
		return err
	}

	// Generate TypeScript definitions
	return generateTypeScriptDefinitions(config, paths.Root)
}

func generateJavaScriptMetadataOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate package.json
	if err := generatePackageJSON(config, paths.Root); err != nil {
		return err
	}

	// Generate binding.gyp for node-gyp
	if err := generateBindingGyp(config, paths.Root); err != nil {
		return err
	}

	// Generate README.md
	return generateJavaScriptReadme(config, paths.Root)
}

func printJavaScriptInstructions(config *PackageConfig, paths *PackagePaths) {
	fmt.Printf("\nâœ… Node.js package ready at: %s\n\n", paths.Root)
	fmt.Println("Build:")
	fmt.Printf("  cd %s\n", paths.Root)
	fmt.Println("  npm install  # Automatically builds native addon")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  const { ConfigMessage } = require('./');\n\n")
	fmt.Println("  const msg = ConfigMessage.decode(buffer);")
	fmt.Println("  const encoded = msg.encode();")
	fmt.Println()
}

// generateNAPIBinding generates the N-API C++ binding file
func generateNAPIBinding(config *PackageConfig, paths *PackagePaths) error {
	buf := &bytes.Buffer{}

	// Header
	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")
	buf.WriteString("#include <napi.h>\n")
	buf.WriteString("#include \"include/generated.hpp\"\n")
	buf.WriteString("#include <vector>\n")
	buf.WriteString("#include <string>\n\n")
	fmt.Fprintf(buf, "using namespace %s;\n\n", config.Schema.Package)

	// Generate encode/decode functions for each message type
	for _, msg := range config.Schema.Messages {
		if err := generateNAPIMessageFunctions(buf, &msg); err != nil {
			return err
		}
	}

	// Generate module initialization
	buf.WriteString("Napi::Object Init(Napi::Env env, Napi::Object exports) {\n")
	for _, msg := range config.Schema.Messages {
		msgName := msg.Name + "Message"
		fmt.Fprintf(buf, "  exports.Set(\"encode%s\", Napi::Function::New(env, Encode%s));\n", msgName, msgName)
		fmt.Fprintf(buf, "  exports.Set(\"decode%s\", Napi::Function::New(env, Decode%s));\n", msgName, msgName)
	}
	buf.WriteString("  return exports;\n")
	buf.WriteString("}\n\n")

	fmt.Fprintf(buf, "NODE_API_MODULE(%s, Init)\n", config.Schema.Package)

	// Write binding.cpp
	bindingPath := filepath.Join(paths.Root, "binding.cpp")
	return os.WriteFile(bindingPath, buf.Bytes(), 0644)
}

// generateNAPIMessageFunctions generates encode/decode functions for a message type
func generateNAPIMessageFunctions(buf *bytes.Buffer, msg *schema.MessageType) error {
	msgName := msg.Name + "Message"
	cppTypeName := msg.Name // C++ struct name (without Message suffix)
	structType, ok := msg.TargetType.(*schema.StructType)
	if !ok {
		// Handle array and primitive types
		return generateNAPIArrayOrPrimitiveFunctions(buf, msg)
	}

	// Generate Decode function (Buffer -> JS Object)
	fmt.Fprintf(buf, "// Decode %s from Buffer to JS Object\n", msgName)
	fmt.Fprintf(buf, "Napi::Value Decode%s(const Napi::CallbackInfo& info) {\n", msgName)
	buf.WriteString("  Napi::Env env = info.Env();\n\n")

	buf.WriteString("  if (info.Length() < 1 || !info[0].IsBuffer()) {\n")
	buf.WriteString("    Napi::TypeError::New(env, \"Buffer expected\").ThrowAsJavaScriptException();\n")
	buf.WriteString("    return env.Null();\n")
	buf.WriteString("  }\n\n")

	buf.WriteString("  Napi::Buffer<uint8_t> buffer = info[0].As<Napi::Buffer<uint8_t>>();\n\n")

	// Call C++ decode function
	fmt.Fprintf(buf, "  %s msg = decode_%s_message(buffer.Data(), buffer.Length());\n\n", cppTypeName, strings.ToLower(msg.Name))

	// Create JS object from C++ struct
	buf.WriteString("  Napi::Object obj = Napi::Object::New(env);\n")
	for _, field := range structType.Fields {
		if err := generateFieldToJS(buf, &field, "msg"); err != nil {
			return err
		}
	}

	buf.WriteString("  return obj;\n")
	buf.WriteString("}\n\n")

	// Generate Encode function (JS Object -> Buffer)
	fmt.Fprintf(buf, "// Encode %s from JS Object to Buffer\n", msgName)
	fmt.Fprintf(buf, "Napi::Value Encode%s(const Napi::CallbackInfo& info) {\n", msgName)
	buf.WriteString("  Napi::Env env = info.Env();\n\n")

	buf.WriteString("  if (info.Length() < 1 || !info[0].IsObject()) {\n")
	buf.WriteString("    Napi::TypeError::New(env, \"Object expected\").ThrowAsJavaScriptException();\n")
	buf.WriteString("    return env.Null();\n")
	buf.WriteString("  }\n\n")

	buf.WriteString("  Napi::Object obj = info[0].As<Napi::Object>();\n\n")

	// Check if we need lossless variable for BigInt conversions
	needsLossless := false
	for _, field := range structType.Fields {
		if primType, ok := field.Type.(*schema.PrimitiveType); ok {
			if primType.Name == "int64" || primType.Name == "uint64" {
				needsLossless = true
				break
			}
		}
	}
	if needsLossless {
		buf.WriteString("  bool lossless;\n")
	}

	// Create C++ struct from JS object
	fmt.Fprintf(buf, "  %s msg;\n", cppTypeName)
	for _, field := range structType.Fields {
		if err := generateFieldFromJS(buf, &field); err != nil {
			return err
		}
	}

	// Call C++ encode function
	fmt.Fprintf(buf, "  std::vector<uint8_t> encoded = encode_%s_message(msg);\n\n", strings.ToLower(msg.Name))

	// Return as Buffer
	buf.WriteString("  return Napi::Buffer<uint8_t>::Copy(env, encoded.data(), encoded.size());\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateFieldToJS converts a C++ field to JavaScript
func generateFieldToJS(buf *bytes.Buffer, field *schema.Field, structVar string) error {
	jsFieldName := field.Name
	cppFieldName := field.Name // C++ uses original field names from schema

	switch t := field.Type.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "string":
			fmt.Fprintf(buf, "  obj.Set(\"%s\", Napi::String::New(env, %s.%s));\n", jsFieldName, structVar, cppFieldName)
		case "bool":
			fmt.Fprintf(buf, "  obj.Set(\"%s\", Napi::Boolean::New(env, %s.%s));\n", jsFieldName, structVar, cppFieldName)
		case "int32", "uint32", "float32", "float64":
			fmt.Fprintf(buf, "  obj.Set(\"%s\", Napi::Number::New(env, %s.%s));\n", jsFieldName, structVar, cppFieldName)
		case "int64", "uint64":
			fmt.Fprintf(buf, "  obj.Set(\"%s\", Napi::BigInt::New(env, %s.%s));\n", jsFieldName, structVar, cppFieldName)
		}
	case *schema.ArrayType:
		// Generate array conversion
		fmt.Fprintf(buf, "  {\n")
		fmt.Fprintf(buf, "    Napi::Array arr = Napi::Array::New(env, %s.%s.size());\n", structVar, cppFieldName)
		fmt.Fprintf(buf, "    for (size_t i = 0; i < %s.%s.size(); i++) {\n", structVar, cppFieldName)

		elemType, ok := t.ElementType.(*schema.PrimitiveType)
		if ok {
			switch elemType.Name {
			case "string":
				fmt.Fprintf(buf, "      arr[i] = Napi::String::New(env, %s.%s[i]);\n", structVar, cppFieldName)
			case "bool":
				fmt.Fprintf(buf, "      arr[i] = Napi::Boolean::New(env, %s.%s[i]);\n", structVar, cppFieldName)
			case "int32", "uint32", "float32", "float64":
				fmt.Fprintf(buf, "      arr[i] = Napi::Number::New(env, %s.%s[i]);\n", structVar, cppFieldName)
			case "int64", "uint64":
				fmt.Fprintf(buf, "      arr[i] = Napi::BigInt::New(env, %s.%s[i]);\n", structVar, cppFieldName)
			}
		}
		fmt.Fprintf(buf, "    }\n")
		fmt.Fprintf(buf, "    obj.Set(\"%s\", arr);\n", jsFieldName)
		fmt.Fprintf(buf, "  }\n")
	case *schema.StructType:
		// Nested struct - create nested object
		fmt.Fprintf(buf, "  {\n")
		fmt.Fprintf(buf, "    Napi::Object nested = Napi::Object::New(env);\n")
		for _, nestedField := range t.Fields {
			nestedVar := structVar + "." + cppFieldName
			// Create temporary buffer for nested field generation
			nestedBuf := &bytes.Buffer{}
			if err := generateFieldToJS(nestedBuf, &nestedField, nestedVar); err != nil {
				return err
			}
			// Replace obj.Set with nested.Set
			nestedCode := strings.ReplaceAll(nestedBuf.String(), "  obj.Set", "    nested.Set")
			buf.WriteString(nestedCode)
		}
		fmt.Fprintf(buf, "    obj.Set(\"%s\", nested);\n", jsFieldName)
		fmt.Fprintf(buf, "  }\n")
	}

	// Handle optional types by checking IsOptional on the field's type
	if field.Type.IsOptional() {
		// Wrap generated code in optional check
		fmt.Fprintf(buf, "  if (%s.%s.has_value()) {\n", structVar, cppFieldName)
		fmt.Fprintf(buf, "    // Generated optional field code here\n")
		fmt.Fprintf(buf, "  } else {\n")
		fmt.Fprintf(buf, "    obj.Set(\"%s\", env.Null());\n", jsFieldName)
		fmt.Fprintf(buf, "  }\n")
	}

	return nil
}

// generateFieldFromJS converts a JavaScript field to C++
func generateFieldFromJS(buf *bytes.Buffer, field *schema.Field) error {
	jsFieldName := field.Name
	cppFieldName := field.Name // C++ uses original field names from schema

	switch t := field.Type.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "string":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::String>().Utf8Value();\n", cppFieldName, jsFieldName)
		case "bool":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::Boolean>().Value();\n", cppFieldName, jsFieldName)
		case "int32":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::Number>().Int32Value();\n", cppFieldName, jsFieldName)
		case "uint32":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::Number>().Uint32Value();\n", cppFieldName, jsFieldName)
		case "float32", "float64":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::Number>().FloatValue();\n", cppFieldName, jsFieldName)
		case "int64":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::BigInt>().Int64Value(&lossless);\n", cppFieldName, jsFieldName)
		case "uint64":
			fmt.Fprintf(buf, "  msg.%s = obj.Get(\"%s\").As<Napi::BigInt>().Uint64Value(&lossless);\n", cppFieldName, jsFieldName)
		}
	case *schema.ArrayType:
		fmt.Fprintf(buf, "  {\n")
		fmt.Fprintf(buf, "    Napi::Array arr = obj.Get(\"%s\").As<Napi::Array>();\n", jsFieldName)
		fmt.Fprintf(buf, "    msg.%s.reserve(arr.Length());\n", cppFieldName)
		fmt.Fprintf(buf, "    for (uint32_t i = 0; i < arr.Length(); i++) {\n")

		elemType, ok := t.ElementType.(*schema.PrimitiveType)
		if ok {
			switch elemType.Name {
			case "string":
				fmt.Fprintf(buf, "      msg.%s.push_back(arr.Get(i).As<Napi::String>().Utf8Value());\n", cppFieldName)
			case "bool":
				fmt.Fprintf(buf, "      msg.%s.push_back(arr.Get(i).As<Napi::Boolean>().Value());\n", cppFieldName)
			case "int32":
				fmt.Fprintf(buf, "      msg.%s.push_back(arr.Get(i).As<Napi::Number>().Int32Value());\n", cppFieldName)
			case "uint32":
				fmt.Fprintf(buf, "      msg.%s.push_back(arr.Get(i).As<Napi::Number>().Uint32Value());\n", cppFieldName)
			case "float32", "float64":
				fmt.Fprintf(buf, "      msg.%s.push_back(arr.Get(i).As<Napi::Number>().FloatValue());\n", cppFieldName)
			}
		}
		fmt.Fprintf(buf, "    }\n")
		fmt.Fprintf(buf, "  }\n")
	}

	return nil
}

// generateNAPIArrayOrPrimitiveFunctions handles non-struct root types
func generateNAPIArrayOrPrimitiveFunctions(buf *bytes.Buffer, msg *schema.MessageType) error {
	msgName := msg.Name + "Message"

	// For array types like IntList
	if arrayType, ok := msg.TargetType.(*schema.ArrayType); ok {
		// Get the root type name (element type name for arrays)
		rootTypeName := getRootTypeName(msg.TargetType)
		funcBaseName := strings.ToLower(rootTypeName)

		// Decode
		fmt.Fprintf(buf, "Napi::Value Decode%s(const Napi::CallbackInfo& info) {\n", msgName)
		buf.WriteString("  Napi::Env env = info.Env();\n")
		buf.WriteString("  Napi::Buffer<uint8_t> buffer = info[0].As<Napi::Buffer<uint8_t>>();\n\n")

		fmt.Fprintf(buf, "  std::vector<%s> vec = decode_%s_message(buffer.Data(), buffer.Length());\n",
			cppType(arrayType.ElementType), funcBaseName)

		buf.WriteString("  Napi::Array arr = Napi::Array::New(env, vec.size());\n")
		buf.WriteString("  for (size_t i = 0; i < vec.size(); i++) {\n")

		if primType, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			switch primType.Name {
			case "int32", "uint32", "float32", "float64":
				buf.WriteString("    arr[i] = Napi::Number::New(env, vec[i]);\n")
			case "string":
				buf.WriteString("    arr[i] = Napi::String::New(env, vec[i]);\n")
			}
		}

		buf.WriteString("  }\n")
		buf.WriteString("  return arr;\n")
		buf.WriteString("}\n\n")

		// Encode
		fmt.Fprintf(buf, "Napi::Value Encode%s(const Napi::CallbackInfo& info) {\n", msgName)
		buf.WriteString("  Napi::Env env = info.Env();\n")
		buf.WriteString("  Napi::Array arr = info[0].As<Napi::Array>();\n\n")

		fmt.Fprintf(buf, "  std::vector<%s> vec;\n", cppType(arrayType.ElementType))
		buf.WriteString("  vec.reserve(arr.Length());\n")
		buf.WriteString("  for (uint32_t i = 0; i < arr.Length(); i++) {\n")

		if primType, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			switch primType.Name {
			case "int32":
				buf.WriteString("    vec.push_back(arr.Get(i).As<Napi::Number>().Int32Value());\n")
			case "float32", "float64":
				buf.WriteString("    vec.push_back(arr.Get(i).As<Napi::Number>().FloatValue());\n")
			case "string":
				buf.WriteString("    vec.push_back(arr.Get(i).As<Napi::String>().Utf8Value());\n")
			}
		}

		buf.WriteString("  }\n\n")
		fmt.Fprintf(buf, "  std::vector<uint8_t> encoded = encode_%s_message(vec);\n", funcBaseName)
		buf.WriteString("  return Napi::Buffer<uint8_t>::Copy(env, encoded.data(), encoded.size());\n")
		buf.WriteString("}\n\n")
	}

	return nil
}

func cppType(t schema.Type) string {
	switch t := t.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "int32":
			return "int32_t"
		case "uint32":
			return "uint32_t"
		case "int64":
			return "int64_t"
		case "uint64":
			return "uint64_t"
		case "float32":
			return "float"
		case "float64":
			return "double"
		case "bool":
			return "bool"
		case "string":
			return "std::string"
		}
	case *schema.StructType:
		return t.Name
	case *schema.ArrayType:
		return "std::vector<" + cppType(t.ElementType) + ">"
	}
	return "unknown"
}

// getRootTypeName returns the root type name for generating C++ function names
// For arrays, it returns the element type name; for structs/primitives, the type itself
func getRootTypeName(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return strings.Title(typ.Name)
	case *schema.StructType:
		return typ.Name
	case *schema.ArrayType:
		return getRootTypeName(typ.ElementType)
	default:
		return "Unknown"
	}
}

// generateJavaScriptWrapper generates the JavaScript user-facing API
func generateJavaScriptWrapper(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "const addon = require('./build/Release/%s.node');\n\n", config.Schema.Package)

	// Generate class for each message type
	for _, msg := range config.Schema.Messages {
		msgName := msg.Name + "Message"

		// Check if this is an array or primitive type (not a struct)
		_, isStruct := msg.TargetType.(*schema.StructType)
		_, isArray := msg.TargetType.(*schema.ArrayType)

		fmt.Fprintf(buf, "class %s {\n", msgName)
		if isArray {
			// For array types, store the array as a property
			buf.WriteString("  constructor(data) {\n")
			buf.WriteString("    this.value = Array.isArray(data) ? data : data.value;\n")
			buf.WriteString("  }\n\n")

			fmt.Fprintf(buf, "  encode() {\n")
			fmt.Fprintf(buf, "    return addon.encode%s(this.value);\n", msgName)
			fmt.Fprintf(buf, "  }\n\n")

			fmt.Fprintf(buf, "  static decode(buffer) {\n")
			fmt.Fprintf(buf, "    const data = addon.decode%s(buffer);\n", msgName)
			fmt.Fprintf(buf, "    return new %s(data);\n", msgName)
			fmt.Fprintf(buf, "  }\n")
		} else if isStruct {
			// For struct types, use Object.assign
			buf.WriteString("  constructor(data) {\n")
			buf.WriteString("    Object.assign(this, data);\n")
			buf.WriteString("  }\n\n")

			fmt.Fprintf(buf, "  encode() {\n")
			fmt.Fprintf(buf, "    return addon.encode%s(this);\n", msgName)
			fmt.Fprintf(buf, "  }\n\n")

			fmt.Fprintf(buf, "  static decode(buffer) {\n")
			fmt.Fprintf(buf, "    const data = addon.decode%s(buffer);\n", msgName)
			fmt.Fprintf(buf, "    return new %s(data);\n", msgName)
			fmt.Fprintf(buf, "  }\n")
		} else {
			// For primitive types, store as value
			buf.WriteString("  constructor(data) {\n")
			buf.WriteString("    this.value = data;\n")
			buf.WriteString("  }\n\n")

			fmt.Fprintf(buf, "  encode() {\n")
			fmt.Fprintf(buf, "    return addon.encode%s(this.value);\n", msgName)
			fmt.Fprintf(buf, "  }\n\n")

			fmt.Fprintf(buf, "  static decode(buffer) {\n")
			fmt.Fprintf(buf, "    const data = addon.decode%s(buffer);\n", msgName)
			fmt.Fprintf(buf, "    return new %s(data);\n", msgName)
			fmt.Fprintf(buf, "  }\n")
		}
		fmt.Fprintf(buf, "}\n\n")
	}

	// Export all classes
	buf.WriteString("module.exports = {\n")
	for i, msg := range config.Schema.Messages {
		msgName := msg.Name + "Message"
		buf.WriteString("  " + msgName)
		if i < len(config.Schema.Messages)-1 {
			buf.WriteString(",\n")
		} else {
			buf.WriteString("\n")
		}
	}
	buf.WriteString("};\n")

	indexPath := filepath.Join(rootDir, "index.js")
	return os.WriteFile(indexPath, buf.Bytes(), 0644)
}

// generatePackageJSON generates package.json
func generatePackageJSON(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `{
  "name": "%s",
  "version": "1.0.0",
  "description": "ffire bindings for %s schema",
  "main": "index.js",
  "scripts": {
    "install": "node-gyp rebuild"
  },
  "dependencies": {
    "node-addon-api": "^7.0.0"
  },
  "devDependencies": {
    "node-gyp": "^10.0.0"
  },
  "gypfile": true
}
`, config.Namespace, config.Schema.Package)

	packagePath := filepath.Join(rootDir, "package.json")
	return os.WriteFile(packagePath, buf.Bytes(), 0644)
}

// generateBindingGyp generates binding.gyp for node-gyp
func generateBindingGyp(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `{
  "targets": [{
    "target_name": "%s",
    "sources": [
      "binding.cpp"
    ],
    "include_dirs": [
      "<!@(node -p \"require('node-addon-api').include\")",
      "."
    ],
    "dependencies": [
      "<!(node -p \"require('node-addon-api').gyp\")"
    ],
    "cflags!": [ "-fno-exceptions" ],
    "cflags_cc!": [ "-fno-exceptions" ],
    "cflags_cc": [ "-std=c++17", "-O3" ],
    "xcode_settings": {
      "GCC_ENABLE_CPP_EXCEPTIONS": "YES",
      "CLANG_CXX_LIBRARY": "libc++",
      "MACOSX_DEPLOYMENT_TARGET": "10.15",
      "OTHER_CFLAGS": [ "-std=c++17", "-O3" ]
    },
    "msvs_settings": {
      "VCCLCompilerTool": {
        "ExceptionHandling": 1
      }
    },
    "defines": [ "NAPI_DISABLE_CPP_EXCEPTIONS" ]
  }]
}
`, config.Schema.Package)

	bindingPath := filepath.Join(rootDir, "binding.gyp")
	return os.WriteFile(bindingPath, buf.Bytes(), 0644)
}

// generateTypeScriptDefinitions generates .d.ts file
func generateTypeScriptDefinitions(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")

	// Generate class definitions
	for _, msg := range config.Schema.Messages {
		msgName := msg.Name + "Message"

		fmt.Fprintf(buf, "export class %s {\n", msgName)
		buf.WriteString("  constructor(data: object);\n")
		buf.WriteString("  encode(): Buffer;\n")
		fmt.Fprintf(buf, "  static decode(buffer: Buffer): %s;\n", msgName)
		buf.WriteString("}\n\n")
	}

	defsPath := filepath.Join(rootDir, "index.d.ts")
	return os.WriteFile(defsPath, buf.Bytes(), 0644)
}

// generateJavaScriptReadme generates README.md
func generateJavaScriptReadme(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `# %s - ffire Node.js Bindings

Node.js bindings for the %s schema, generated by [ffire](https://github.com/shaban/ffire).

## Installation

`+"```bash"+`
npm install
`+"```"+`

This will automatically build the native addon using node-gyp.

## Usage

`+"```javascript"+`
const { ConfigMessage } = require('./');
const fs = require('fs');

// Encode
const config = new ConfigMessage({
  host: "localhost",
  port: 8080,
  enableSSL: true
});

const buffer = config.encode();
fs.writeFileSync('config.bin', buffer);

// Decode
const data = fs.readFileSync('config.bin');
const decoded = ConfigMessage.decode(data);

console.log(decoded.host);  // "localhost"
console.log(decoded.port);  // 8080
`+"```"+`

## API

`, config.Namespace, config.Schema.Package)

	for _, msg := range config.Schema.Messages {
		msgName := msg.Name + "Message"
		fmt.Fprintf(buf, "### `%s`\n\n", msgName)
		fmt.Fprintf(buf, "**Constructor:** `new %s(data)`\n\n", msgName)
		fmt.Fprintf(buf, "**Methods:**\n")
		fmt.Fprintf(buf, "- `encode()` - Returns Buffer\n")
		fmt.Fprintf(buf, "- `static decode(buffer)` - Returns %s instance\n\n", msgName)
	}

	buf.WriteString("## Performance\n\n")
	buf.WriteString("Native N-API bindings provide near-C++ performance with zero-copy buffer handling.\n")

	readmePath := filepath.Join(rootDir, "README.md")
	return os.WriteFile(readmePath, buf.Bytes(), 0644)
}
