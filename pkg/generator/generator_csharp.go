package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateCSharp generates native C# code with Span<byte> encoding/decoding
// Uses modern .NET patterns: Span<byte>, BinaryPrimitives, MemoryMarshal
func GenerateCSharp(s *schema.Schema) ([]byte, error) {
	gen := &csharpGenerator{
		schema:     s,
		buf:        &bytes.Buffer{},
		seenTypes:  make(map[string]bool),
		needsTypes: make(map[string]bool),
	}
	return gen.generate()
}

type csharpGenerator struct {
	schema     *schema.Schema
	buf        *bytes.Buffer
	seenTypes  map[string]bool
	needsTypes map[string]bool
}

func (g *csharpGenerator) generate() ([]byte, error) {
	fmt.Fprintf(g.buf, "// Code generated by ffire. DO NOT EDIT.\n\n")
	fmt.Fprintf(g.buf, "using System;\n")
	fmt.Fprintf(g.buf, "using System.Buffers.Binary;\n")
	fmt.Fprintf(g.buf, "using System.Runtime.CompilerServices;\n")
	fmt.Fprintf(g.buf, "using System.Runtime.InteropServices;\n")
	fmt.Fprintf(g.buf, "using System.Text;\n\n")
	fmt.Fprintf(g.buf, "namespace %s\n{\n", g.toPascalCase(g.schema.Package))

	for _, msg := range g.schema.Messages {
		g.collectNeededTypes(msg.TargetType)
	}

	// Build set of root message type names
	messageTypes := make(map[string]bool)
	for _, msg := range g.schema.Messages {
		if st, ok := msg.TargetType.(*schema.StructType); ok {
			messageTypes[st.Name] = true
		}
	}

	sorted, err := g.topologicalSort()
	if err != nil {
		return nil, err
	}

	// Generate helper classes first (public visibility - needed for array element types)
	for _, name := range sorted {
		if !messageTypes[name] {
			if err := g.generateStructClass(name, false); err != nil {
				return nil, err
			}
		}
	}

	// Generate message classes (public visibility)
	for _, msg := range g.schema.Messages {
		if err := g.generateMessageClass(&msg); err != nil {
			return nil, err
		}
	}

	// Generate string decoder helper if needed
	if g.needsStringDecoder() {
		g.buf.WriteString("    internal static class FFireHelpers\n")
		g.buf.WriteString("    {\n")
		g.buf.WriteString("        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n")
		g.buf.WriteString("        internal static unsafe string DecodeString(ReadOnlySpan<byte> buffer, ref int offset)\n")
		g.buf.WriteString("        {\n")
		g.buf.WriteString("            fixed (byte* ptr = buffer)\n")
		g.buf.WriteString("            {\n")
		g.buf.WriteString("                ushort length = *(ushort*)(ptr + offset);\n")
		g.buf.WriteString("                offset += 2;\n")
		g.buf.WriteString("                string result = Encoding.UTF8.GetString(ptr + offset, length);\n")
		g.buf.WriteString("                offset += length;\n")
		g.buf.WriteString("                return result;\n")
		g.buf.WriteString("            }\n")
		g.buf.WriteString("        }\n")
		g.buf.WriteString("    }\n\n")
	}

	g.buf.WriteString("}\n") // Close namespace
	return g.buf.Bytes(), nil
}

func (g *csharpGenerator) collectNeededTypes(t schema.Type) {
	switch typ := t.(type) {
	case *schema.StructType:
		if !g.seenTypes[typ.Name] {
			g.seenTypes[typ.Name] = true
			g.needsTypes[typ.Name] = true
			for _, field := range typ.Fields {
				g.collectNeededTypes(field.Type)
			}
		}
	case *schema.ArrayType:
		g.collectNeededTypes(typ.ElementType)
	}
}

func (g *csharpGenerator) topologicalSort() ([]string, error) {
	deps := make(map[string][]string)
	for name := range g.needsTypes {
		structType := g.findStructType(name)
		if structType != nil {
			for _, field := range structType.Fields {
				if st, ok := field.Type.(*schema.StructType); ok {
					if g.needsTypes[st.Name] {
						deps[name] = append(deps[name], st.Name)
					}
				}
				if arr, ok := field.Type.(*schema.ArrayType); ok {
					if st, ok := arr.ElementType.(*schema.StructType); ok {
						if g.needsTypes[st.Name] {
							deps[name] = append(deps[name], st.Name)
						}
					}
				}
			}
		}
	}

	inDegree := make(map[string]int)
	for name := range g.needsTypes {
		if _, exists := deps[name]; !exists {
			inDegree[name] = 0
		} else {
			inDegree[name] = len(deps[name])
		}
	}

	var queue []string
	for name, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, name)
		}
	}

	var sorted []string
	for len(queue) > 0 {
		sort.Strings(queue)
		name := queue[0]
		queue = queue[1:]
		sorted = append(sorted, name)

		for dependent, depList := range deps {
			for _, dep := range depList {
				if dep == name {
					inDegree[dependent]--
					if inDegree[dependent] == 0 {
						queue = append(queue, dependent)
					}
					break
				}
			}
		}
	}

	if len(sorted) != len(g.needsTypes) {
		return nil, fmt.Errorf("circular dependency detected in struct types")
	}

	return sorted, nil
}

func (g *csharpGenerator) findStructType(name string) *schema.StructType {
	for _, msg := range g.schema.Messages {
		if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == name {
			return st
		}
	}
	for _, t := range g.schema.Types {
		if st, ok := t.(*schema.StructType); ok && st.Name == name {
			return st
		}
	}
	return nil
}

// isPrimitiveOnlyStruct checks if a struct contains only non-optional primitive fields (no strings, arrays, or nested structs)
// These can be encoded/decoded using fast bulk memory operations
func (g *csharpGenerator) isPrimitiveOnlyStruct(structType *schema.StructType) bool {
	if len(structType.Fields) == 0 {
		return false
	}
	for _, field := range structType.Fields {
		switch t := field.Type.(type) {
		case *schema.PrimitiveType:
			// String requires UTF8 encoding, optional requires null handling
			if t.Name == "string" || t.Optional {
				return false
			}
			// Only bool, int8/16/32/64, float32/64 are allowed
		case *schema.StructType, *schema.ArrayType:
			return false
		default:
			return false
		}
	}
	return true
}

func (g *csharpGenerator) isStringField(t schema.Type) bool {
	if prim, ok := t.(*schema.PrimitiveType); ok {
		return prim.Name == "string"
	}
	return false
}

// reorderFieldsForEncoding reorders struct fields to group primitives first for optimal encoding:
// 1. Non-optional primitive fields (except string): bool, int8-64, float32-64
// 2. Strings, arrays, optional fields, nested structs
// This allows bulk memory operations on the primitive block
func (g *csharpGenerator) reorderFieldsForEncoding(fields []schema.Field) []schema.Field {
	var primitives []schema.Field
	var others []schema.Field

	for _, field := range fields {
		isPrimitive := false
		if prim, ok := field.Type.(*schema.PrimitiveType); ok {
			// Non-optional primitives except string go first
			if !prim.Optional && prim.Name != "string" {
				isPrimitive = true
			}
		}

		if isPrimitive {
			primitives = append(primitives, field)
		} else {
			others = append(others, field)
		}
	}

	// Return primitives first, then everything else
	return append(primitives, others...)
}

func (g *csharpGenerator) generateMessageClass(msg *schema.MessageType) error {
	switch targetType := msg.TargetType.(type) {
	case *schema.StructType:
		return g.generateStructClassWithName(targetType, msg.Name+"Message", true)
	case *schema.ArrayType:
		return g.generateArrayMessageClass(msg.Name, targetType, true)
	default:
		return fmt.Errorf("message %s has unsupported type %T", msg.Name, msg.TargetType)
	}
}

func (g *csharpGenerator) generateStructClass(typeName string, isMessage bool) error {
	structType := g.findStructType(typeName)
	if structType == nil {
		return fmt.Errorf("struct type %s not found", typeName)
	}
	className := typeName
	if isMessage {
		className = typeName + "Message"
	}
	// Helper structs need to be public (for array element types), messages are always public
	return g.generateStructClassWithName(structType, className, true)
}

func (g *csharpGenerator) generateStructClassWithName(structType *schema.StructType, className string, isPublic bool) error {
	visibility := "internal"
	if isPublic {
		visibility = "public"
	}

	// Add StructLayout attribute for primitive-only structs to enable fast bulk operations
	if g.isPrimitiveOnlyStruct(structType) {
		g.buf.WriteString("    [StructLayout(LayoutKind.Sequential)]\n")
	}

	// Use readonly struct for better performance (passed by value, no heap allocation)
	fmt.Fprintf(g.buf, "    %s struct %s\n", visibility, className)
	g.buf.WriteString("    {\n")

	// Fields - all are normal properties (no UTF-8 caching for strings)
	for _, field := range structType.Fields {
		fieldName := g.toPascalCase(field.Name)
		csType := g.csharpType(field.Type)
		fmt.Fprintf(g.buf, "        public %s %s { get; set; }\n", csType, fieldName)
	}
	g.buf.WriteString("\n")

	// Encode method - allocate max size, encode, trim if needed
	g.buf.WriteString("        public byte[] Encode()\n")
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            int maxSize = ComputeMaxSize();\n")
	g.buf.WriteString("            byte[] buffer = new byte[maxSize];\n")
	g.buf.WriteString("            int offset = 0;\n")
	g.buf.WriteString("            EncodeTo(buffer, ref offset);\n")
	g.buf.WriteString("            if (offset < maxSize)\n")
	g.buf.WriteString("            {\n")
	g.buf.WriteString("                Array.Resize(ref buffer, offset);\n")
	g.buf.WriteString("            }\n")
	g.buf.WriteString("            return buffer;\n")
	g.buf.WriteString("        }\n\n")

	// Decode method
	fmt.Fprintf(g.buf, "        public static %s Decode(byte[] data)\n", className)
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            ReadOnlySpan<byte> span = data;\n")
	g.buf.WriteString("            int offset = 0;\n")
	fmt.Fprintf(g.buf, "            return DecodeFrom(span, ref offset);\n")
	g.buf.WriteString("        }\n\n")

	// ComputeMaxSize method - fast upper bound using UTF-8 byte array lengths
	g.buf.WriteString("        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n")
	g.buf.WriteString("        internal int ComputeMaxSize()\n")
	g.buf.WriteString("        {\n")

	// Use sizeof for primitive-only structs
	if g.isPrimitiveOnlyStruct(structType) {
		fmt.Fprintf(g.buf, "            return sizeof(%s);\n", className)
	} else {
		g.buf.WriteString("            int size = 0;\n")
		for _, field := range structType.Fields {
			g.generateMaxSizeComputation(&field)
		}
		g.buf.WriteString("            return size;\n")
	}
	g.buf.WriteString("        }\n\n")

	// EncodeTo method - uses byte[] like blueprint for better performance
	g.buf.WriteString("        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n")
	g.buf.WriteString("        internal unsafe void EncodeTo(byte[] buffer, ref int offset)\n")
	g.buf.WriteString("        {\n")

	// Use fast bulk copy for primitive-only structs
	if g.isPrimitiveOnlyStruct(structType) {
		g.buf.WriteString("            // Fast path: bulk copy for primitive-only struct\n")
		fmt.Fprintf(g.buf, "            Span<%s> structSpan = MemoryMarshal.Cast<byte, %s>(buffer.AsSpan(offset));\n", className, className)
		g.buf.WriteString("            structSpan[0] = this;\n")
		fmt.Fprintf(g.buf, "            offset += sizeof(%s);\n", className)
	} else {
		for _, field := range structType.Fields {
			g.generateEncodeField(&field)
		}
	}
	g.buf.WriteString("        }\n\n") // DecodeFrom method - use reordered fields
	fmt.Fprintf(g.buf, "        internal static %s DecodeFrom(ReadOnlySpan<byte> buffer, ref int offset)\n", className)
	g.buf.WriteString("        {\n")

	// Use unsafe pointer read for primitive-only structs (1.19x faster than field-by-field)
	if g.isPrimitiveOnlyStruct(structType) {
		g.buf.WriteString("            // Fast path: unsafe pointer read for primitive-only struct\n")
		fmt.Fprintf(g.buf, "            %s result;\n", className)
		g.buf.WriteString("            unsafe\n")
		g.buf.WriteString("            {\n")
		g.buf.WriteString("                fixed (byte* ptr = buffer)\n")
		g.buf.WriteString("                {\n")
		fmt.Fprintf(g.buf, "                    result = *(%s*)(ptr + offset);\n", className)
		g.buf.WriteString("                }\n")
		g.buf.WriteString("            }\n")
		fmt.Fprintf(g.buf, "            offset += sizeof(%s);\n", className)
		g.buf.WriteString("            return result;\n")
	} else {
		fmt.Fprintf(g.buf, "            var obj = new %s();\n", className)
		for _, field := range structType.Fields {
			g.generateDecodeField(&field)
		}
		g.buf.WriteString("            return obj;\n")
	}
	g.buf.WriteString("        }\n")

	g.buf.WriteString("    }\n\n")
	return nil
}

func (g *csharpGenerator) generateArrayMessageClass(msgName string, arrayType *schema.ArrayType, isPublic bool) error {
	className := msgName + "Message"
	visibility := "internal"
	if isPublic {
		visibility = "public"
	}

	elemType := g.csharpType(arrayType.ElementType)

	fmt.Fprintf(g.buf, "    %s struct %s\n", visibility, className)
	g.buf.WriteString("    {\n")
	fmt.Fprintf(g.buf, "        public %s[]? Items { get; set; }\n\n", elemType)

	// Encode - compute exact size
	g.buf.WriteString("        public byte[] Encode()\n")
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            int maxSize = ComputeMaxSize();\n")
	g.buf.WriteString("            byte[] buffer = new byte[maxSize];\n")
	g.buf.WriteString("            int offset = 0;\n")
	g.buf.WriteString("            EncodeTo(buffer, ref offset);\n")
	g.buf.WriteString("            if (offset < maxSize)\n")
	g.buf.WriteString("            {\n")
	g.buf.WriteString("                Array.Resize(ref buffer, offset);\n")
	g.buf.WriteString("            }\n")
	g.buf.WriteString("            return buffer;\n")
	g.buf.WriteString("        }\n\n")

	// Decode
	fmt.Fprintf(g.buf, "        public static %s Decode(byte[] data)\n", className)
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            ReadOnlySpan<byte> span = data;\n")
	g.buf.WriteString("            int offset = 0;\n")
	g.buf.WriteString("            return DecodeFrom(span, ref offset);\n")
	g.buf.WriteString("        }\n\n")

	// ComputeSize - compute exact size
	g.buf.WriteString("        internal int ComputeMaxSize()\n")
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            int size = 2; // array length\n")
	g.buf.WriteString("            if (Items != null)\n")
	g.buf.WriteString("            {\n")

	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && prim.Name != "string" {
		fmt.Fprintf(g.buf, "                size += Items.Length * %d;\n", g.sizeOfPrimitive(prim.Name))
	} else {
		g.buf.WriteString("                foreach (var item in Items)\n")
		g.buf.WriteString("                {\n")
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && prim.Name == "string" {
			g.buf.WriteString("                    size += 2 + Encoding.UTF8.GetByteCount(item ?? \"\");\n")
		} else if _, ok := arrayType.ElementType.(*schema.StructType); ok {
			g.buf.WriteString("                    size += item.ComputeMaxSize();\n")
		}
		g.buf.WriteString("                }\n")
	}

	g.buf.WriteString("            }\n")
	g.buf.WriteString("            return size;\n")
	g.buf.WriteString("        }\n\n")

	// EncodeTo
	g.buf.WriteString("        internal unsafe void EncodeTo(byte[] buffer, ref int offset)\n")
	g.buf.WriteString("        {\n")
	g.buf.WriteString("            { ushort len = (ushort)(Items?.Length ?? 0); buffer[offset++] = (byte)len; buffer[offset++] = (byte)(len >> 8); }\n")
	g.buf.WriteString("            if (Items != null)\n")
	g.buf.WriteString("            {\n")

	// Use bulk operations for primitive arrays
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		g.generateBulkArrayEncode("Items", prim.Name)
	} else {
		g.buf.WriteString("                foreach (var item in Items)\n")
		g.buf.WriteString("                {\n")
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			// Array elements use single-pass encoding (no cached values)
			g.generatePrimitiveEncodeNoCache("item", prim.Name, "                    ")
		} else if _, ok := arrayType.ElementType.(*schema.StructType); ok {
			g.buf.WriteString("                    item.EncodeTo(buffer, ref offset);\n")
		}
		g.buf.WriteString("                }\n")
	}

	g.buf.WriteString("            }\n")
	g.buf.WriteString("        }\n\n")

	// DecodeFrom
	fmt.Fprintf(g.buf, "        internal static %s DecodeFrom(ReadOnlySpan<byte> buffer, ref int offset)\n", className)
	g.buf.WriteString("        {\n")
	fmt.Fprintf(g.buf, "            var obj = new %s();\n", className)
	g.buf.WriteString("            int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n")
	g.buf.WriteString("            offset += 2;\n")
	fmt.Fprintf(g.buf, "            obj.Items = new %s[length];\n", elemType)

	// Use bulk operations for primitive arrays
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		g.generateBulkArrayDecode("obj.Items", prim.Name)
	} else {
		g.buf.WriteString("            for (int i = 0; i < length; i++)\n")
		g.buf.WriteString("            {\n")
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			g.buf.WriteString("                obj.Items[i] = ")
			g.generatePrimitiveDecode(prim.Name)
			g.buf.WriteString(";\n")
		} else if st, ok := arrayType.ElementType.(*schema.StructType); ok {
			fmt.Fprintf(g.buf, "                obj.Items[i] = %s.DecodeFrom(buffer, ref offset);\n", st.Name)
		}
		g.buf.WriteString("            }\n")
	}

	g.buf.WriteString("            return obj;\n")
	g.buf.WriteString("        }\n")
	g.buf.WriteString("    }\n\n")

	return nil
}

func (g *csharpGenerator) csharpType(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		baseType := g.csharpBaseType(typ.Name)
		if typ.Optional {
			return baseType + "?"
		}
		return baseType
	case *schema.ArrayType:
		elemType := g.csharpType(typ.ElementType)
		return elemType + "[]"
	case *schema.StructType:
		return typ.Name
	}
	return "object"
}

func (g *csharpGenerator) csharpBaseType(kind string) string {
	switch kind {
	case "bool":
		return "bool"
	case "i8", "int8":
		return "sbyte"
	case "u8", "uint8":
		return "byte"
	case "i16", "int16":
		return "short"
	case "u16", "uint16":
		return "ushort"
	case "i32", "int32":
		return "int"
	case "u32", "uint32":
		return "uint"
	case "i64", "int64":
		return "long"
	case "u64", "uint64":
		return "ulong"
	case "f32", "float32":
		return "float"
	case "f64", "float64":
		return "double"
	case "string":
		return "string"
	default:
		return "object"
	}
}

func (g *csharpGenerator) sizeOfPrimitive(kind string) int {
	switch kind {
	case "bool", "i8", "u8", "int8", "uint8":
		return 1
	case "i16", "u16", "int16", "uint16":
		return 2
	case "i32", "u32", "int32", "uint32", "f32", "float32":
		return 4
	case "i64", "u64", "int64", "uint64", "f64", "float64":
		return 8
	}
	return 0
}

func (g *csharpGenerator) generateSizeComputationWithCache(field *schema.Field) {
	fieldName := g.toPascalCase(field.Name)

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			if typ.Name == "string" {
				// Encode to UTF-8 once and cache the bytes
				cacheFieldName := fmt.Sprintf("_cached%sUtf8", fieldName)
				fmt.Fprintf(g.buf, "                %s = Encoding.UTF8.GetBytes(%s);\n", cacheFieldName, fieldName)
				fmt.Fprintf(g.buf, "                size += 2 + %s.Length;\n", cacheFieldName)
			} else {
				fmt.Fprintf(g.buf, "                size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
			g.buf.WriteString("            }\n")
		} else {
			if typ.Name == "string" {
				// Encode to UTF-8 once and cache the bytes
				cacheFieldName := fmt.Sprintf("_cached%sUtf8", fieldName)
				fmt.Fprintf(g.buf, "            %s = Encoding.UTF8.GetBytes(%s ?? \"\");\n", cacheFieldName, fieldName)
				fmt.Fprintf(g.buf, "            size += 2 + %s.Length;\n", cacheFieldName)
			} else {
				fmt.Fprintf(g.buf, "            size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
		}
	case *schema.ArrayType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                size += 2;\n")
			g.generateArraySizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		} else {
			g.buf.WriteString("            size += 2;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.generateArraySizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "            size += %s.ComputeMaxSize();\n", fieldName)
	}
}

func (g *csharpGenerator) generateMaxSizeComputation(field *schema.Field) {
	fieldName := g.toPascalCase(field.Name)

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			if typ.Name == "string" {
				// Use * 3 multiplier for max UTF-8 expansion (like Approach 3)
				fmt.Fprintf(g.buf, "                size += 2 + (%s?.Length ?? 0) * 3;\n", fieldName)
			} else {
				fmt.Fprintf(g.buf, "                size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
			g.buf.WriteString("            }\n")
		} else {
			if typ.Name == "string" {
				// Use * 3 multiplier for max UTF-8 expansion (like Approach 3)
				fmt.Fprintf(g.buf, "            size += 2 + (%s?.Length ?? 0) * 3;\n", fieldName)
			} else {
				fmt.Fprintf(g.buf, "            size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
		}
	case *schema.ArrayType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                size += 2;\n")
			g.generateArrayMaxSizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		} else {
			g.buf.WriteString("            size += 2;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.generateArrayMaxSizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "            size += %s.ComputeMaxSize();\n", fieldName)
	}
}

func (g *csharpGenerator) generateSizeComputation(field *schema.Field) {
	fieldName := g.toPascalCase(field.Name)

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			if typ.Name == "string" {
				// Use * 3 multiplier for max UTF-8 expansion (like Approach 3)
				fmt.Fprintf(g.buf, "                size += 2 + (%s?.Length ?? 0) * 3;\n", fieldName)
			} else {
				fmt.Fprintf(g.buf, "                size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
			g.buf.WriteString("            }\n")
		} else {
			if typ.Name == "string" {
				// Use * 3 multiplier for max UTF-8 expansion (like Approach 3)
				fmt.Fprintf(g.buf, "            size += 2 + (%s?.Length ?? 0) * 3;\n", fieldName)
			} else {
				fmt.Fprintf(g.buf, "            size += %d;\n", g.sizeOfPrimitive(typ.Name))
			}
		}
	case *schema.ArrayType:
		if typ.Optional {
			g.buf.WriteString("            size += 1;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                size += 2;\n")
			g.generateArraySizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		} else {
			g.buf.WriteString("            size += 2;\n")
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.generateArraySizeLogic(fieldName, typ)
			g.buf.WriteString("            }\n")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "            size += %s.ComputeMaxSize();\n", fieldName)
	}
}

func (g *csharpGenerator) generateArrayMaxSizeLogic(fieldName string, arrayType *schema.ArrayType) {
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		fmt.Fprintf(g.buf, "                size += %s.Length * %d;\n", fieldName, g.sizeOfPrimitive(prim.Name))
	} else {
		fmt.Fprintf(g.buf, "                foreach (var item in %s)\n", fieldName)
		g.buf.WriteString("                {\n")
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			if prim.Name == "string" {
				// UTF-8 max: 3 bytes per char
				g.buf.WriteString("                    size += 2 + (item?.Length ?? 0) * 3;\n")
			} else if prim.Optional {
				g.buf.WriteString("                    size += 1;\n")
				g.buf.WriteString("                    if (item != null)\n")
				g.buf.WriteString("                    {\n")
				fmt.Fprintf(g.buf, "                        size += %d;\n", g.sizeOfPrimitive(prim.Name))
				g.buf.WriteString("                    }\n")
			} else {
				fmt.Fprintf(g.buf, "                    size += %d;\n", g.sizeOfPrimitive(prim.Name))
			}
		} else if _, ok := arrayType.ElementType.(*schema.StructType); ok {
			g.buf.WriteString("                    size += item.ComputeMaxSize();\n")
		}
		g.buf.WriteString("                }\n")
	}
}

func (g *csharpGenerator) generateArraySizeLogic(fieldName string, arrayType *schema.ArrayType) {
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		fmt.Fprintf(g.buf, "                size += %s.Length * %d;\n", fieldName, g.sizeOfPrimitive(prim.Name))
	} else {
		fmt.Fprintf(g.buf, "                foreach (var item in %s)\n", fieldName)
		g.buf.WriteString("                {\n")
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			if prim.Name == "string" {
				// Use * 3 multiplier for max UTF-8 expansion (like Approach 3)
				g.buf.WriteString("                    size += 2 + (item?.Length ?? 0) * 3;\n")
			} else if prim.Optional {
				g.buf.WriteString("                    size += 1;\n")
				g.buf.WriteString("                    if (item != null)\n")
				g.buf.WriteString("                    {\n")
				fmt.Fprintf(g.buf, "                        size += %d;\n", g.sizeOfPrimitive(prim.Name))
				g.buf.WriteString("                    }\n")
			} else {
				fmt.Fprintf(g.buf, "                    size += %d;\n", g.sizeOfPrimitive(prim.Name))
			}
		} else if _, ok := arrayType.ElementType.(*schema.StructType); ok {
			g.buf.WriteString("                    size += item.ComputeMaxSize();\n")
		}
		g.buf.WriteString("                }\n")
	}
}

func (g *csharpGenerator) generateEncodeField(field *schema.Field) {
	fieldName := g.toPascalCase(field.Name)

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                buffer[offset++] = 1;\n")
			// Unwrap nullable value types (not reference types like string)
			encodeFieldName := fieldName
			if typ.Name != "string" {
				encodeFieldName = fieldName + ".Value"
			}
			g.generatePrimitiveEncode(encodeFieldName, typ.Name, "                ")
			g.buf.WriteString("            }\n")
			g.buf.WriteString("            else\n")
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                buffer[offset++] = 0;\n")
			g.buf.WriteString("            }\n")
		} else {
			g.generatePrimitiveEncode(fieldName, typ.Name, "            ")
		}
	case *schema.ArrayType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                buffer[offset++] = 1;\n")
			fmt.Fprintf(g.buf, "                { ushort len = (ushort)%s.Length; buffer[offset++] = (byte)len; buffer[offset++] = (byte)(len >> 8); }\n", fieldName)
			g.generateArrayEncodeLogic(fieldName, typ, "                ")
			g.buf.WriteString("            }\n")
			g.buf.WriteString("            else\n")
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                buffer[offset++] = 0;\n")
			g.buf.WriteString("            }\n")
		} else {
			fmt.Fprintf(g.buf, "            { ushort len = (ushort)(%s?.Length ?? 0); buffer[offset++] = (byte)len; buffer[offset++] = (byte)(len >> 8); }\n", fieldName)
			fmt.Fprintf(g.buf, "            if (%s != null)\n", fieldName)
			g.buf.WriteString("            {\n")
			g.generateArrayEncodeLogic(fieldName, typ, "                ")
			g.buf.WriteString("            }\n")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "            %s.EncodeTo(buffer, ref offset);\n", fieldName)
	}
}

func (g *csharpGenerator) generateArrayEncodeLogic(fieldName string, arrayType *schema.ArrayType, indent string) {
	// Use MemoryMarshal for bulk primitive array encoding
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		g.generateBulkArrayEncode(fieldName, prim.Name)
	} else {
		fmt.Fprintf(g.buf, "%sforeach (var item in %s)\n", indent, fieldName)
		fmt.Fprintf(g.buf, "%s{\n", indent)
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			// Array elements use single-pass encoding (no cached values available)
			g.generatePrimitiveEncodeNoCache("item", prim.Name, indent+"    ")
		} else if _, ok := arrayType.ElementType.(*schema.StructType); ok {
			fmt.Fprintf(g.buf, "%s    item.EncodeTo(buffer, ref offset);\n", indent)
		}
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *csharpGenerator) generateBulkArrayEncode(fieldName, kind string) {
	// Use MemoryMarshal.AsBytes for zero-copy bulk encoding
	g.buf.WriteString("                // Bulk copy using MemoryMarshal for zero-copy performance\n")
	fmt.Fprintf(g.buf, "                Span<%s> span = %s;\n", g.csharpBaseType(kind), fieldName)
	g.buf.WriteString("                ReadOnlySpan<byte> bytes = MemoryMarshal.AsBytes(span);\n")
	g.buf.WriteString("                bytes.CopyTo(buffer.AsSpan(offset));\n")
	g.buf.WriteString("                offset += bytes.Length;\n")
}

func (g *csharpGenerator) generateBulkArrayDecode(fieldName, kind string) {
	// Use MemoryMarshal.Cast for zero-copy bulk decoding
	g.buf.WriteString("            // Bulk copy using MemoryMarshal for zero-copy performance\n")
	fmt.Fprintf(g.buf, "            int byteCount = length * %d;\n", g.sizeOfPrimitive(kind))
	fmt.Fprintf(g.buf, "            ReadOnlySpan<%s> span = MemoryMarshal.Cast<byte, %s>(buffer.Slice(offset, byteCount));\n",
		g.csharpBaseType(kind), g.csharpBaseType(kind))
	fmt.Fprintf(g.buf, "            span.CopyTo(%s);\n", fieldName)
	g.buf.WriteString("            offset += byteCount;\n")
}

func (g *csharpGenerator) generatePrimitiveEncode(fieldName, kind, indent string) {
	switch kind {
	case "bool":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)(%s ? 1 : 0);\n", indent, fieldName)
	case "i8", "int8":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)%s;\n", indent, fieldName)
	case "u8", "uint8":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = %s;\n", indent, fieldName)
	case "i16", "int16":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt16LittleEndian(buffer.AsSpan(offset), %s); offset += 2;\n", indent, fieldName)
	case "u16", "uint16":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt16LittleEndian(buffer.AsSpan(offset), %s); offset += 2;\n", indent, fieldName)
	case "i32", "int32":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt32LittleEndian(buffer.AsSpan(offset), %s); offset += 4;\n", indent, fieldName)
	case "u32", "uint32":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt32LittleEndian(buffer.AsSpan(offset), %s); offset += 4;\n", indent, fieldName)
	case "i64", "int64":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt64LittleEndian(buffer.AsSpan(offset), %s); offset += 8;\n", indent, fieldName)
	case "u64", "uint64":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt64LittleEndian(buffer.AsSpan(offset), %s); offset += 8;\n", indent, fieldName)
	case "f32", "float32":
		fmt.Fprintf(g.buf, "%s{ float f = %s; uint v = *(uint*)&f; buffer[offset++] = (byte)v; buffer[offset++] = (byte)(v >> 8); buffer[offset++] = (byte)(v >> 16); buffer[offset++] = (byte)(v >> 24); }\n", indent, fieldName)
	case "f64", "float64":
		fmt.Fprintf(g.buf, "%s{ double d = %s; ulong v = *(ulong*)&d; buffer[offset++] = (byte)v; buffer[offset++] = (byte)(v >> 8); buffer[offset++] = (byte)(v >> 16); buffer[offset++] = (byte)(v >> 24); buffer[offset++] = (byte)(v >> 32); buffer[offset++] = (byte)(v >> 40); buffer[offset++] = (byte)(v >> 48); buffer[offset++] = (byte)(v >> 56); }\n", indent, fieldName)
	case "string":
		// Single-pass encoding: GetBytes writes directly to buffer and returns byte count (matches blueprint exactly)
		cleanFieldName := strings.TrimSuffix(fieldName, ".Value")
		fmt.Fprintf(g.buf, "%sint byteCount_%s = Encoding.UTF8.GetBytes(%s ?? \"\", buffer.AsSpan(offset + 2));\n", indent, cleanFieldName, fieldName)
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)byteCount_%s;\n", indent, cleanFieldName)
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)(byteCount_%s >> 8);\n", indent, cleanFieldName)
		fmt.Fprintf(g.buf, "%soffset += byteCount_%s;\n", indent, cleanFieldName)
	}
}

func (g *csharpGenerator) generatePrimitiveEncodeNoCache(fieldName, kind, indent string) {
	switch kind {
	case "bool":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)(%s ? 1 : 0);\n", indent, fieldName)
	case "i8", "int8":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)%s;\n", indent, fieldName)
	case "u8", "uint8":
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = %s;\n", indent, fieldName)
	case "i16", "int16":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt16LittleEndian(buffer.AsSpan(offset), %s); offset += 2;\n", indent, fieldName)
	case "u16", "uint16":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt16LittleEndian(buffer.AsSpan(offset), %s); offset += 2;\n", indent, fieldName)
	case "i32", "int32":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt32LittleEndian(buffer.AsSpan(offset), %s); offset += 4;\n", indent, fieldName)
	case "u32", "uint32":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt32LittleEndian(buffer.AsSpan(offset), %s); offset += 4;\n", indent, fieldName)
	case "i64", "int64":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteInt64LittleEndian(buffer.AsSpan(offset), %s); offset += 8;\n", indent, fieldName)
	case "u64", "uint64":
		fmt.Fprintf(g.buf, "%sBinaryPrimitives.WriteUInt64LittleEndian(buffer.AsSpan(offset), %s); offset += 8;\n", indent, fieldName)
	case "f32", "float32":
		fmt.Fprintf(g.buf, "%s{ float f = %s; uint v = *(uint*)&f; buffer[offset++] = (byte)v; buffer[offset++] = (byte)(v >> 8); buffer[offset++] = (byte)(v >> 16); buffer[offset++] = (byte)(v >> 24); }\n", indent, fieldName)
	case "f64", "float64":
		fmt.Fprintf(g.buf, "%s{ double d = %s; ulong v = *(ulong*)&d; buffer[offset++] = (byte)v; buffer[offset++] = (byte)(v >> 8); buffer[offset++] = (byte)(v >> 16); buffer[offset++] = (byte)(v >> 24); buffer[offset++] = (byte)(v >> 32); buffer[offset++] = (byte)(v >> 40); buffer[offset++] = (byte)(v >> 48); buffer[offset++] = (byte)(v >> 56); }\n", indent, fieldName)
	case "string":
		// Single-pass encoding: GetBytes writes directly to buffer and returns byte count (matches blueprint exactly)
		cleanFieldName := strings.TrimSuffix(fieldName, ".Value")
		varName := fmt.Sprintf("byteCount_%s", strings.ToLower(cleanFieldName))
		fmt.Fprintf(g.buf, "%sint %s = Encoding.UTF8.GetBytes(%s ?? \"\", buffer.AsSpan(offset + 2));\n", indent, varName, fieldName)
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)%s;\n", indent, varName)
		fmt.Fprintf(g.buf, "%sbuffer[offset++] = (byte)(%s >> 8);\n", indent, varName)
		fmt.Fprintf(g.buf, "%soffset += %s;\n", indent, varName)
	}
}

func (g *csharpGenerator) generateDecodeField(field *schema.Field) {
	fieldName := g.toPascalCase(field.Name)

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("            if (buffer[offset++] == 1)\n")
			g.buf.WriteString("            {\n")
			if typ.Name == "string" {
				// Inline string decoding (like blueprint) for better performance
				lenVar := fmt.Sprintf("_len_%s", strings.ToLower(fieldName))
				fmt.Fprintf(g.buf, "                int %s = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n", lenVar)
				g.buf.WriteString("                offset += 2;\n")
				fmt.Fprintf(g.buf, "                obj.%s = %s > 0 ? Encoding.UTF8.GetString(buffer.Slice(offset, %s)) : \"\";\n", fieldName, lenVar, lenVar)
				fmt.Fprintf(g.buf, "                offset += %s;\n", lenVar)
			} else {
				fmt.Fprintf(g.buf, "                obj.%s = ", fieldName)
				g.generatePrimitiveDecode(typ.Name)
				g.buf.WriteString(";\n")
			}
			g.buf.WriteString("            }\n")
		} else {
			if typ.Name == "string" {
				// Inline string decoding (like blueprint) for better performance
				lenVar := fmt.Sprintf("_len_%s", strings.ToLower(fieldName))
				fmt.Fprintf(g.buf, "            int %s = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n", lenVar)
				g.buf.WriteString("            offset += 2;\n")
				fmt.Fprintf(g.buf, "            obj.%s = %s > 0 ? Encoding.UTF8.GetString(buffer.Slice(offset, %s)) : \"\";\n", fieldName, lenVar, lenVar)
				fmt.Fprintf(g.buf, "            offset += %s;\n", lenVar)
			} else {
				fmt.Fprintf(g.buf, "            obj.%s = ", fieldName)
				g.generatePrimitiveDecode(typ.Name)
				g.buf.WriteString(";\n")
			}
		}
	case *schema.ArrayType:
		if typ.Optional {
			g.buf.WriteString("            if (buffer[offset++] == 1)\n")
			g.buf.WriteString("            {\n")
			g.buf.WriteString("                int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n")
			g.buf.WriteString("                offset += 2;\n")
			elemType := g.csharpType(typ.ElementType)
			fmt.Fprintf(g.buf, "                obj.%s = new %s[length];\n", fieldName, elemType)
			g.generateArrayDecodeLogic(fmt.Sprintf("obj.%s", fieldName), typ, "                ")
			g.buf.WriteString("            }\n")
		} else {
			g.buf.WriteString("            int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n")
			g.buf.WriteString("            offset += 2;\n")
			elemType := g.csharpType(typ.ElementType)
			fmt.Fprintf(g.buf, "            obj.%s = new %s[length];\n", fieldName, elemType)
			g.generateArrayDecodeLogic(fmt.Sprintf("obj.%s", fieldName), typ, "            ")
		}
	case *schema.StructType:
		fmt.Fprintf(g.buf, "            obj.%s = %s.DecodeFrom(buffer, ref offset);\n", fieldName, typ.Name)
	}
}

func (g *csharpGenerator) generateArrayDecodeLogic(fieldName string, arrayType *schema.ArrayType, indent string) {
	// Use MemoryMarshal for bulk primitive array decoding
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
		g.generateBulkArrayDecode(fieldName, prim.Name)
	} else {
		fmt.Fprintf(g.buf, "%sfor (int i = 0; i < length; i++)\n", indent)
		fmt.Fprintf(g.buf, "%s{\n", indent)
		if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
			if prim.Name == "string" {
				// Inline string decoding for better performance (use unique variable name per loop iteration)
				fmt.Fprintf(g.buf, "%s    int _itemLen = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));\n", indent)
				fmt.Fprintf(g.buf, "%s    offset += 2;\n", indent)
				fmt.Fprintf(g.buf, "%s    %s[i] = _itemLen > 0 ? Encoding.UTF8.GetString(buffer.Slice(offset, _itemLen)) : \"\";\n", indent, fieldName)
				fmt.Fprintf(g.buf, "%s    offset += _itemLen;\n", indent)
			} else {
				fmt.Fprintf(g.buf, "%s    %s[i] = ", indent, fieldName)
				g.generatePrimitiveDecode(prim.Name)
				g.buf.WriteString(";\n")
			}
		} else if st, ok := arrayType.ElementType.(*schema.StructType); ok {
			fmt.Fprintf(g.buf, "%s    %s[i] = %s.DecodeFrom(buffer, ref offset);\n", indent, fieldName, st.Name)
		}
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *csharpGenerator) generatePrimitiveDecode(kind string) {
	switch kind {
	case "bool":
		g.buf.WriteString("buffer[offset++] != 0")
	case "i8", "int8":
		g.buf.WriteString("(sbyte)buffer[offset++]")
	case "u8", "uint8":
		g.buf.WriteString("buffer[offset++]")
	case "i16", "int16":
		g.buf.WriteString("BinaryPrimitives.ReadInt16LittleEndian(buffer.Slice(offset, 2)); offset += 2")
	case "u16", "uint16":
		g.buf.WriteString("BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2)); offset += 2")
	case "i32", "int32":
		g.buf.WriteString("BinaryPrimitives.ReadInt32LittleEndian(buffer.Slice(offset, 4)); offset += 4")
	case "u32", "uint32":
		g.buf.WriteString("BinaryPrimitives.ReadUInt32LittleEndian(buffer.Slice(offset, 4)); offset += 4")
	case "i64", "int64":
		g.buf.WriteString("BinaryPrimitives.ReadInt64LittleEndian(buffer.Slice(offset, 8)); offset += 8")
	case "u64", "uint64":
		g.buf.WriteString("BinaryPrimitives.ReadUInt64LittleEndian(buffer.Slice(offset, 8)); offset += 8")
	case "f32", "float32":
		g.buf.WriteString("BinaryPrimitives.ReadSingleLittleEndian(buffer.Slice(offset, 4)); offset += 4")
	case "f64", "float64":
		g.buf.WriteString("BinaryPrimitives.ReadDoubleLittleEndian(buffer.Slice(offset, 8)); offset += 8")
	case "string":
		g.buf.WriteString("FFireHelpers.DecodeString(buffer, ref offset)")
	}
}

func (g *csharpGenerator) toPascalCase(s string) string {
	if len(s) == 0 {
		return s
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func (g *csharpGenerator) toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}
	pascal := g.toPascalCase(s)
	if len(pascal) > 0 {
		return strings.ToLower(pascal[:1]) + pascal[1:]
	}
	return pascal
}

func (g *csharpGenerator) needsStringDecoder() bool {
	for _, msg := range g.schema.Messages {
		if g.typeUsesStrings(msg.TargetType) {
			return true
		}
	}
	return false
}

func (g *csharpGenerator) typeUsesStrings(t schema.Type) bool {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return typ.Name == "string"
	case *schema.ArrayType:
		return g.typeUsesStrings(typ.ElementType)
	case *schema.StructType:
		for _, field := range typ.Fields {
			if g.typeUsesStrings(field.Type) {
				return true
			}
		}
	}
	return false
}
