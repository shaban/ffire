package generator

import (
"bytes"
"fmt"
"os"
"path/filepath"
)

// GenerateCSharpPackage generates a complete C# NuGet package
func GenerateCSharpPackage(config *PackageConfig) error {
	return orchestrateTierBPackage(
config,
CSharpLayout,
generateCSharpWrapperOrchestrated,
generateCSharpMetadataOrchestrated,
printCSharpInstructions,
)
}

func generateCSharpWrapperOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	projectName := ToPascalCase(config.Namespace)
	csharpDir := filepath.Join(paths.Root, "src", projectName)
	if err := os.MkdirAll(csharpDir, 0755); err != nil {
		return fmt.Errorf("failed to create C# source directory: %w", err)
	}
	return generateCSharpFiles(config, csharpDir)
}

func generateCSharpMetadataOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	projectName := ToPascalCase(config.Namespace)
	csharpDir := filepath.Join(paths.Root, "src", projectName)
	if err := generateCSharpProject(config, csharpDir); err != nil {
		return err
	}
	return generateCSharpReadme(config, paths.Root)
}

func printCSharpInstructions(config *PackageConfig, paths *PackagePaths) {
	projectName := ToPascalCase(config.Namespace)
	projectPath := filepath.Join(paths.Root, "src", projectName)
	fmt.Printf("\n✅ C# NuGet package ready at: %s\n\n", paths.Root)
	fmt.Println("Build:")
	fmt.Printf("  cd %s\n", projectPath)
	fmt.Println("  dotnet build")
	fmt.Println()
}

func generateCSharpFiles(config *PackageConfig, srcDir string) error {
	namespace := ToPascalCase(config.Namespace)
	
	// Exception
	exc := fmt.Sprintf(`// Code generated by ffire. DO NOT EDIT.

using System;

namespace %s
{
    public class %sException : Exception
    {
        public %sException() { }
        public %sException(string message) : base(message) { }
        public %sException(string message, Exception inner) : base(message, inner) { }
    }
}
`, namespace, namespace, namespace, namespace, namespace)
	if err := os.WriteFile(filepath.Join(srcDir, namespace+"Exception.cs"), []byte(exc), 0644); err != nil {
		return err
	}
	fmt.Printf("✓ Generated %sException.cs\n", namespace)
	
	// NativeLibrary
	native := fmt.Sprintf(`// Code generated by ffire. DO NOT EDIT.

using System;
using System.Runtime.InteropServices;

namespace %s
{
    internal static class NativeLibrary
    {
        private const string LibName = "ffire";

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr ffire_decode(byte[] data, int len);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr ffire_encode(IntPtr msg);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void ffire_free(IntPtr msg);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        internal static extern IntPtr ffire_get_error();

        internal static string GetLastError()
        {
            IntPtr errPtr = ffire_get_error();
            if (errPtr == IntPtr.Zero) return "Unknown error";
            return Marshal.PtrToStringAnsi(errPtr) ?? "Unknown error";
        }
    }
}
`, namespace)
	if err := os.WriteFile(filepath.Join(srcDir, "NativeLibrary.cs"), []byte(native), 0644); err != nil {
		return err
	}
	fmt.Println("✓ Generated NativeLibrary.cs")
	
	// Message
	msg := fmt.Sprintf(`// Code generated by ffire. DO NOT EDIT.

using System;
using System.Runtime.InteropServices;

namespace %s
{
    public class Message : IDisposable
    {
        private IntPtr handle;
        private bool disposed = false;

        private Message(IntPtr handle) { this.handle = handle; }

        public static Message Decode(byte[] data)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            IntPtr handle = NativeLibrary.ffire_decode(data, data.Length);
            if (handle == IntPtr.Zero)
            {
                throw new %sException($"Decode failed: {NativeLibrary.GetLastError()}");
            }
            return new Message(handle);
        }

        public byte[] Encode()
        {
            if (disposed) throw new ObjectDisposedException(nameof(Message));
            IntPtr resultPtr = NativeLibrary.ffire_encode(handle);
            if (resultPtr == IntPtr.Zero)
            {
                throw new %sException($"Encode failed: {NativeLibrary.GetLastError()}");
            }
            int length = Marshal.ReadInt32(resultPtr);
            byte[] data = new byte[length];
            Marshal.Copy(resultPtr + 4, data, 0, length);
            return data;
        }

        public void Free() { Dispose(); }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (handle != IntPtr.Zero)
                {
                    NativeLibrary.ffire_free(handle);
                    handle = IntPtr.Zero;
                }
                disposed = true;
            }
        }

        ~Message() { Dispose(false); }
    }
}
`, namespace, namespace, namespace)
	if err := os.WriteFile(filepath.Join(srcDir, "Message.cs"), []byte(msg), 0644); err != nil {
		return err
	}
	fmt.Println("✓ Generated Message.cs")
	
	return nil
}

func generateCSharpProject(config *PackageConfig, srcDir string) error {
	buf := &bytes.Buffer{}
	projectName := ToPascalCase(config.Namespace)
	
	buf.WriteString("<Project Sdk=\"Microsoft.NET.Sdk\">\n\n")
	buf.WriteString("  <PropertyGroup>\n")
	buf.WriteString("    <TargetFramework>net6.0</TargetFramework>\n")
	fmt.Fprintf(buf, "    <RootNamespace>%s</RootNamespace>\n", projectName)
	fmt.Fprintf(buf, "    <AssemblyName>%s</AssemblyName>\n", projectName)
	buf.WriteString("    <Version>1.0.0</Version>\n")
	buf.WriteString("    <Authors>FFireGenerator</Authors>\n")
	buf.WriteString("    <LangVersion>latest</LangVersion>\n")
	buf.WriteString("  </PropertyGroup>\n\n")
	buf.WriteString("</Project>\n")

	filePath := filepath.Join(srcDir, projectName+".csproj")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write .csproj: %w", err)
	}
	fmt.Printf("✓ Generated %s.csproj\n", projectName)
	return nil
}

func generateCSharpReadme(config *PackageConfig, csharpDir string) error {
	buf := &bytes.Buffer{}
	projectName := ToPascalCase(config.Namespace)
	
	fmt.Fprintf(buf, "# %s - C# Bindings\n\n", projectName)
	buf.WriteString("C# NuGet package with P/Invoke bindings.\n\n")
	buf.WriteString("## Build\n\n```bash\n")
fmt.Fprintf(buf, "cd src/%s\n", projectName)
buf.WriteString("dotnet build\n```\n\n")
	buf.WriteString("## Usage\n\n```csharp\n")
fmt.Fprintf(buf, "using %s;\n\n", projectName)
buf.WriteString("byte[] data = File.ReadAllBytes(\"data.bin\");\n")
buf.WriteString("using (var msg = Message.Decode(data)) {\n")
buf.WriteString("    byte[] encoded = msg.Encode();\n")
buf.WriteString("}\n```\n")

	filePath := filepath.Join(csharpDir, "README.md")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}
	fmt.Println("✓ Generated README.md")
	return nil
}
