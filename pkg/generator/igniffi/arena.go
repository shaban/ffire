package igniffi

import "strings"

// GenerateArenaHeader generates igniffi_arena.h
func GenerateArenaHeader() string {
	var b strings.Builder

	b.WriteString(`// Code generated by ffire - DO NOT EDIT
// igniffi - Micro ffire C API
// Arena memory management

#ifndef IGNIFFI_ARENA_H
#define IGNIFFI_ARENA_H

#include "igniffi_types.h"

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// Arena Type (opaque)
// ============================================================================

typedef struct igniffi_Arena igniffi_Arena;

// ============================================================================
// Arena Management
// ============================================================================

// Create a new arena with default initial size (4KB)
igniffi_Arena* igniffi_arena_new(void);

// Create arena with specific initial size
igniffi_Arena* igniffi_arena_new_sized(size_t initial_size);

// Free an arena and all memory allocated within it
void igniffi_arena_free(igniffi_Arena* arena);

// Get arena statistics (for debugging)
igniffi_ArenaStats igniffi_arena_stats(const igniffi_Arena* arena);

// ============================================================================
// Arena Allocation (internal use - rarely needed directly)
// ============================================================================

// Allocate memory from arena (aligned to 8 bytes)
void* igniffi_arena_alloc(igniffi_Arena* arena, size_t size);

// Copy StringView to arena (allocates new buffer)
igniffi_StringView igniffi_stringview_copy(igniffi_StringView src, igniffi_Arena* arena);

// Create null-terminated C string from StringView (allocates in arena)
const char* igniffi_stringview_to_cstr(igniffi_StringView sv, igniffi_Arena* arena);

#ifdef __cplusplus
}
#endif

#endif // IGNIFFI_ARENA_H
`)

	return b.String()
}

// GenerateArenaImpl generates igniffi_arena.c
func GenerateArenaImpl() string {
	var b strings.Builder

	b.WriteString(`// Code generated by ffire - DO NOT EDIT
// igniffi - Micro ffire C API
// Arena memory management implementation

#include "igniffi_arena.h"
#include <stdlib.h>
#include <string.h>

// ============================================================================
// Arena Implementation
// ============================================================================

#define IGNIFFI_ARENA_DEFAULT_SIZE 4096
#define IGNIFFI_ARENA_ALIGN 8

typedef struct igniffi_ArenaBlock {
    struct igniffi_ArenaBlock* next;
    size_t size;
    size_t used;
    char data[];  // Flexible array member
} igniffi_ArenaBlock;

struct igniffi_Arena {
    igniffi_ArenaBlock* current;
    igniffi_ArenaBlock* first;
    size_t total_allocated;
    size_t num_blocks;
};

// Align size up to IGNIFFI_ARENA_ALIGN bytes
static inline size_t align_size(size_t size) {
    return (size + IGNIFFI_ARENA_ALIGN - 1) & ~(IGNIFFI_ARENA_ALIGN - 1);
}

// Create a new arena block
static igniffi_ArenaBlock* create_block(size_t size) {
    size_t block_size = sizeof(igniffi_ArenaBlock) + size;
    igniffi_ArenaBlock* block = (igniffi_ArenaBlock*)malloc(block_size);
    if (!block) return NULL;
    
    block->next = NULL;
    block->size = size;
    block->used = 0;
    return block;
}

// ============================================================================
// Public API
// ============================================================================

igniffi_Arena* igniffi_arena_new(void) {
    return igniffi_arena_new_sized(IGNIFFI_ARENA_DEFAULT_SIZE);
}

igniffi_Arena* igniffi_arena_new_sized(size_t initial_size) {
    igniffi_Arena* arena = (igniffi_Arena*)malloc(sizeof(igniffi_Arena));
    if (!arena) return NULL;
    
    igniffi_ArenaBlock* block = create_block(initial_size);
    if (!block) {
        free(arena);
        return NULL;
    }
    
    arena->current = block;
    arena->first = block;
    arena->total_allocated = initial_size;
    arena->num_blocks = 1;
    
    return arena;
}

void igniffi_arena_free(igniffi_Arena* arena) {
    if (!arena) return;
    
    igniffi_ArenaBlock* block = arena->first;
    while (block) {
        igniffi_ArenaBlock* next = block->next;
        free(block);
        block = next;
    }
    
    free(arena);
}

igniffi_ArenaStats igniffi_arena_stats(const igniffi_Arena* arena) {
    igniffi_ArenaStats stats;
    if (!arena) {
        stats.bytes_allocated = 0;
        stats.num_blocks = 0;
        return stats;
    }
    
    stats.bytes_allocated = arena->total_allocated;
    stats.num_blocks = arena->num_blocks;
    return stats;
}

void* igniffi_arena_alloc(igniffi_Arena* arena, size_t size) {
    if (!arena || size == 0) return NULL;
    
    size_t aligned_size = align_size(size);
    
    // Try current block
    if (arena->current->used + aligned_size <= arena->current->size) {
        void* ptr = arena->current->data + arena->current->used;
        arena->current->used += aligned_size;
        return ptr;
    }
    
    // Need new block - allocate at least double the requested size
    size_t new_block_size = aligned_size * 2;
    if (new_block_size < IGNIFFI_ARENA_DEFAULT_SIZE) {
        new_block_size = IGNIFFI_ARENA_DEFAULT_SIZE;
    }
    
    igniffi_ArenaBlock* new_block = create_block(new_block_size);
    if (!new_block) return NULL;
    
    // Link new block
    arena->current->next = new_block;
    arena->current = new_block;
    arena->total_allocated += new_block_size;
    arena->num_blocks++;
    
    // Allocate from new block
    void* ptr = new_block->data;
    new_block->used = aligned_size;
    return ptr;
}

igniffi_StringView igniffi_stringview_copy(igniffi_StringView src, igniffi_Arena* arena) {
    if (src.size == 0 || !src.data) {
        igniffi_StringView empty;
        empty.data = NULL;
        empty.size = 0;
        return empty;
    }
    
    char* buf = (char*)igniffi_arena_alloc(arena, src.size);
    if (!buf) {
        igniffi_StringView empty;
        empty.data = NULL;
        empty.size = 0;
        return empty;
    }
    
    memcpy(buf, src.data, src.size);
    
    igniffi_StringView result;
    result.data = buf;
    result.size = src.size;
    return result;
}

const char* igniffi_stringview_to_cstr(igniffi_StringView sv, igniffi_Arena* arena) {
    if (sv.size == 0 || !sv.data) {
        char* empty = (char*)igniffi_arena_alloc(arena, 1);
        if (empty) empty[0] = '\0';
        return empty;
    }
    
    char* buf = (char*)igniffi_arena_alloc(arena, sv.size + 1);
    if (!buf) return NULL;
    
    memcpy(buf, sv.data, sv.size);
    buf[sv.size] = '\0';
    return buf;
}
`)

	return b.String()
}
