// Package igniffi generates the micro ffire C API (igniffi).
// igniffi provides a minimal, arena-based C API for dynamic languages.
package igniffi

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// Generate creates igniffi C API code for the given schema
func Generate(s *schema.Schema, outputDir string) error {
	// Create output directories
	includeDir := filepath.Join(outputDir, "include")
	srcDir := filepath.Join(outputDir, "src")

	if err := os.MkdirAll(includeDir, 0755); err != nil {
		return fmt.Errorf("failed to create include directory: %w", err)
	}
	if err := os.MkdirAll(srcDir, 0755); err != nil {
		return fmt.Errorf("failed to create src directory: %w", err)
	}

	// Generate header files
	if err := generateHeaders(s, includeDir); err != nil {
		return fmt.Errorf("failed to generate headers: %w", err)
	}

	// Generate implementation files
	if err := generateImplementations(s, srcDir); err != nil {
		return fmt.Errorf("failed to generate implementations: %w", err)
	}

	return nil
}

func generateHeaders(s *schema.Schema, outputDir string) error {
	// Generate igniffi_types.h
	typesContent := GenerateTypesHeader()
	if err := writeFile(filepath.Join(outputDir, "igniffi_types.h"), typesContent); err != nil {
		return err
	}

	// Generate igniffi_arena.h
	arenaContent := GenerateArenaHeader()
	if err := writeFile(filepath.Join(outputDir, "igniffi_arena.h"), arenaContent); err != nil {
		return err
	}

	// Generate schema-specific header (igniffi_{package}.h)
	schemaHeaderContent := GenerateSchemaHeader(s)
	headerName := fmt.Sprintf("igniffi_%s.h", s.Package)
	if err := writeFile(filepath.Join(outputDir, headerName), schemaHeaderContent); err != nil {
		return err
	}

	// Generate main umbrella header (igniffi.h)
	umbrellaContent := GenerateUmbrellaHeader(s)
	if err := writeFile(filepath.Join(outputDir, "igniffi.h"), umbrellaContent); err != nil {
		return err
	}

	return nil
}

func generateImplementations(s *schema.Schema, outputDir string) error {
	// Generate igniffi_arena.c
	arenaImplContent := GenerateArenaImpl()
	if err := writeFile(filepath.Join(outputDir, "igniffi_arena.c"), arenaImplContent); err != nil {
		return err
	}

	// Generate schema-specific implementation (igniffi_{package}.c)
	codecImplContent := GenerateCodecImpl(s)
	implName := fmt.Sprintf("igniffi_%s.c", s.Package)
	if err := writeFile(filepath.Join(outputDir, implName), codecImplContent); err != nil {
		return err
	}

	return nil
}

// GenerateUmbrellaHeader generates the main igniffi.h that includes everything
func GenerateUmbrellaHeader(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`// Code generated by ffire - DO NOT EDIT
// igniffi - Micro ffire C API
// Main header (includes all components)

#ifndef IGNIFFI_H
#define IGNIFFI_H

#include "igniffi_types.h"
#include "igniffi_arena.h"
`)

	// Include schema-specific header
	fmt.Fprintf(&b, "#include \"igniffi_%s.h\"\n\n", s.Package)

	b.WriteString("#endif // IGNIFFI_H\n")

	return b.String()
}

// GenerateSchemaHeader generates the schema-specific header with structs, accessors, and codec
func GenerateSchemaHeader(s *schema.Schema) string {
	var b strings.Builder

	packageUpper := strings.ToUpper(s.Package)

	b.WriteString("// Code generated by ffire - DO NOT EDIT\n")
	fmt.Fprintf(&b, "// igniffi - Micro ffire C API for %s\n\n", s.Package)

	fmt.Fprintf(&b, "#ifndef IGNIFFI_%s_H\n", packageUpper)
	fmt.Fprintf(&b, "#define IGNIFFI_%s_H\n\n", packageUpper)

	b.WriteString("#include \"igniffi_types.h\"\n")
	b.WriteString("#include \"igniffi_arena.h\"\n\n")

	b.WriteString("#ifdef __cplusplus\n")
	b.WriteString("extern \"C\" {\n")
	b.WriteString("#endif\n\n")

	// Generate struct definitions
	b.WriteString(GenerateStructs(s))

	// Generate accessor functions
	b.WriteString(GenerateAccessors(s))

	// Generate encode/decode function declarations
	b.WriteString(GenerateCodecHeader(s))

	b.WriteString("#ifdef __cplusplus\n")
	b.WriteString("}\n")
	b.WriteString("#endif\n\n")

	fmt.Fprintf(&b, "#endif // IGNIFFI_%s_H\n", packageUpper)

	return b.String()
}

func writeFile(path string, content string) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", path, err)
	}
	defer f.Close()

	if _, err := f.WriteString(content); err != nil {
		return fmt.Errorf("failed to write to file %s: %w", path, err)
	}

	return nil
}
