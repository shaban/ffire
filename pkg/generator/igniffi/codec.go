package igniffi

import (
	"fmt"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateCodecHeader generates igniffi_codec.h with encode/decode declarations
func GenerateCodecHeader(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString("// ============================================================================\n")
	b.WriteString("// Encode/Decode Functions\n")
	b.WriteString("// ============================================================================\n\n")

	// Generate encode/decode for each root message type
	for _, msg := range s.Messages {
		msgName := toCIdentifier(msg.Name)

		// Decode function
		fmt.Fprintf(&b, "// Decode %s from wire format\n", msg.Name)
		fmt.Fprintf(&b, "igniffi_%s* igniffi_decode_%s(\n", msgName, msgName)
		fmt.Fprintf(&b, "    const uint8_t* data,\n")
		fmt.Fprintf(&b, "    size_t len,\n")
		fmt.Fprintf(&b, "    igniffi_Arena* arena,\n")
		fmt.Fprintf(&b, "    igniffi_Status* status);\n\n")

		// Encode function
		fmt.Fprintf(&b, "// Encode %s to wire format\n", msg.Name)
		fmt.Fprintf(&b, "uint8_t* igniffi_encode_%s(\n", msgName)
		fmt.Fprintf(&b, "    const igniffi_%s* msg,\n", msgName)
		fmt.Fprintf(&b, "    size_t* out_len,\n")
		fmt.Fprintf(&b, "    igniffi_Arena* arena,\n")
		fmt.Fprintf(&b, "    igniffi_Status* status);\n\n")
	}

	return b.String()
}

// GenerateCodecImpl generates igniffi_codec.c with encode/decode implementations
func GenerateCodecImpl(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`// Code generated by ffire - DO NOT EDIT
// igniffi - Micro ffire C API
// Encode/Decode implementation

#include "igniffi.h"
#include <string.h>

// ============================================================================
// Internal Encoder
// ============================================================================

typedef struct {
    uint8_t* data;
    size_t capacity;
    size_t size;
    igniffi_Arena* arena;
} igniffi_Encoder;

static igniffi_Encoder* encoder_new(igniffi_Arena* arena) {
    igniffi_Encoder* enc = (igniffi_Encoder*)igniffi_arena_alloc(arena, sizeof(igniffi_Encoder));
    if (!enc) return NULL;
    
    enc->capacity = 1024;
    enc->data = (uint8_t*)igniffi_arena_alloc(arena, enc->capacity);
    if (!enc->data) return NULL;
    
    enc->size = 0;
    enc->arena = arena;
    return enc;
}

static bool encoder_ensure_capacity(igniffi_Encoder* enc, size_t needed) {
    if (enc->size + needed <= enc->capacity) return true;
    
    size_t new_capacity = enc->capacity * 2;
    while (new_capacity < enc->size + needed) {
        new_capacity *= 2;
    }
    
    uint8_t* new_data = (uint8_t*)igniffi_arena_alloc(enc->arena, new_capacity);
    if (!new_data) return false;
    
    memcpy(new_data, enc->data, enc->size);
    enc->data = new_data;
    enc->capacity = new_capacity;
    return true;
}

static void encoder_write_byte(igniffi_Encoder* enc, uint8_t b) {
    encoder_ensure_capacity(enc, 1);
    enc->data[enc->size++] = b;
}

static void encoder_write_bool(igniffi_Encoder* enc, bool v) {
    encoder_write_byte(enc, v ? 0x01 : 0x00);
}

static void encoder_write_int8(igniffi_Encoder* enc, int8_t v) {
    encoder_write_byte(enc, (uint8_t)v);
}

static void encoder_write_int16(igniffi_Encoder* enc, int16_t v) {
    encoder_ensure_capacity(enc, 2);
    uint16_t u = (uint16_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
}

static void encoder_write_int32(igniffi_Encoder* enc, int32_t v) {
    encoder_ensure_capacity(enc, 4);
    uint32_t u = (uint32_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
    enc->data[enc->size++] = (uint8_t)(u >> 16);
    enc->data[enc->size++] = (uint8_t)(u >> 24);
}

static void encoder_write_int64(igniffi_Encoder* enc, int64_t v) {
    encoder_ensure_capacity(enc, 8);
    uint64_t u = (uint64_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
    enc->data[enc->size++] = (uint8_t)(u >> 16);
    enc->data[enc->size++] = (uint8_t)(u >> 24);
    enc->data[enc->size++] = (uint8_t)(u >> 32);
    enc->data[enc->size++] = (uint8_t)(u >> 40);
    enc->data[enc->size++] = (uint8_t)(u >> 48);
    enc->data[enc->size++] = (uint8_t)(u >> 56);
}

static void encoder_write_float32(igniffi_Encoder* enc, float v) {
    union { float f; uint32_t u; } converter;
    converter.f = v;
    encoder_write_int32(enc, (int32_t)converter.u);
}

static void encoder_write_float64(igniffi_Encoder* enc, double v) {
    union { double f; uint64_t u; } converter;
    converter.f = v;
    encoder_write_int64(enc, (int64_t)converter.u);
}

static void encoder_write_string(igniffi_Encoder* enc, igniffi_StringView sv) {
    uint16_t len = (uint16_t)sv.size;
    encoder_write_int16(enc, (int16_t)len);
    if (len > 0) {
        encoder_ensure_capacity(enc, len);
        memcpy(enc->data + enc->size, sv.data, len);
        enc->size += len;
    }
}

static void encoder_write_array_length(igniffi_Encoder* enc, uint16_t len) {
    encoder_write_int16(enc, (int16_t)len);
}

static void encoder_write_optional_present(igniffi_Encoder* enc, bool present) {
    encoder_write_byte(enc, present ? 0x01 : 0x00);
}

// ============================================================================
// Internal Decoder
// ============================================================================

typedef struct {
    const uint8_t* data;
    size_t size;
    size_t pos;
} igniffi_Decoder;

static igniffi_Decoder* decoder_new(const uint8_t* data, size_t size, igniffi_Arena* arena) {
    igniffi_Decoder* dec = (igniffi_Decoder*)igniffi_arena_alloc(arena, sizeof(igniffi_Decoder));
    if (!dec) return NULL;
    dec->data = data;
    dec->size = size;
    dec->pos = 0;
    return dec;
}

static bool decoder_check_remaining(igniffi_Decoder* dec, size_t needed) {
    return dec->pos + needed <= dec->size;
}

static bool decoder_read_bool(igniffi_Decoder* dec, bool* out) {
    if (!decoder_check_remaining(dec, 1)) return false;
    *out = dec->data[dec->pos++] != 0x00;
    return true;
}

static bool decoder_read_int8(igniffi_Decoder* dec, int8_t* out) {
    if (!decoder_check_remaining(dec, 1)) return false;
    *out = (int8_t)dec->data[dec->pos++];
    return true;
}

static bool decoder_read_int16(igniffi_Decoder* dec, int16_t* out) {
    if (!decoder_check_remaining(dec, 2)) return false;
    uint16_t u = (uint16_t)dec->data[dec->pos] |
                 ((uint16_t)dec->data[dec->pos + 1] << 8);
    dec->pos += 2;
    *out = (int16_t)u;
    return true;
}

static bool decoder_read_int32(igniffi_Decoder* dec, int32_t* out) {
    if (!decoder_check_remaining(dec, 4)) return false;
    uint32_t u = (uint32_t)dec->data[dec->pos] |
                 ((uint32_t)dec->data[dec->pos + 1] << 8) |
                 ((uint32_t)dec->data[dec->pos + 2] << 16) |
                 ((uint32_t)dec->data[dec->pos + 3] << 24);
    dec->pos += 4;
    *out = (int32_t)u;
    return true;
}

static bool decoder_read_int64(igniffi_Decoder* dec, int64_t* out) {
    if (!decoder_check_remaining(dec, 8)) return false;
    uint64_t u = (uint64_t)dec->data[dec->pos] |
                 ((uint64_t)dec->data[dec->pos + 1] << 8) |
                 ((uint64_t)dec->data[dec->pos + 2] << 16) |
                 ((uint64_t)dec->data[dec->pos + 3] << 24) |
                 ((uint64_t)dec->data[dec->pos + 4] << 32) |
                 ((uint64_t)dec->data[dec->pos + 5] << 40) |
                 ((uint64_t)dec->data[dec->pos + 6] << 48) |
                 ((uint64_t)dec->data[dec->pos + 7] << 56);
    dec->pos += 8;
    *out = (int64_t)u;
    return true;
}

static bool decoder_read_float32(igniffi_Decoder* dec, float* out) {
    int32_t i;
    if (!decoder_read_int32(dec, &i)) return false;
    union { float f; uint32_t u; } converter;
    converter.u = (uint32_t)i;
    *out = converter.f;
    return true;
}

static bool decoder_read_float64(igniffi_Decoder* dec, double* out) {
    int64_t i;
    if (!decoder_read_int64(dec, &i)) return false;
    union { double f; uint64_t u; } converter;
    converter.u = (uint64_t)i;
    *out = converter.f;
    return true;
}

static bool decoder_read_string(igniffi_Decoder* dec, igniffi_StringView* out, igniffi_Arena* arena) {
    int16_t len_signed;
    if (!decoder_read_int16(dec, &len_signed)) return false;
    uint16_t len = (uint16_t)len_signed;
    
    if (!decoder_check_remaining(dec, len)) return false;
    
    if (len == 0) {
        out->data = NULL;
        out->size = 0;
        return true;
    }
    
    // Copy string data to arena
    char* buf = (char*)igniffi_arena_alloc(arena, len);
    if (!buf) return false;
    memcpy(buf, dec->data + dec->pos, len);
    dec->pos += len;
    
    out->data = buf;
    out->size = len;
    return true;
}

static bool decoder_read_array_length(igniffi_Decoder* dec, uint16_t* out) {
    int16_t len;
    if (!decoder_read_int16(dec, &len)) return false;
    *out = (uint16_t)len;
    return true;
}

static bool decoder_read_optional_present(igniffi_Decoder* dec, bool* out) {
    return decoder_read_bool(dec, out);
}

`)

	// Generate encode/decode implementations for each root message
	for _, msg := range s.Messages {
		generateMessageCodec(&b, s, &msg)
	}

	return b.String()
}

func generateMessageCodec(b *strings.Builder, s *schema.Schema, msg *schema.MessageType) {
	msgName := toCIdentifier(msg.Name)

	b.WriteString("// ============================================================================\n")
	fmt.Fprintf(b, "// %s Codec\n", msg.Name)
	b.WriteString("// ============================================================================\n\n")

	// Forward declare helper functions
	generateCodecForwardDecls(b, s, msg.TargetType, msg.Name)

	// Generate helper encode/decode functions for nested types
	generateTypeCodecHelpers(b, s, msg.TargetType, msg.Name)

	// Generate main decode function
	fmt.Fprintf(b, "igniffi_%s* igniffi_decode_%s(\n", msgName, msgName)
	b.WriteString("    const uint8_t* data,\n")
	b.WriteString("    size_t len,\n")
	b.WriteString("    igniffi_Arena* arena,\n")
	b.WriteString("    igniffi_Status* status) {\n")
	b.WriteString("    \n")
	b.WriteString("    if (!data || len == 0 || !arena || !status) {\n")
	b.WriteString("        if (status) *status = igniffi_error(\"Invalid arguments\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")
	b.WriteString("    igniffi_Decoder* dec = decoder_new(data, len, arena);\n")
	b.WriteString("    if (!dec) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to create decoder\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	fmt.Fprintf(b, "    igniffi_%s* msg = (igniffi_%s*)igniffi_arena_alloc(arena, sizeof(igniffi_%s));\n",
		msgName, msgName, msgName)
	b.WriteString("    if (!msg) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to allocate message\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	// Decode based on target type - both struct and array use decode_{msgName}
	fmt.Fprintf(b, "    if (!decode_%s(dec, msg, arena)) {\n", msgName)
	if _, ok := msg.TargetType.(*schema.ArrayType); ok {
		b.WriteString("        *status = igniffi_error(\"Failed to decode array\");\n")
	} else {
		b.WriteString("        *status = igniffi_error(\"Failed to decode message\");\n")
	}
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	b.WriteString("    *status = igniffi_ok();\n")
	b.WriteString("    return msg;\n")
	b.WriteString("}\n\n")

	// Generate main encode function
	fmt.Fprintf(b, "uint8_t* igniffi_encode_%s(\n", msgName)
	fmt.Fprintf(b, "    const igniffi_%s* msg,\n", msgName)
	b.WriteString("    size_t* out_len,\n")
	b.WriteString("    igniffi_Arena* arena,\n")
	b.WriteString("    igniffi_Status* status) {\n")
	b.WriteString("    \n")
	b.WriteString("    if (!msg || !out_len || !arena || !status) {\n")
	b.WriteString("        if (status) *status = igniffi_error(\"Invalid arguments\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")
	b.WriteString("    igniffi_Encoder* enc = encoder_new(arena);\n")
	b.WriteString("    if (!enc) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to create encoder\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	// Encode based on target type - both struct and array use encode_{msgName}
	fmt.Fprintf(b, "    encode_%s(enc, msg);\n\n", msgName)

	b.WriteString("    *out_len = enc->size;\n")
	b.WriteString("    *status = igniffi_ok();\n")
	b.WriteString("    return enc->data;\n")
	b.WriteString("}\n\n")
}

func generateCodecForwardDecls(b *strings.Builder, s *schema.Schema, typ schema.Type, msgName string) {
	// Generate forward declarations for all helper functions
	switch t := typ.(type) {
	case *schema.StructType:
		// Collect all nested struct types (depth-first for correct ordering)
		nestedTypes := collectNestedStructTypes(t, make(map[string]bool))
		for _, nested := range nestedTypes {
			nestedName := toCIdentifier(nested.Name)
			fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
				nestedName, nestedName)
			fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n",
				nestedName, nestedName)
		}
		structName := toCIdentifier(t.Name)
		fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
			structName, structName)
		fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n\n",
			structName, structName)
	case *schema.ArrayType:
		// For array of structs, also need to forward declare the element struct codec
		if elemStruct, ok := t.ElementType.(*schema.StructType); ok {
			nestedTypes := collectNestedStructTypes(elemStruct, make(map[string]bool))
			for _, nested := range nestedTypes {
				nestedName := toCIdentifier(nested.Name)
				fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
					nestedName, nestedName)
				fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n",
					nestedName, nestedName)
			}
			elemName := toCIdentifier(elemStruct.Name)
			fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
				elemName, elemName)
			fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n",
				elemName, elemName)
		}
		structName := toCIdentifier(msgName)
		fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
			structName, structName)
		fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n\n",
			structName, structName)
	}
}

// collectNestedStructTypes collects all nested struct types in dependency order
func collectNestedStructTypes(structType *schema.StructType, seen map[string]bool) []*schema.StructType {
	var result []*schema.StructType
	for _, field := range structType.Fields {
		switch t := field.Type.(type) {
		case *schema.StructType:
			if !seen[t.Name] {
				seen[t.Name] = true
				// Recursively collect nested types first
				result = append(result, collectNestedStructTypes(t, seen)...)
				result = append(result, t)
			}
		case *schema.ArrayType:
			if elemStruct, ok := t.ElementType.(*schema.StructType); ok {
				if !seen[elemStruct.Name] {
					seen[elemStruct.Name] = true
					result = append(result, collectNestedStructTypes(elemStruct, seen)...)
					result = append(result, elemStruct)
				}
			}
		}
	}
	return result
}

func generateTypeCodecHelpers(b *strings.Builder, s *schema.Schema, typ schema.Type, msgName string) {
	switch t := typ.(type) {
	case *schema.StructType:
		// Generate helpers for nested types first (in dependency order)
		nestedTypes := collectNestedStructTypes(t, make(map[string]bool))
		for _, nested := range nestedTypes {
			generateStructCodecHelper(b, s, nested)
		}
		generateStructCodecHelper(b, s, t)
	case *schema.ArrayType:
		// For array of structs, generate element struct codec first
		if elemStruct, ok := t.ElementType.(*schema.StructType); ok {
			nestedTypes := collectNestedStructTypes(elemStruct, make(map[string]bool))
			for _, nested := range nestedTypes {
				generateStructCodecHelper(b, s, nested)
			}
			generateStructCodecHelper(b, s, elemStruct)
		}
		generateArrayRootCodecHelper(b, s, t, msgName)
	}
}

func generateStructCodecHelper(b *strings.Builder, s *schema.Schema, structType *schema.StructType) {
	structName := toCIdentifier(structType.Name)

	// Decode helper
	fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena) {\n",
		structName, structName)

	for _, field := range structType.Fields {
		fieldName := toCIdentifier(field.Name)
		generateFieldDecode(b, &field, fieldName, "out->"+fieldName)
	}

	b.WriteString("    return true;\n")
	b.WriteString("}\n\n")

	// Encode helper
	fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg) {\n",
		structName, structName)

	for _, field := range structType.Fields {
		fieldName := toCIdentifier(field.Name)
		generateFieldEncode(b, &field, fieldName, "msg->"+fieldName)
	}

	b.WriteString("}\n\n")
}

func generateArrayRootCodecHelper(b *strings.Builder, s *schema.Schema, arrayType *schema.ArrayType, msgName string) {
	structName := toCIdentifier(msgName)
	elemCType := getCType(arrayType.ElementType)
	// Remove trailing * for allocation
	elemCTypeBase := strings.TrimSuffix(elemCType, "*")

	// Check if element type is a fixed-size primitive (can use memcpy)
	isPrimitive := false
	primitiveSize := 0
	if prim, ok := arrayType.ElementType.(*schema.PrimitiveType); ok {
		switch prim.Name {
		case "bool", "int8":
			isPrimitive = true
			primitiveSize = 1
		case "int16":
			isPrimitive = true
			primitiveSize = 2
		case "int32", "float32":
			isPrimitive = true
			primitiveSize = 4
		case "int64", "float64":
			isPrimitive = true
			primitiveSize = 8
		}
	}

	// Decode helper
	fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena) {\n",
		structName, structName)
	b.WriteString("    uint16_t len;\n")
	b.WriteString("    if (!decoder_read_array_length(dec, &len)) return false;\n")
	b.WriteString("    out->len = len;\n\n")
	b.WriteString("    if (len == 0) {\n")
	b.WriteString("        out->items = NULL;\n")
	b.WriteString("        return true;\n")
	b.WriteString("    }\n\n")

	fmt.Fprintf(b, "    out->items = (%s*)igniffi_arena_alloc(arena, len * sizeof(%s));\n",
		elemCTypeBase, elemCTypeBase)
	b.WriteString("    if (!out->items) return false;\n\n")

	if isPrimitive && primitiveSize > 0 {
		// Bulk memcpy for primitive arrays (little-endian assumed)
		fmt.Fprintf(b, "    size_t bytes = len * %d;\n", primitiveSize)
		b.WriteString("    if (!decoder_check_remaining(dec, bytes)) return false;\n")
		b.WriteString("    memcpy(out->items, dec->data + dec->pos, bytes);\n")
		b.WriteString("    dec->pos += bytes;\n")
	} else {
		// Loop for struct/string arrays
		b.WriteString("    for (uint16_t i = 0; i < len; i++) {\n")
		generateElementDecode(b, arrayType.ElementType, "out->items[i]", "        ")
		b.WriteString("    }\n")
	}
	b.WriteString("    return true;\n")
	b.WriteString("}\n\n")

	// Encode helper
	fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg) {\n",
		structName, structName)
	b.WriteString("    encoder_write_array_length(enc, msg->len);\n")

	if isPrimitive && primitiveSize > 0 {
		// Bulk memcpy for primitive arrays
		fmt.Fprintf(b, "    size_t bytes = msg->len * %d;\n", primitiveSize)
		b.WriteString("    encoder_ensure_capacity(enc, bytes);\n")
		b.WriteString("    memcpy(enc->data + enc->size, msg->items, bytes);\n")
		b.WriteString("    enc->size += bytes;\n")
	} else {
		// Loop for struct/string arrays
		b.WriteString("    for (uint16_t i = 0; i < msg->len; i++) {\n")
		generateElementEncode(b, arrayType.ElementType, "msg->items[i]", "        ")
		b.WriteString("    }\n")
	}
	b.WriteString("}\n\n")
}

// generateElementDecode generates code to decode a single array element
func generateElementDecode(b *strings.Builder, elemType schema.Type, resultVar, indent string) {
	switch typ := elemType.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "%sif (!decoder_read_bool(dec, &%s)) return false;\n", indent, resultVar)
		case "int8":
			fmt.Fprintf(b, "%sif (!decoder_read_int8(dec, &%s)) return false;\n", indent, resultVar)
		case "int16":
			fmt.Fprintf(b, "%sif (!decoder_read_int16(dec, &%s)) return false;\n", indent, resultVar)
		case "int32":
			fmt.Fprintf(b, "%sif (!decoder_read_int32(dec, &%s)) return false;\n", indent, resultVar)
		case "int64":
			fmt.Fprintf(b, "%sif (!decoder_read_int64(dec, &%s)) return false;\n", indent, resultVar)
		case "float32":
			fmt.Fprintf(b, "%sif (!decoder_read_float32(dec, &%s)) return false;\n", indent, resultVar)
		case "float64":
			fmt.Fprintf(b, "%sif (!decoder_read_float64(dec, &%s)) return false;\n", indent, resultVar)
		case "string":
			fmt.Fprintf(b, "%sif (!decoder_read_string(dec, &%s, arena)) return false;\n", indent, resultVar)
		}
	case *schema.StructType:
		structName := toCIdentifier(typ.Name)
		// For struct elements in arrays, the element is stored by value - decode into address
		fmt.Fprintf(b, "%sif (!decode_%s(dec, &%s, arena)) return false;\n", indent, structName, resultVar)
	}
}

// generateElementEncode generates code to encode a single array element
func generateElementEncode(b *strings.Builder, elemType schema.Type, valueVar, indent string) {
	switch typ := elemType.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "%sencoder_write_bool(enc, %s);\n", indent, valueVar)
		case "int8":
			fmt.Fprintf(b, "%sencoder_write_int8(enc, %s);\n", indent, valueVar)
		case "int16":
			fmt.Fprintf(b, "%sencoder_write_int16(enc, %s);\n", indent, valueVar)
		case "int32":
			fmt.Fprintf(b, "%sencoder_write_int32(enc, %s);\n", indent, valueVar)
		case "int64":
			fmt.Fprintf(b, "%sencoder_write_int64(enc, %s);\n", indent, valueVar)
		case "float32":
			fmt.Fprintf(b, "%sencoder_write_float32(enc, %s);\n", indent, valueVar)
		case "float64":
			fmt.Fprintf(b, "%sencoder_write_float64(enc, %s);\n", indent, valueVar)
		case "string":
			fmt.Fprintf(b, "%sencoder_write_string(enc, %s);\n", indent, valueVar)
		}
	case *schema.StructType:
		structName := toCIdentifier(typ.Name)
		// For struct elements in arrays, they're stored by value - pass address
		fmt.Fprintf(b, "%sencode_%s(enc, &%s);\n", indent, structName, valueVar)
	}
}

func generateFieldDecode(b *strings.Builder, field *schema.Field, fieldName, resultVar string) {
	// Check if field type is optional
	isOptional := field.Type.IsOptional()

	if isOptional {
		// Read presence byte first
		fmt.Fprintf(b, "    {\n")
		fmt.Fprintf(b, "        bool has_%s;\n", fieldName)
		fmt.Fprintf(b, "        if (!decoder_read_optional_present(dec, &has_%s)) return false;\n", fieldName)
		fmt.Fprintf(b, "        out->has_%s = has_%s;\n", fieldName, fieldName)
		fmt.Fprintf(b, "        if (has_%s) {\n", fieldName)
	}

	indent := "    "
	if isOptional {
		indent = "            "
	}

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "%sif (!decoder_read_bool(dec, &%s)) return false;\n", indent, resultVar)
		case "int8":
			fmt.Fprintf(b, "%sif (!decoder_read_int8(dec, &%s)) return false;\n", indent, resultVar)
		case "int16":
			fmt.Fprintf(b, "%sif (!decoder_read_int16(dec, &%s)) return false;\n", indent, resultVar)
		case "int32":
			fmt.Fprintf(b, "%sif (!decoder_read_int32(dec, &%s)) return false;\n", indent, resultVar)
		case "int64":
			fmt.Fprintf(b, "%sif (!decoder_read_int64(dec, &%s)) return false;\n", indent, resultVar)
		case "float32":
			fmt.Fprintf(b, "%sif (!decoder_read_float32(dec, &%s)) return false;\n", indent, resultVar)
		case "float64":
			fmt.Fprintf(b, "%sif (!decoder_read_float64(dec, &%s)) return false;\n", indent, resultVar)
		case "string":
			fmt.Fprintf(b, "%sif (!decoder_read_string(dec, &%s, arena)) return false;\n", indent, resultVar)
		}
	case *schema.ArrayType:
		// Array field - read length, allocate, decode elements
		elemCType := getCType(typ.ElementType)
		elemCTypeBase := strings.TrimSuffix(elemCType, "*")

		fmt.Fprintf(b, "%sif (!decoder_read_array_length(dec, &out->%s_len)) return false;\n", indent, fieldName)
		fmt.Fprintf(b, "%sif (out->%s_len > 0) {\n", indent, fieldName)
		fmt.Fprintf(b, "%s    out->%s = (%s*)igniffi_arena_alloc(arena, out->%s_len * sizeof(%s));\n",
			indent, fieldName, elemCTypeBase, fieldName, elemCTypeBase)
		fmt.Fprintf(b, "%s    if (!out->%s) return false;\n", indent, fieldName)
		fmt.Fprintf(b, "%s    for (uint16_t i = 0; i < out->%s_len; i++) {\n", indent, fieldName)
		generateElementDecode(b, typ.ElementType, fmt.Sprintf("out->%s[i]", fieldName), indent+"        ")
		fmt.Fprintf(b, "%s    }\n", indent)
		fmt.Fprintf(b, "%s} else {\n", indent)
		fmt.Fprintf(b, "%s    out->%s = NULL;\n", indent, fieldName)
		fmt.Fprintf(b, "%s}\n", indent)
	case *schema.StructType:
		// Nested struct - decode inline
		structName := toCIdentifier(typ.Name)
		fmt.Fprintf(b, "%sif (!decode_%s(dec, &%s, arena)) return false;\n", indent, structName, resultVar)
	}

	if isOptional {
		fmt.Fprintf(b, "        }\n")
		fmt.Fprintf(b, "    }\n")
	}
}

func generateFieldEncode(b *strings.Builder, field *schema.Field, fieldName, valueVar string) {
	// Check if field type is optional
	isOptional := field.Type.IsOptional()

	if isOptional {
		fmt.Fprintf(b, "    encoder_write_optional_present(enc, msg->has_%s);\n", fieldName)
		fmt.Fprintf(b, "    if (msg->has_%s) {\n", fieldName)
	}

	indent := "    "
	if isOptional {
		indent = "        "
	}

	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "%sencoder_write_bool(enc, %s);\n", indent, valueVar)
		case "int8":
			fmt.Fprintf(b, "%sencoder_write_int8(enc, %s);\n", indent, valueVar)
		case "int16":
			fmt.Fprintf(b, "%sencoder_write_int16(enc, %s);\n", indent, valueVar)
		case "int32":
			fmt.Fprintf(b, "%sencoder_write_int32(enc, %s);\n", indent, valueVar)
		case "int64":
			fmt.Fprintf(b, "%sencoder_write_int64(enc, %s);\n", indent, valueVar)
		case "float32":
			fmt.Fprintf(b, "%sencoder_write_float32(enc, %s);\n", indent, valueVar)
		case "float64":
			fmt.Fprintf(b, "%sencoder_write_float64(enc, %s);\n", indent, valueVar)
		case "string":
			fmt.Fprintf(b, "%sencoder_write_string(enc, %s);\n", indent, valueVar)
		}
	case *schema.ArrayType:
		// Array field - encode length then elements
		fmt.Fprintf(b, "%sencoder_write_array_length(enc, msg->%s_len);\n", indent, fieldName)
		fmt.Fprintf(b, "%sfor (uint16_t i = 0; i < msg->%s_len; i++) {\n", indent, fieldName)
		generateElementEncode(b, typ.ElementType, fmt.Sprintf("msg->%s[i]", fieldName), indent+"    ")
		fmt.Fprintf(b, "%s}\n", indent)
	case *schema.StructType:
		// Nested struct - encode inline
		structName := toCIdentifier(typ.Name)
		fmt.Fprintf(b, "%sencode_%s(enc, &%s);\n", indent, structName, valueVar)
	}

	if isOptional {
		fmt.Fprintf(b, "    }\n")
	}
}

