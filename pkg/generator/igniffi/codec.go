package igniffi

import (
	"fmt"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateCodecHeader generates igniffi_codec.h with encode/decode declarations
func GenerateCodecHeader(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString("// ============================================================================\n")
	b.WriteString("// Encode/Decode Functions\n")
	b.WriteString("// ============================================================================\n\n")

	// Generate encode/decode for each root message type
	for _, msg := range s.Messages {
		msgName := toCIdentifier(msg.Name)

		// Decode function
		fmt.Fprintf(&b, "// Decode %s from wire format\n", msg.Name)
		fmt.Fprintf(&b, "igniffi_%s* igniffi_decode_%s(\n", msgName, msgName)
		fmt.Fprintf(&b, "    const uint8_t* data,\n")
		fmt.Fprintf(&b, "    size_t len,\n")
		fmt.Fprintf(&b, "    igniffi_Arena* arena,\n")
		fmt.Fprintf(&b, "    igniffi_Status* status);\n\n")

		// Encode function
		fmt.Fprintf(&b, "// Encode %s to wire format\n", msg.Name)
		fmt.Fprintf(&b, "uint8_t* igniffi_encode_%s(\n", msgName)
		fmt.Fprintf(&b, "    const igniffi_%s* msg,\n", msgName)
		fmt.Fprintf(&b, "    size_t* out_len,\n")
		fmt.Fprintf(&b, "    igniffi_Arena* arena,\n")
		fmt.Fprintf(&b, "    igniffi_Status* status);\n\n")
	}

	return b.String()
}

// GenerateCodecImpl generates igniffi_codec.c with encode/decode implementations
func GenerateCodecImpl(s *schema.Schema) string {
	var b strings.Builder

	b.WriteString(`// Code generated by ffire - DO NOT EDIT
// igniffi - Micro ffire C API
// Encode/Decode implementation

#include "igniffi.h"
#include <string.h>

// ============================================================================
// Internal Encoder
// ============================================================================

typedef struct {
    uint8_t* data;
    size_t capacity;
    size_t size;
    igniffi_Arena* arena;
} igniffi_Encoder;

static igniffi_Encoder* encoder_new(igniffi_Arena* arena) {
    igniffi_Encoder* enc = (igniffi_Encoder*)igniffi_arena_alloc(arena, sizeof(igniffi_Encoder));
    if (!enc) return NULL;
    
    enc->capacity = 1024;
    enc->data = (uint8_t*)igniffi_arena_alloc(arena, enc->capacity);
    if (!enc->data) return NULL;
    
    enc->size = 0;
    enc->arena = arena;
    return enc;
}

static bool encoder_ensure_capacity(igniffi_Encoder* enc, size_t needed) {
    if (enc->size + needed <= enc->capacity) return true;
    
    size_t new_capacity = enc->capacity * 2;
    while (new_capacity < enc->size + needed) {
        new_capacity *= 2;
    }
    
    uint8_t* new_data = (uint8_t*)igniffi_arena_alloc(enc->arena, new_capacity);
    if (!new_data) return false;
    
    memcpy(new_data, enc->data, enc->size);
    enc->data = new_data;
    enc->capacity = new_capacity;
    return true;
}

static void encoder_write_byte(igniffi_Encoder* enc, uint8_t b) {
    encoder_ensure_capacity(enc, 1);
    enc->data[enc->size++] = b;
}

static void encoder_write_bool(igniffi_Encoder* enc, bool v) {
    encoder_write_byte(enc, v ? 0x01 : 0x00);
}

static void encoder_write_int8(igniffi_Encoder* enc, int8_t v) {
    encoder_write_byte(enc, (uint8_t)v);
}

static void encoder_write_int16(igniffi_Encoder* enc, int16_t v) {
    encoder_ensure_capacity(enc, 2);
    uint16_t u = (uint16_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
}

static void encoder_write_int32(igniffi_Encoder* enc, int32_t v) {
    encoder_ensure_capacity(enc, 4);
    uint32_t u = (uint32_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
    enc->data[enc->size++] = (uint8_t)(u >> 16);
    enc->data[enc->size++] = (uint8_t)(u >> 24);
}

static void encoder_write_int64(igniffi_Encoder* enc, int64_t v) {
    encoder_ensure_capacity(enc, 8);
    uint64_t u = (uint64_t)v;
    enc->data[enc->size++] = (uint8_t)u;
    enc->data[enc->size++] = (uint8_t)(u >> 8);
    enc->data[enc->size++] = (uint8_t)(u >> 16);
    enc->data[enc->size++] = (uint8_t)(u >> 24);
    enc->data[enc->size++] = (uint8_t)(u >> 32);
    enc->data[enc->size++] = (uint8_t)(u >> 40);
    enc->data[enc->size++] = (uint8_t)(u >> 48);
    enc->data[enc->size++] = (uint8_t)(u >> 56);
}

static void encoder_write_float32(igniffi_Encoder* enc, float v) {
    union { float f; uint32_t u; } converter;
    converter.f = v;
    encoder_write_int32(enc, (int32_t)converter.u);
}

static void encoder_write_float64(igniffi_Encoder* enc, double v) {
    union { double f; uint64_t u; } converter;
    converter.f = v;
    encoder_write_int64(enc, (int64_t)converter.u);
}

static void encoder_write_string(igniffi_Encoder* enc, igniffi_StringView sv) {
    uint16_t len = (uint16_t)sv.size;
    encoder_write_int16(enc, (int16_t)len);
    if (len > 0) {
        encoder_ensure_capacity(enc, len);
        memcpy(enc->data + enc->size, sv.data, len);
        enc->size += len;
    }
}

static void encoder_write_array_length(igniffi_Encoder* enc, uint16_t len) {
    encoder_write_int16(enc, (int16_t)len);
}

// ============================================================================
// Internal Decoder
// ============================================================================

typedef struct {
    const uint8_t* data;
    size_t size;
    size_t pos;
} igniffi_Decoder;

static igniffi_Decoder* decoder_new(const uint8_t* data, size_t size, igniffi_Arena* arena) {
    igniffi_Decoder* dec = (igniffi_Decoder*)igniffi_arena_alloc(arena, sizeof(igniffi_Decoder));
    if (!dec) return NULL;
    dec->data = data;
    dec->size = size;
    dec->pos = 0;
    return dec;
}

static bool decoder_check_remaining(igniffi_Decoder* dec, size_t needed) {
    return dec->pos + needed <= dec->size;
}

static bool decoder_read_bool(igniffi_Decoder* dec, bool* out) {
    if (!decoder_check_remaining(dec, 1)) return false;
    *out = dec->data[dec->pos++] != 0x00;
    return true;
}

static bool decoder_read_int8(igniffi_Decoder* dec, int8_t* out) {
    if (!decoder_check_remaining(dec, 1)) return false;
    *out = (int8_t)dec->data[dec->pos++];
    return true;
}

static bool decoder_read_int16(igniffi_Decoder* dec, int16_t* out) {
    if (!decoder_check_remaining(dec, 2)) return false;
    uint16_t u = (uint16_t)dec->data[dec->pos] |
                 ((uint16_t)dec->data[dec->pos + 1] << 8);
    dec->pos += 2;
    *out = (int16_t)u;
    return true;
}

static bool decoder_read_int32(igniffi_Decoder* dec, int32_t* out) {
    if (!decoder_check_remaining(dec, 4)) return false;
    uint32_t u = (uint32_t)dec->data[dec->pos] |
                 ((uint32_t)dec->data[dec->pos + 1] << 8) |
                 ((uint32_t)dec->data[dec->pos + 2] << 16) |
                 ((uint32_t)dec->data[dec->pos + 3] << 24);
    dec->pos += 4;
    *out = (int32_t)u;
    return true;
}

static bool decoder_read_int64(igniffi_Decoder* dec, int64_t* out) {
    if (!decoder_check_remaining(dec, 8)) return false;
    uint64_t u = (uint64_t)dec->data[dec->pos] |
                 ((uint64_t)dec->data[dec->pos + 1] << 8) |
                 ((uint64_t)dec->data[dec->pos + 2] << 16) |
                 ((uint64_t)dec->data[dec->pos + 3] << 24) |
                 ((uint64_t)dec->data[dec->pos + 4] << 32) |
                 ((uint64_t)dec->data[dec->pos + 5] << 40) |
                 ((uint64_t)dec->data[dec->pos + 6] << 48) |
                 ((uint64_t)dec->data[dec->pos + 7] << 56);
    dec->pos += 8;
    *out = (int64_t)u;
    return true;
}

static bool decoder_read_float32(igniffi_Decoder* dec, float* out) {
    int32_t i;
    if (!decoder_read_int32(dec, &i)) return false;
    union { float f; uint32_t u; } converter;
    converter.u = (uint32_t)i;
    *out = converter.f;
    return true;
}

static bool decoder_read_float64(igniffi_Decoder* dec, double* out) {
    int64_t i;
    if (!decoder_read_int64(dec, &i)) return false;
    union { double f; uint64_t u; } converter;
    converter.u = (uint64_t)i;
    *out = converter.f;
    return true;
}

static bool decoder_read_string(igniffi_Decoder* dec, igniffi_StringView* out, igniffi_Arena* arena) {
    int16_t len_signed;
    if (!decoder_read_int16(dec, &len_signed)) return false;
    uint16_t len = (uint16_t)len_signed;
    
    if (!decoder_check_remaining(dec, len)) return false;
    
    if (len == 0) {
        out->data = NULL;
        out->size = 0;
        return true;
    }
    
    // Copy string data to arena
    char* buf = (char*)igniffi_arena_alloc(arena, len);
    if (!buf) return false;
    memcpy(buf, dec->data + dec->pos, len);
    dec->pos += len;
    
    out->data = buf;
    out->size = len;
    return true;
}

static bool decoder_read_array_length(igniffi_Decoder* dec, uint16_t* out) {
    int16_t len;
    if (!decoder_read_int16(dec, &len)) return false;
    *out = (uint16_t)len;
    return true;
}

`)

	// Generate encode/decode implementations for each root message
	for _, msg := range s.Messages {
		generateMessageCodec(&b, s, &msg)
	}

	return b.String()
}

func generateMessageCodec(b *strings.Builder, s *schema.Schema, msg *schema.MessageType) {
	msgName := toCIdentifier(msg.Name)

	b.WriteString("// ============================================================================\n")
	fmt.Fprintf(b, "// %s Codec\n", msg.Name)
	b.WriteString("// ============================================================================\n\n")

	// Forward declare helper functions
	generateCodecForwardDecls(b, s, msg.TargetType)

	// Generate helper encode/decode functions for nested types
	generateTypeCodecHelpers(b, s, msg.TargetType, "")

	// Generate main decode function
	fmt.Fprintf(b, "igniffi_%s* igniffi_decode_%s(\n", msgName, msgName)
	b.WriteString("    const uint8_t* data,\n")
	b.WriteString("    size_t len,\n")
	b.WriteString("    igniffi_Arena* arena,\n")
	b.WriteString("    igniffi_Status* status) {\n")
	b.WriteString("    \n")
	b.WriteString("    if (!data || len == 0 || !arena || !status) {\n")
	b.WriteString("        if (status) *status = igniffi_error(\"Invalid arguments\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")
	b.WriteString("    igniffi_Decoder* dec = decoder_new(data, len, arena);\n")
	b.WriteString("    if (!dec) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to create decoder\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	fmt.Fprintf(b, "    igniffi_%s* msg = (igniffi_%s*)igniffi_arena_alloc(arena, sizeof(igniffi_%s));\n",
		msgName, msgName, msgName)
	b.WriteString("    if (!msg) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to allocate message\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	// Decode based on target type
	if _, ok := msg.TargetType.(*schema.ArrayType); ok {
		// Array root type
		b.WriteString("    if (!decode_array_root(dec, msg, arena)) {\n")
		b.WriteString("        *status = igniffi_error(\"Failed to decode array\");\n")
		b.WriteString("        return NULL;\n")
		b.WriteString("    }\n\n")
	} else {
		// Struct root type
		fmt.Fprintf(b, "    if (!decode_%s(dec, msg, arena)) {\n", msgName)
		b.WriteString("        *status = igniffi_error(\"Failed to decode message\");\n")
		b.WriteString("        return NULL;\n")
		b.WriteString("    }\n\n")
	}

	b.WriteString("    *status = igniffi_ok();\n")
	b.WriteString("    return msg;\n")
	b.WriteString("}\n\n")

	// Generate main encode function
	fmt.Fprintf(b, "uint8_t* igniffi_encode_%s(\n", msgName)
	fmt.Fprintf(b, "    const igniffi_%s* msg,\n", msgName)
	b.WriteString("    size_t* out_len,\n")
	b.WriteString("    igniffi_Arena* arena,\n")
	b.WriteString("    igniffi_Status* status) {\n")
	b.WriteString("    \n")
	b.WriteString("    if (!msg || !out_len || !arena || !status) {\n")
	b.WriteString("        if (status) *status = igniffi_error(\"Invalid arguments\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")
	b.WriteString("    igniffi_Encoder* enc = encoder_new(arena);\n")
	b.WriteString("    if (!enc) {\n")
	b.WriteString("        *status = igniffi_error(\"Failed to create encoder\");\n")
	b.WriteString("        return NULL;\n")
	b.WriteString("    }\n\n")

	// Encode based on target type
	if _, ok := msg.TargetType.(*schema.ArrayType); ok {
		b.WriteString("    encode_array_root(enc, msg);\n\n")
	} else {
		fmt.Fprintf(b, "    encode_%s(enc, msg);\n\n", msgName)
	}

	b.WriteString("    *out_len = enc->size;\n")
	b.WriteString("    *status = igniffi_ok();\n")
	b.WriteString("    return enc->data;\n")
	b.WriteString("}\n\n")
}

func generateCodecForwardDecls(b *strings.Builder, s *schema.Schema, typ schema.Type) {
	// Generate forward declarations for all helper functions
	switch t := typ.(type) {
	case *schema.StructType:
		structName := toCIdentifier(t.Name)
		fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena);\n",
			structName, structName)
		fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg);\n\n",
			structName, structName)
	case *schema.ArrayType:
		b.WriteString("static bool decode_array_root(igniffi_Decoder* dec, void* out, igniffi_Arena* arena);\n")
		b.WriteString("static void encode_array_root(igniffi_Encoder* enc, const void* msg);\n\n")
	}
}

func generateTypeCodecHelpers(b *strings.Builder, s *schema.Schema, typ schema.Type, indent string) {
	switch t := typ.(type) {
	case *schema.StructType:
		generateStructCodecHelper(b, s, t)
	case *schema.ArrayType:
		generateArrayRootCodecHelper(b, s, t)
	}
}

func generateStructCodecHelper(b *strings.Builder, s *schema.Schema, structType *schema.StructType) {
	structName := toCIdentifier(structType.Name)

	// Decode helper
	fmt.Fprintf(b, "static bool decode_%s(igniffi_Decoder* dec, igniffi_%s* out, igniffi_Arena* arena) {\n",
		structName, structName)

	for _, field := range structType.Fields {
		fieldName := toCIdentifier(field.Name)
		generateFieldDecode(b, &field, fieldName, "out->"+fieldName)
	}

	b.WriteString("    return true;\n")
	b.WriteString("}\n\n")

	// Encode helper
	fmt.Fprintf(b, "static void encode_%s(igniffi_Encoder* enc, const igniffi_%s* msg) {\n",
		structName, structName)

	for _, field := range structType.Fields {
		fieldName := toCIdentifier(field.Name)
		generateFieldEncode(b, &field, fieldName, "msg->"+fieldName)
	}

	b.WriteString("}\n\n")
}

func generateArrayRootCodecHelper(b *strings.Builder, s *schema.Schema, arrayType *schema.ArrayType) {
	b.WriteString("static bool decode_array_root(igniffi_Decoder* dec, void* out, igniffi_Arena* arena) {\n")
	b.WriteString("    // TODO: Implement array root decode\n")
	b.WriteString("    return false;\n")
	b.WriteString("}\n\n")

	b.WriteString("static void encode_array_root(igniffi_Encoder* enc, const void* msg) {\n")
	b.WriteString("    // TODO: Implement array root encode\n")
	b.WriteString("}\n\n")
}

func generateFieldDecode(b *strings.Builder, field *schema.Field, fieldName, resultVar string) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "    if (!decoder_read_bool(dec, &%s)) return false;\n", resultVar)
		case "int8":
			fmt.Fprintf(b, "    if (!decoder_read_int8(dec, &%s)) return false;\n", resultVar)
		case "int16":
			fmt.Fprintf(b, "    if (!decoder_read_int16(dec, &%s)) return false;\n", resultVar)
		case "int32":
			fmt.Fprintf(b, "    if (!decoder_read_int32(dec, &%s)) return false;\n", resultVar)
		case "int64":
			fmt.Fprintf(b, "    if (!decoder_read_int64(dec, &%s)) return false;\n", resultVar)
		case "float32":
			fmt.Fprintf(b, "    if (!decoder_read_float32(dec, &%s)) return false;\n", resultVar)
		case "float64":
			fmt.Fprintf(b, "    if (!decoder_read_float64(dec, &%s)) return false;\n", resultVar)
		case "string":
			fmt.Fprintf(b, "    if (!decoder_read_string(dec, &%s, arena)) return false;\n", resultVar)
		}
	case *schema.ArrayType:
		// Array field - read length then elements
		fmt.Fprintf(b, "    if (!decoder_read_array_length(dec, &out->%s_len)) return false;\n", fieldName)
		fmt.Fprintf(b, "    // TODO: Decode array elements\n")
	case *schema.StructType:
		// Nested struct
		fmt.Fprintf(b, "    // TODO: Decode nested struct %s\n", typ.Name)
	}
}

func generateFieldEncode(b *strings.Builder, field *schema.Field, fieldName, valueVar string) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		switch typ.Name {
		case "bool":
			fmt.Fprintf(b, "    encoder_write_bool(enc, %s);\n", valueVar)
		case "int8":
			fmt.Fprintf(b, "    encoder_write_int8(enc, %s);\n", valueVar)
		case "int16":
			fmt.Fprintf(b, "    encoder_write_int16(enc, %s);\n", valueVar)
		case "int32":
			fmt.Fprintf(b, "    encoder_write_int32(enc, %s);\n", valueVar)
		case "int64":
			fmt.Fprintf(b, "    encoder_write_int64(enc, %s);\n", valueVar)
		case "float32":
			fmt.Fprintf(b, "    encoder_write_float32(enc, %s);\n", valueVar)
		case "float64":
			fmt.Fprintf(b, "    encoder_write_float64(enc, %s);\n", valueVar)
		case "string":
			fmt.Fprintf(b, "    encoder_write_string(enc, %s);\n", valueVar)
		}
	case *schema.ArrayType:
		// Array field
		fmt.Fprintf(b, "    encoder_write_array_length(enc, msg->%s_len);\n", fieldName)
		fmt.Fprintf(b, "    // TODO: Encode array elements\n")
	case *schema.StructType:
		// Nested struct
		fmt.Fprintf(b, "    // TODO: Encode nested struct %s\n", typ.Name)
	}
}
