package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// GeneratePythonPybind11Package generates a Python package using pybind11 for native C++ bindings
func GeneratePythonPybind11Package(config *PackageConfig) error {
	return orchestrateTierBPackage(
		config,
		PythonLayout,
		generatePybind11WrapperOrchestrated,
		generatePybind11MetadataOrchestrated,
		printPybind11Instructions,
	)
}

func generatePybind11WrapperOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Create src directory for C++ source files
	srcDir := filepath.Join(paths.Root, "src")
	if err := os.MkdirAll(srcDir, 0755); err != nil {
		return fmt.Errorf("failed to create src directory: %w", err)
	}

	// Generate C++ code (same as C++ generator)
	cppCode, err := GenerateCpp(config.Schema)
	if err != nil {
		return fmt.Errorf("failed to generate C++ code: %w", err)
	}

	// Write generated.hpp
	generatedHpp := filepath.Join(srcDir, "generated.hpp")
	if err := os.WriteFile(generatedHpp, cppCode, 0644); err != nil {
		return fmt.Errorf("failed to write generated.hpp: %w", err)
	}

	// Generate pybind11 bindings
	bindingsCode, err := generatePybind11Bindings(config)
	if err != nil {
		return err
	} // Write python_bindings.cpp
	bindingsCpp := filepath.Join(srcDir, "python_bindings.cpp")
	if err := os.WriteFile(bindingsCpp, bindingsCode, 0644); err != nil {
		return fmt.Errorf("failed to write python_bindings.cpp: %w", err)
	}

	// Generate Python __init__.py
	if err := generatePybind11Init(config, paths.Root); err != nil {
		return err
	}

	fmt.Printf("✓ Generated pybind11 bindings in %s\n", srcDir)
	return nil
}

func generatePybind11MetadataOrchestrated(config *PackageConfig, paths *PackagePaths) error {
	// Generate setup.py
	if err := generatePybind11Setup(config, paths.Root); err != nil {
		return err
	}

	// Generate pyproject.toml
	if err := generatePybind11Pyproject(config, paths.Root); err != nil {
		return err
	}

	// Generate README
	if err := generatePybind11Readme(config, paths.Root); err != nil {
		return err
	}

	return nil
}

func printPybind11Instructions(config *PackageConfig, paths *PackagePaths) {
	fmt.Printf("\n✅ Python (pybind11) package ready at: %s\n\n", paths.Root)
	fmt.Println("Build and install:")
	fmt.Printf("  cd %s\n", paths.Root)
	fmt.Println("  pip install .")
	fmt.Println()
	fmt.Println("Or build in development mode:")
	fmt.Println("  pip install -e .")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  import %s\n\n", config.Namespace)
	for _, msg := range config.Schema.Messages {
		fmt.Printf("  # %s\n", msg.Name)
		fmt.Printf("  obj = %s.%s()\n", config.Namespace, msg.Name)
		fmt.Printf("  binary = obj.encode()\n")
		fmt.Printf("  obj2 = %s.%s.decode(binary)\n\n", config.Namespace, msg.Name)
	}
}

// generatePybind11Bindings generates the pybind11 wrapper code
func generatePybind11Bindings(config *PackageConfig) ([]byte, error) {
	s := config.Schema
	buf := &bytes.Buffer{}

	// Header
	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")
	buf.WriteString("#include <pybind11/pybind11.h>\n")
	buf.WriteString("#include <pybind11/stl.h>\n")
	buf.WriteString("#include \"generated.hpp\"\n\n")
	buf.WriteString("namespace py = pybind11;\n\n")

	// Module definition (use _native suffix to avoid circular import with package name)
	fmt.Fprintf(buf, "PYBIND11_MODULE(%s_native, m) {\n", config.Namespace)
	fmt.Fprintf(buf, "    m.doc() = \"FFire bindings for %s schema\";\n\n", config.Namespace)

	// Generate bindings for root message struct types (with Message suffix)
	for _, msg := range s.Messages {
		if structType, ok := msg.TargetType.(*schema.StructType); ok {
			// Create a modified struct type with Message suffix for binding
			msgStructType := *structType
			msgStructType.Name = structType.Name + "Message"
			if err := generatePybind11StructBinding(buf, s, &msgStructType); err != nil {
				return nil, err
			}
		}
	}

	// Generate bindings for helper/embedded struct types (no Message suffix)
	for _, typ := range s.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			// Skip if this is a root message type (already generated above)
			isRootType := false
			for _, msg := range s.Messages {
				if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == structType.Name {
					isRootType = true
					break
				}
			}
			if !isRootType {
				if err := generatePybind11StructBinding(buf, s, structType); err != nil {
					return nil, err
				}
			}
		}
	}

	// Generate bindings for message types (encode/decode functions)
	for _, msg := range s.Messages {
		if err := generatePybind11MessageBinding(buf, s, &msg); err != nil {
			return nil, err
		}
	}

	buf.WriteString("}\n")
	return buf.Bytes(), nil
}

func generatePybind11StructBinding(buf *bytes.Buffer, s *schema.Schema, structType *schema.StructType) error {
	className := structType.Name

	fmt.Fprintf(buf, "    py::class_<%s::%s>(m, \"%s\")\n", s.Package, className, className)
	fmt.Fprintf(buf, "        .def(py::init<>())\n")

	// Add field bindings
	for _, field := range structType.Fields {
		fmt.Fprintf(buf, "        .def_readwrite(\"%s\", &%s::%s::%s)\n",
			field.Name, s.Package, className, field.Name)
	}

	// Add __repr__
	fmt.Fprintf(buf, "        .def(\"__repr__\", [](const %s::%s& self) {\n",
		s.Package, className)
	fmt.Fprintf(buf, "            return \"<%s>\";\n", className)
	fmt.Fprintf(buf, "        });\n\n")

	return nil
}

func generatePybind11MessageBinding(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType) error {
	typeName := rootTypeName(msg.TargetType)
	encodeFunc := fmt.Sprintf("encode_%s_message", strings.ToLower(typeName))
	decodeFunc := fmt.Sprintf("decode_%s_message", strings.ToLower(typeName))

	// Determine the C++ type (root message types have Message suffix)
	isStructMessage := false
	if _, ok := msg.TargetType.(*schema.StructType); ok {
		isStructMessage = true
	}
	cppType := getCppTypeString(s.Package, msg.TargetType, isStructMessage)

	// Add static decode method
	fmt.Fprintf(buf, "    m.def(\"%s_decode\", [](py::bytes data) {\n", strings.ToLower(msg.Name))
	buf.WriteString("        std::string_view sv(data);\n")
	fmt.Fprintf(buf, "        return %s::%s(\n", s.Package, decodeFunc)
	buf.WriteString("            reinterpret_cast<const uint8_t*>(sv.data()),\n")
	buf.WriteString("            sv.size()\n")
	buf.WriteString("        );\n")
	fmt.Fprintf(buf, "    }, \"Decode %s from binary wire format\");\n\n", msg.Name)

	// Add encode function
	fmt.Fprintf(buf, "    m.def(\"%s_encode\", [](%s obj) {\n",
		strings.ToLower(msg.Name), cppType)
	fmt.Fprintf(buf, "        auto bytes = %s::%s(obj);\n", s.Package, encodeFunc)
	buf.WriteString("        return py::bytes(\n")
	buf.WriteString("            reinterpret_cast<const char*>(bytes.data()),\n")
	buf.WriteString("            bytes.size()\n")
	buf.WriteString("        );\n")
	fmt.Fprintf(buf, "    }, \"Encode %s to binary wire format\");\n\n", msg.Name)

	return nil
}

func getCppTypeString(packageName string, typ schema.Type, isRootMessage bool) string {
	switch t := typ.(type) {
	case *schema.StructType:
		// Root message types have Message suffix in C++
		structName := t.Name
		if isRootMessage {
			structName += "Message"
		}
		return fmt.Sprintf("const %s::%s&", packageName, structName)
	case *schema.ArrayType:
		elemType := getCppTypeString(packageName, t.ElementType, false)
		elemType = strings.TrimPrefix(elemType, "const ")
		elemType = strings.TrimSuffix(elemType, "&")
		return fmt.Sprintf("const std::vector<%s>&", strings.TrimSpace(elemType))
	case *schema.PrimitiveType:
		return getCppPrimitiveType(t.Name)
	default:
		return "void"
	}
}

func getCppPrimitiveType(name string) string {
	switch name {
	case "bool":
		return "bool"
	case "int8":
		return "int8_t"
	case "int16":
		return "int16_t"
	case "int32":
		return "int32_t"
	case "int64":
		return "int64_t"
	case "uint8":
		return "uint8_t"
	case "uint16":
		return "uint16_t"
	case "uint32":
		return "uint32_t"
	case "uint64":
		return "uint64_t"
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "string":
		return "const std::string&"
	default:
		return "void"
	}
}

func generatePybind11Init(config *PackageConfig, rootDir string) error {
	packageDir := filepath.Join(rootDir, config.Namespace)
	if err := os.MkdirAll(packageDir, 0755); err != nil {
		return fmt.Errorf("failed to create package directory: %w", err)
	}

	buf := &bytes.Buffer{}
	buf.WriteString("# Code generated by ffire. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "\"\"\"\nFFire %s bindings using pybind11.\n", config.Schema.Package)
	buf.WriteString("\nThis module provides native Python bindings to the FFire binary serialization library.\n")
	buf.WriteString("All types are native Python objects with direct field access.\n")
	buf.WriteString("\"\"\"\n\n")

	// Import the compiled extension module (named with _native suffix to avoid circular import)
	fmt.Fprintf(buf, "from . import %s_native as _native\n\n", config.Namespace)

	// Re-export all struct types for direct access
	for _, typ := range config.Schema.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			fmt.Fprintf(buf, "%s = _native.%s\n", structType.Name, structType.Name)
		}
	}
	buf.WriteString("\n")

	// Re-export encode/decode functions for message types
	for _, msg := range config.Schema.Messages {
		funcBaseName := strings.ToLower(msg.Name)
		fmt.Fprintf(buf, "%s_decode = _native.%s_decode\n", funcBaseName, funcBaseName)
		fmt.Fprintf(buf, "%s_encode = _native.%s_encode\n", funcBaseName, funcBaseName)
	}
	buf.WriteString("\n")

	// Export all types and functions
	buf.WriteString("__all__ = [")
	first := true
	// Export struct types
	for _, typ := range config.Schema.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			if !first {
				buf.WriteString(", ")
			}
			fmt.Fprintf(buf, "\"%s\"", structType.Name)
			first = false
		}
	}
	// Export encode/decode functions for message types
	for _, msg := range config.Schema.Messages {
		funcBaseName := strings.ToLower(msg.Name)
		if !first {
			buf.WriteString(", ")
		}
		fmt.Fprintf(buf, "\"%s_decode\", \"%s_encode\"", funcBaseName, funcBaseName)
		first = false
	}
	buf.WriteString("]\n")

	initPath := filepath.Join(packageDir, "__init__.py")
	return os.WriteFile(initPath, buf.Bytes(), 0644)
}

func generatePybind11Setup(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("# Code generated by ffire. DO NOT EDIT.\n\n")
	buf.WriteString("from setuptools import setup\n")
	buf.WriteString("from pybind11.setup_helpers import Pybind11Extension, build_ext\n\n")

	buf.WriteString("ext_modules = [\n")
	fmt.Fprintf(buf, "    Pybind11Extension(\n")
	fmt.Fprintf(buf, "        \"%s.%s_native\",\n", config.Namespace, config.Namespace)
	buf.WriteString("        [\"src/python_bindings.cpp\"],\n")
	buf.WriteString("        include_dirs=[\"src\"],\n")
	buf.WriteString("        cxx_std=17,\n")
	buf.WriteString("        extra_compile_args=[\"-O3\"],\n")
	buf.WriteString("    ),\n")
	buf.WriteString("]\n\n")

	buf.WriteString("setup(\n")
	fmt.Fprintf(buf, "    name=\"ffire-%s\",\n", config.Namespace)
	buf.WriteString("    version=\"0.1.0\",\n")
	fmt.Fprintf(buf, "    description=\"FFire bindings for %s schema\",\n", config.Schema.Package)
	buf.WriteString("    ext_modules=ext_modules,\n")
	buf.WriteString("    cmdclass={\"build_ext\": build_ext},\n")
	fmt.Fprintf(buf, "    packages=[\"%s\"],\n", config.Namespace)
	buf.WriteString("    install_requires=[\"pybind11>=2.10.0\"],\n")
	buf.WriteString("    python_requires=\">=3.7\",\n")
	buf.WriteString(")\n")

	setupPath := filepath.Join(rootDir, "setup.py")
	return os.WriteFile(setupPath, buf.Bytes(), 0644)
}

func generatePybind11Pyproject(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	buf.WriteString("# Code generated by ffire. DO NOT EDIT.\n\n")
	buf.WriteString("[build-system]\n")
	buf.WriteString("requires = [\"setuptools>=42\", \"wheel\", \"pybind11>=2.10.0\"]\n")
	buf.WriteString("build-backend = \"setuptools.build_meta\"\n\n")

	buf.WriteString("[project]\n")
	fmt.Fprintf(buf, "name = \"ffire-%s\"\n", config.Namespace)
	buf.WriteString("version = \"0.1.0\"\n")
	fmt.Fprintf(buf, "description = \"FFire bindings for %s schema\"\n", config.Schema.Package)
	buf.WriteString("requires-python = \">=3.7\"\n")
	buf.WriteString("dependencies = [\"pybind11>=2.10.0\"]\n")

	pyprojectPath := filepath.Join(rootDir, "pyproject.toml")
	return os.WriteFile(pyprojectPath, buf.Bytes(), 0644)
}

func generatePybind11Readme(config *PackageConfig, rootDir string) error {
	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, "# FFire Python Bindings for %s\n\n", config.Schema.Package)
	buf.WriteString("This package provides native Python bindings using pybind11 for high-performance binary serialization.\n\n")

	buf.WriteString("## Installation\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("pip install .\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Usage\n\n")
	buf.WriteString("```python\n")
	fmt.Fprintf(buf, "import %s\n\n", config.Namespace)

	if len(config.Schema.Messages) > 0 {
		msg := config.Schema.Messages[0]
		if structType, ok := msg.TargetType.(*schema.StructType); ok {
			fmt.Fprintf(buf, "# Create object with direct field access\n")
			fmt.Fprintf(buf, "obj = %s.%s()\n", config.Namespace, structType.Name)
			if len(structType.Fields) > 0 {
				field := structType.Fields[0]
				fmt.Fprintf(buf, "obj.%s = ...  # Direct field access!\n\n", field.Name)
			}
			fmt.Fprintf(buf, "# Encode to binary\n")
			fmt.Fprintf(buf, "binary = %s.%s.encode(obj)\n\n", config.Namespace, msg.Name)
			fmt.Fprintf(buf, "# Decode from binary\n")
			fmt.Fprintf(buf, "obj2 = %s.%s.decode(binary)\n", config.Namespace, msg.Name)
		}
	}

	buf.WriteString("```\n\n")

	buf.WriteString("## Performance\n\n")
	buf.WriteString("This implementation uses pybind11 for native C++ performance:\n")
	buf.WriteString("- Direct field access (no getter/setter overhead)\n")
	buf.WriteString("- Automatic type conversion between C++ and Python\n")
	buf.WriteString("- 10-100x faster than ctypes-based implementations\n")

	readmePath := filepath.Join(rootDir, "README.md")
	return os.WriteFile(readmePath, buf.Bytes(), 0644)
}
