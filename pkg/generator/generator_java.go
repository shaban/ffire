package generator

import (
	"bytes"
	"fmt"
	"sort"

	"github.com/shaban/ffire/pkg/schema"
)

// GenerateJava generates native Java code with ByteBuffer encoding/decoding
func GenerateJava(s *schema.Schema) ([]byte, error) {
	gen := &javaGenerator{
		schema:     s,
		buf:        &bytes.Buffer{},
		seenTypes:  make(map[string]bool),
		needsTypes: make(map[string]bool),
	}
	return gen.generate()
}

type javaGenerator struct {
	schema     *schema.Schema
	buf        *bytes.Buffer
	seenTypes  map[string]bool
	needsTypes map[string]bool
}

func (g *javaGenerator) generate() ([]byte, error) {
	fmt.Fprintf(g.buf, "// Code generated by ffire. DO NOT EDIT.\n\n")
	fmt.Fprintf(g.buf, "package %s;\n\n", g.schema.Package)

	g.buf.WriteString("import java.nio.ByteBuffer;\n")
	g.buf.WriteString("import java.nio.ByteOrder;\n")
	g.buf.WriteString("import java.nio.charset.StandardCharsets;\n")
	g.buf.WriteString("import java.util.ArrayList;\n")
	g.buf.WriteString("import java.util.List;\n\n")

	for _, msg := range g.schema.Messages {
		g.collectNeededTypes(msg.TargetType)
	}

	if err := g.generateHelperClasses(); err != nil {
		return nil, err
	}

	for _, msg := range g.schema.Messages {
		if err := g.generateMessageClass(&msg); err != nil {
			return nil, err
		}
	}

	return g.buf.Bytes(), nil
}

func (g *javaGenerator) collectNeededTypes(t schema.Type) {
	switch typ := t.(type) {
	case *schema.StructType:
		if !g.seenTypes[typ.Name] {
			g.seenTypes[typ.Name] = true
			g.needsTypes[typ.Name] = true
			for _, field := range typ.Fields {
				g.collectNeededTypes(field.Type)
			}
		}
	case *schema.ArrayType:
		g.collectNeededTypes(typ.ElementType)
	}
}

func (g *javaGenerator) generateHelperClasses() error {
	sorted, err := g.topologicalSort()
	if err != nil {
		return err
	}

	for _, name := range sorted {
		if err := g.generateStructClass(name, false); err != nil {
			return err
		}
	}

	return nil
}

func (g *javaGenerator) topologicalSort() ([]string, error) {
	deps := make(map[string][]string)
	for name := range g.needsTypes {
		structType := g.findStructType(name)
		if structType != nil {
			for _, field := range structType.Fields {
				if st, ok := field.Type.(*schema.StructType); ok {
					deps[name] = append(deps[name], st.Name)
				}
				if arr, ok := field.Type.(*schema.ArrayType); ok {
					if st, ok := arr.ElementType.(*schema.StructType); ok {
						deps[name] = append(deps[name], st.Name)
					}
				}
			}
		}
	}

	inDegree := make(map[string]int)
	for name := range g.needsTypes {
		inDegree[name] = 0
	}
	for _, depList := range deps {
		for _, dep := range depList {
			inDegree[dep]++
		}
	}

	var queue []string
	for name := range g.needsTypes {
		if inDegree[name] == 0 {
			queue = append(queue, name)
		}
	}

	var sorted []string
	for len(queue) > 0 {
		sort.Strings(queue)

		name := queue[0]
		queue = queue[1:]
		sorted = append(sorted, name)

		for dependent, depList := range deps {
			for _, dep := range depList {
				if dep == name {
					inDegree[dependent]--
					if inDegree[dependent] == 0 {
						queue = append(queue, dependent)
					}
				}
			}
		}
	}

	if len(sorted) != len(g.needsTypes) {
		return nil, fmt.Errorf("circular dependency detected in struct types")
	}

	return sorted, nil
}

func (g *javaGenerator) findStructType(name string) *schema.StructType {
	for _, msg := range g.schema.Messages {
		if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == name {
			return st
		}
	}
	return nil
}

func (g *javaGenerator) generateMessageClass(msg *schema.MessageType) error {
	structType, ok := msg.TargetType.(*schema.StructType)
	if !ok {
		return fmt.Errorf("message %s must have a struct type", msg.Name)
	}

	return g.generateStructClassWithName(structType, msg.Name+"Message")
}

func (g *javaGenerator) generateStructClass(typeName string, isMessage bool) error {
	structType := g.findStructType(typeName)
	if structType == nil {
		return fmt.Errorf("struct type %s not found", typeName)
	}

	className := typeName
	if isMessage {
		className = typeName + "Message"
	}

	return g.generateStructClassWithName(structType, className)
}

func (g *javaGenerator) generateStructClassWithName(structType *schema.StructType, className string) error {
	fmt.Fprintf(g.buf, "public class %s {\n", className)

	for _, field := range structType.Fields {
		javaType := g.javaType(field.Type)
		fmt.Fprintf(g.buf, "    public %s %s;\n", javaType, field.Name)
	}
	g.buf.WriteString("\n")

	fmt.Fprintf(g.buf, "    public %s() {}\n\n", className)

	g.buf.WriteString("    public byte[] encode() {\n")
	g.buf.WriteString("        ByteBuffer buf = ByteBuffer.allocate(computeSize());\n")
	g.buf.WriteString("        buf.order(ByteOrder.LITTLE_ENDIAN);\n")
	g.buf.WriteString("        encodeTo(buf);\n")
	g.buf.WriteString("        return buf.array();\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    public static " + className + " decode(byte[] data) {\n")
	g.buf.WriteString("        ByteBuffer buf = ByteBuffer.wrap(data);\n")
	g.buf.WriteString("        buf.order(ByteOrder.LITTLE_ENDIAN);\n")
	fmt.Fprintf(g.buf, "        %s obj = new %s();\n", className, className)
	g.buf.WriteString("        obj.decodeFrom(buf);\n")
	g.buf.WriteString("        return obj;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    private int computeSize() {\n")
	g.buf.WriteString("        int size = 0;\n")
	for _, field := range structType.Fields {
		g.generateSizeComputation(&field)
	}
	g.buf.WriteString("        return size;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    private void encodeTo(ByteBuffer buf) {\n")
	for _, field := range structType.Fields {
		g.generateEncodeField(&field)
	}
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    private void decodeFrom(ByteBuffer buf) {\n")
	for _, field := range structType.Fields {
		g.generateDecodeField(&field)
	}
	g.buf.WriteString("    }\n\n")

	if g.structUsesStrings(structType) {
		g.buf.WriteString("    private static String decodeString(ByteBuffer buf) {\n")
		g.buf.WriteString("        int len = buf.getShort() & 0xFFFF;\n")
		g.buf.WriteString("        byte[] bytes = new byte[len];\n")
		g.buf.WriteString("        buf.get(bytes);\n")
		g.buf.WriteString("        return new String(bytes, StandardCharsets.UTF_8);\n")
		g.buf.WriteString("    }\n")
	}

	g.buf.WriteString("}\n\n")
	return nil
}

func (g *javaGenerator) javaType(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		baseType := g.javaBaseType(typ.Name)
		if typ.Optional {
			return g.boxedType(baseType)
		}
		return baseType
	case *schema.ArrayType:
		elemType := g.javaType(typ.ElementType)
		if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && !prim.Optional {
			elemType = g.boxedType(g.javaBaseType(prim.Name))
		}
		return "List<" + elemType + ">"
	case *schema.StructType:
		return typ.Name
	}
	return "Object"
}

func (g *javaGenerator) javaBaseType(kind string) string {
	switch kind {
	case "bool":
		return "boolean"
	case "i8", "u8":
		return "byte"
	case "i16", "u16":
		return "short"
	case "i32", "u32":
		return "int"
	case "i64", "u64":
		return "long"
	case "f32":
		return "float"
	case "f64":
		return "double"
	case "string":
		return "String"
	default:
		return "Object"
	}
}

func (g *javaGenerator) boxedType(primitiveType string) string {
	switch primitiveType {
	case "boolean":
		return "Boolean"
	case "byte":
		return "Byte"
	case "short":
		return "Short"
	case "int":
		return "Integer"
	case "long":
		return "Long"
	case "float":
		return "Float"
	case "double":
		return "Double"
	default:
		return primitiveType
	}
}

func (g *javaGenerator) generateSizeComputation(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("        size += 1;\n")
			fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)
			g.buf.WriteString("            size += " + g.sizeOf(typ.Name, field.Name) + ";\n")
			g.buf.WriteString("        }\n")
		} else {
			g.buf.WriteString("        size += " + g.sizeOf(typ.Name, field.Name) + ";\n")
		}
	case *schema.ArrayType:
		g.buf.WriteString("        size += 2;\n")
		fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)
		if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && !prim.Optional && prim.Name != "string" {
			fmt.Fprintf(g.buf, "            size += %s.size() * %s;\n", field.Name, g.sizeOf(prim.Name, ""))
		} else {
			fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", field.Name)
			if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && prim.Optional {
				g.buf.WriteString("                size += 1;\n")
				g.buf.WriteString("                if (elem != null) {\n")
				g.buf.WriteString("                    size += " + g.sizeOf(prim.Name, "elem") + ";\n")
				g.buf.WriteString("                }\n")
			} else if _, ok := typ.ElementType.(*schema.StructType); ok {
				g.buf.WriteString("                size += elem.computeSize();\n")
			} else if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok {
				g.buf.WriteString("                size += " + g.sizeOf(prim.Name, "elem") + ";\n")
			}
			g.buf.WriteString("            }\n")
		}
		g.buf.WriteString("        }\n")
	case *schema.StructType:
		fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)
		fmt.Fprintf(g.buf, "            size += %s.computeSize();\n", field.Name)
		g.buf.WriteString("        }\n")
	}
}

func (g *javaGenerator) sizeOf(kind string, varName string) string {
	switch kind {
	case "bool", "i8", "u8":
		return "1"
	case "i16", "u16":
		return "2"
	case "i32", "u32", "f32":
		return "4"
	case "i64", "u64", "f64":
		return "8"
	case "string":
		if varName != "" {
			return varName + ".getBytes(StandardCharsets.UTF_8).length + 2"
		}
		return "elem.getBytes(StandardCharsets.UTF_8).length + 2"
	default:
		return "0"
	}
}

func (g *javaGenerator) generateEncodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)
			g.buf.WriteString("            buf.put((byte) 1);\n")
			g.generatePrimitiveEncode(field.Name, typ.Name)
			g.buf.WriteString("        } else {\n")
			g.buf.WriteString("            buf.put((byte) 0);\n")
			g.buf.WriteString("        }\n")
		} else {
			g.generatePrimitiveEncode(field.Name, typ.Name)
		}
	case *schema.ArrayType:
		fmt.Fprintf(g.buf, "        buf.putShort((short) (%s != null ? %s.size() : 0));\n", field.Name, field.Name)
		fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)

		if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && !prim.Optional {
			g.generateBulkArrayEncode(field.Name, prim.Name)
		} else {
			fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", field.Name)
			if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && prim.Optional {
				g.buf.WriteString("                if (elem != null) {\n")
				g.buf.WriteString("                    buf.put((byte) 1);\n")
				g.generatePrimitiveEncode("elem", prim.Name)
				g.buf.WriteString("                } else {\n")
				g.buf.WriteString("                    buf.put((byte) 0);\n")
				g.buf.WriteString("                }\n")
			} else if _, ok := typ.ElementType.(*schema.StructType); ok {
				g.buf.WriteString("                elem.encodeTo(buf);\n")
			} else if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok {
				g.generatePrimitiveEncode("elem", prim.Name)
			}
			g.buf.WriteString("            }\n")
		}
		g.buf.WriteString("        }\n")
	case *schema.StructType:
		fmt.Fprintf(g.buf, "        if (%s != null) {\n", field.Name)
		fmt.Fprintf(g.buf, "            %s.encodeTo(buf);\n", field.Name)
		g.buf.WriteString("        }\n")
	}
}

func (g *javaGenerator) generateBulkArrayEncode(fieldName, kind string) {
	switch kind {
	case "bool":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.put((byte) (elem ? 1 : 0));\n")
		g.buf.WriteString("            }\n")
	case "i8", "u8":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.put(elem);\n")
		g.buf.WriteString("            }\n")
	case "i16", "u16":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.putShort(elem);\n")
		g.buf.WriteString("            }\n")
	case "i32", "u32":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.putInt(elem);\n")
		g.buf.WriteString("            }\n")
	case "i64", "u64":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.putLong(elem);\n")
		g.buf.WriteString("            }\n")
	case "f32":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.putFloat(elem);\n")
		g.buf.WriteString("            }\n")
	case "f64":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                buf.putDouble(elem);\n")
		g.buf.WriteString("            }\n")
	case "string":
		fmt.Fprintf(g.buf, "            for (var elem : %s) {\n", fieldName)
		g.buf.WriteString("                byte[] bytes = elem.getBytes(StandardCharsets.UTF_8);\n")
		g.buf.WriteString("                buf.putShort((short) bytes.length);\n")
		g.buf.WriteString("                buf.put(bytes);\n")
		g.buf.WriteString("            }\n")
	}
}

func (g *javaGenerator) generatePrimitiveEncode(fieldName, kind string) {
	switch kind {
	case "bool":
		fmt.Fprintf(g.buf, "            buf.put((byte) (%s ? 1 : 0));\n", fieldName)
	case "i8", "u8":
		fmt.Fprintf(g.buf, "            buf.put(%s);\n", fieldName)
	case "i16", "u16":
		fmt.Fprintf(g.buf, "            buf.putShort(%s);\n", fieldName)
	case "i32", "u32":
		fmt.Fprintf(g.buf, "            buf.putInt(%s);\n", fieldName)
	case "i64", "u64":
		fmt.Fprintf(g.buf, "            buf.putLong(%s);\n", fieldName)
	case "f32":
		fmt.Fprintf(g.buf, "            buf.putFloat(%s);\n", fieldName)
	case "f64":
		fmt.Fprintf(g.buf, "            buf.putDouble(%s);\n", fieldName)
	case "string":
		fmt.Fprintf(g.buf, "            byte[] bytes = %s.getBytes(StandardCharsets.UTF_8);\n", fieldName)
		g.buf.WriteString("            buf.putShort((short) bytes.length);\n")
		g.buf.WriteString("            buf.put(bytes);\n")
	}
}

func (g *javaGenerator) generateDecodeField(field *schema.Field) {
	switch typ := field.Type.(type) {
	case *schema.PrimitiveType:
		if typ.Optional {
			g.buf.WriteString("        if (buf.get() == 1) {\n")
			fmt.Fprintf(g.buf, "            %s = ", field.Name)
			g.generatePrimitiveDecode(typ.Name)
			g.buf.WriteString(";\n")
			g.buf.WriteString("        }\n")
		} else {
			fmt.Fprintf(g.buf, "        %s = ", field.Name)
			g.generatePrimitiveDecode(typ.Name)
			g.buf.WriteString(";\n")
		}
	case *schema.ArrayType:
		g.buf.WriteString("        int len = buf.getShort() & 0xFFFF;\n")
		fmt.Fprintf(g.buf, "        %s = new ArrayList<>(len);\n", field.Name)
		g.buf.WriteString("        for (int i = 0; i < len; i++) {\n")

		if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok && prim.Optional {
			g.buf.WriteString("            if (buf.get() == 1) {\n")
			fmt.Fprintf(g.buf, "                %s.add(", field.Name)
			g.generatePrimitiveDecode(prim.Name)
			g.buf.WriteString(");\n")
			g.buf.WriteString("            } else {\n")
			fmt.Fprintf(g.buf, "                %s.add(null);\n", field.Name)
			g.buf.WriteString("            }\n")
		} else if st, ok := typ.ElementType.(*schema.StructType); ok {
			fmt.Fprintf(g.buf, "            %s elem = new %s();\n", st.Name, st.Name)
			g.buf.WriteString("            elem.decodeFrom(buf);\n")
			fmt.Fprintf(g.buf, "            %s.add(elem);\n", field.Name)
		} else if prim, ok := typ.ElementType.(*schema.PrimitiveType); ok {
			fmt.Fprintf(g.buf, "            %s.add(", field.Name)
			g.generatePrimitiveDecode(prim.Name)
			g.buf.WriteString(");\n")
		}
		g.buf.WriteString("        }\n")
	case *schema.StructType:
		fmt.Fprintf(g.buf, "        %s = new %s();\n", field.Name, typ.Name)
		fmt.Fprintf(g.buf, "        %s.decodeFrom(buf);\n", field.Name)
	}
}

func (g *javaGenerator) generatePrimitiveDecode(kind string) {
	switch kind {
	case "bool":
		g.buf.WriteString("buf.get() != 0")
	case "i8", "u8":
		g.buf.WriteString("buf.get()")
	case "i16", "u16":
		g.buf.WriteString("buf.getShort()")
	case "i32", "u32":
		g.buf.WriteString("buf.getInt()")
	case "i64", "u64":
		g.buf.WriteString("buf.getLong()")
	case "f32":
		g.buf.WriteString("buf.getFloat()")
	case "f64":
		g.buf.WriteString("buf.getDouble()")
	case "string":
		g.buf.WriteString("decodeString(buf)")
	}
}

func (g *javaGenerator) structUsesStrings(structType *schema.StructType) bool {
	for _, field := range structType.Fields {
		if g.typeUsesStrings(field.Type) {
			return true
		}
	}
	return false
}

func (g *javaGenerator) typeUsesStrings(t schema.Type) bool {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return typ.Name == "string"
	case *schema.ArrayType:
		return g.typeUsesStrings(typ.ElementType)
	case *schema.StructType:
		for _, field := range typ.Fields {
			if g.typeUsesStrings(field.Type) {
				return true
			}
		}
	}
	return false
}
