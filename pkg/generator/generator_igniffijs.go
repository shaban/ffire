package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/shaban/ffire/pkg/generator/igniffi"
	"github.com/shaban/ffire/pkg/schema"
)

// GenerateIgniffiJSPackage generates a JavaScript package using Koffi FFI bindings
// to the igniffi C API. This is the recommended approach for JavaScript:
// - No native compilation needed by end users (npm install just works)
// - Koffi provides type-precise bindings with ~80-150ns overhead
// - Zero-copy buffer access where possible
func GenerateIgniffiJSPackage(config *PackageConfig) error {
	if config.Verbose {
		fmt.Println("Generating igniffi JavaScript package (Koffi FFI)")
	}

	// Directory structure:
	// javascript/
	//   lib/              - Compiled dylib
	//   src/              - igniffi C source (for reference)
	//   include/          - igniffi headers
	//   index.js          - Main entry point with Koffi bindings
	//   package.json      - npm package metadata
	//   README.md         - Usage documentation

	jsDir := filepath.Join(config.OutputDir, "javascript")
	libDir := filepath.Join(jsDir, "lib")
	srcDir := filepath.Join(jsDir, "src")
	includeDir := filepath.Join(jsDir, "include")

	for _, dir := range []string{jsDir, libDir, srcDir, includeDir} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Step 1: Generate igniffi C code
	igniffiDir := jsDir // igniffi.Generate expects root dir, creates include/ and src/
	if err := igniffi.Generate(config.Schema, igniffiDir); err != nil {
		return fmt.Errorf("failed to generate igniffi code: %w", err)
	}

	// Step 2: Compile igniffi to dylib
	if !config.NoCompile {
		if err := compileIgniffiDylib(config, srcDir, includeDir, libDir); err != nil {
			return fmt.Errorf("failed to compile igniffi dylib: %w", err)
		}
	}

	// Step 3: Generate Koffi JavaScript wrapper
	if err := generateKoffiWrapper(config, jsDir); err != nil {
		return fmt.Errorf("failed to generate Koffi wrapper: %w", err)
	}

	// Step 4: Generate package.json
	if err := generateJSPackageJSON(config, jsDir); err != nil {
		return fmt.Errorf("failed to generate package.json: %w", err)
	}

	// Step 5: Generate README
	if err := generateJSReadme(config, jsDir); err != nil {
		return fmt.Errorf("failed to generate README: %w", err)
	}

	printJSInstructions(config, jsDir)

	return nil
}

func compileIgniffiDylib(config *PackageConfig, srcDir, includeDir, libDir string) error {
	// Find all .c files in src/
	srcFiles, err := filepath.Glob(filepath.Join(srcDir, "*.c"))
	if err != nil || len(srcFiles) == 0 {
		return fmt.Errorf("no .c files found in %s", srcDir)
	}

	// Determine output library name and flags based on platform
	var libName string
	var flags []string

	switch runtime.GOOS {
	case "darwin":
		libName = fmt.Sprintf("lib%s.dylib", config.Schema.Package)
		flags = []string{
			"-dynamiclib",
			"-arch", runtime.GOARCH,
			"-O2",
			"-fPIC",
			"-I", includeDir,
			"-o", filepath.Join(libDir, libName),
		}
	case "linux":
		libName = fmt.Sprintf("lib%s.so", config.Schema.Package)
		flags = []string{
			"-shared",
			"-O2",
			"-fPIC",
			"-I", includeDir,
			"-o", filepath.Join(libDir, libName),
		}
	case "windows":
		libName = fmt.Sprintf("%s.dll", config.Schema.Package)
		flags = []string{
			"-shared",
			"-O2",
			"-I", includeDir,
			"-o", filepath.Join(libDir, libName),
		}
	default:
		return fmt.Errorf("unsupported platform: %s", runtime.GOOS)
	}

	// Compile: gcc [flags] src/*.c
	args := append(flags, srcFiles...)
	cmd := exec.Command("gcc", args...)
	// Don't set cmd.Dir - srcFiles already contains full paths from filepath.Glob

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("gcc failed: %w\nOutput: %s", err, string(output))
	}

	fmt.Printf("✓ Compiled %s\n", libName)
	return nil
}

func generateKoffiWrapper(config *PackageConfig, jsDir string) error {
	s := config.Schema
	buf := &bytes.Buffer{}

	// Generated code header
	buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n")
	buf.WriteString("// igniffi JavaScript bindings using Koffi FFI\n\n")

	buf.WriteString("'use strict';\n\n")
	buf.WriteString("const koffi = require('koffi');\n")
	buf.WriteString("const path = require('path');\n")
	buf.WriteString("const os = require('os');\n\n")

	// Library loading
	buf.WriteString("// Load native library\n")
	buf.WriteString("function loadLibrary() {\n")
	buf.WriteString("  let libName;\n")
	buf.WriteString("  switch (os.platform()) {\n")
	fmt.Fprintf(buf, "    case 'darwin': libName = 'lib%s.dylib'; break;\n", s.Package)
	fmt.Fprintf(buf, "    case 'linux': libName = 'lib%s.so'; break;\n", s.Package)
	fmt.Fprintf(buf, "    case 'win32': libName = '%s.dll'; break;\n", s.Package)
	buf.WriteString("    default: throw new Error(`Unsupported platform: ${os.platform()}`);\n")
	buf.WriteString("  }\n")
	buf.WriteString("  return koffi.load(path.join(__dirname, 'lib', libName));\n")
	buf.WriteString("}\n\n")

	buf.WriteString("const lib = loadLibrary();\n\n")

	// Define Koffi types
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Type Definitions\n")
	buf.WriteString("// ============================================================================\n\n")

	// StringView struct
	buf.WriteString("const StringView = koffi.struct('igniffi_StringView', {\n")
	buf.WriteString("  data: 'const char*',\n")
	buf.WriteString("  size: 'size_t'\n")
	buf.WriteString("});\n\n")

	// Status struct
	buf.WriteString("const Status = koffi.struct('igniffi_Status', {\n")
	buf.WriteString("  ok: 'bool',\n")
	buf.WriteString("  message: 'const char*'\n")
	buf.WriteString("});\n\n")

	// Arena pointer (opaque)
	buf.WriteString("const Arena = koffi.pointer('igniffi_Arena', koffi.opaque());\n\n")

	// Generate struct types for schema (in topological order - dependencies first)
	sortedTypes := topSortStructTypes(s.Types)
	for _, structType := range sortedTypes {
		generateKoffiStructType(buf, s, structType)
	}

	// Generate message types
	for _, msg := range s.Messages {
		generateKoffiMessageType(buf, s, &msg)
	}

	// Arena functions
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Arena Management\n")
	buf.WriteString("// ============================================================================\n\n")

	buf.WriteString("const arena_new = lib.func('igniffi_Arena* igniffi_arena_new(void)');\n")
	buf.WriteString("const arena_new_sized = lib.func('igniffi_Arena* igniffi_arena_new_sized(size_t initial_size)');\n")
	buf.WriteString("const arena_free = lib.func('void igniffi_arena_free(igniffi_Arena* arena)');\n\n")

	// Encode/Decode functions
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Encode/Decode Functions\n")
	buf.WriteString("// ============================================================================\n\n")

	for _, msg := range s.Messages {
		msgName := toCIdentifier(msg.Name)
		structName := fmt.Sprintf("igniffi_%s", msgName)

		// Decode function
		fmt.Fprintf(buf, "const decode_%s = lib.func('%s* igniffi_decode_%s(const uint8_t* data, size_t len, igniffi_Arena* arena, igniffi_Status* status)');\n",
			msgName, structName, msgName)

		// Encode function
		fmt.Fprintf(buf, "const encode_%s = lib.func('uint8_t* igniffi_encode_%s(const %s* msg, size_t* out_len, igniffi_Arena* arena, igniffi_Status* status)');\n\n",
			msgName, msgName, structName)
	}

	// Generate high-level API classes
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// High-Level API\n")
	buf.WriteString("// ============================================================================\n\n")

	for _, msg := range s.Messages {
		generateKoffiMessageClass(buf, s, &msg)
	}

	// Exports
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Exports\n")
	buf.WriteString("// ============================================================================\n\n")

	buf.WriteString("module.exports = {\n")
	for i, msg := range s.Messages {
		className := msg.Name + "Message"
		if i < len(s.Messages)-1 {
			fmt.Fprintf(buf, "  %s,\n", className)
		} else {
			fmt.Fprintf(buf, "  %s\n", className)
		}
	}
	buf.WriteString("};\n")

	// Write file
	filePath := filepath.Join(jsDir, "index.js")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write index.js: %w", err)
	}

	fmt.Println("✓ Generated index.js (Koffi bindings)")
	return nil
}

func generateKoffiStructType(buf *bytes.Buffer, s *schema.Schema, structType *schema.StructType) {
	structName := fmt.Sprintf("igniffi_%s", toCIdentifier(structType.Name))
	fmt.Fprintf(buf, "const %s = koffi.struct('%s', {\n", structName, structName)

	for i, field := range structType.Fields {
		koffiType := koffiTypeForField(s, &field)
		comma := ","
		if i == len(structType.Fields)-1 {
			comma = ""
		}
		fmt.Fprintf(buf, "  %s: %s%s\n", field.Name, koffiType, comma)
	}

	buf.WriteString("});\n\n")
}

func generateKoffiMessageType(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType) {
	// For messages that wrap arrays or primitives, we need different handling
	msgName := toCIdentifier(msg.Name)
	structName := fmt.Sprintf("igniffi_%s", msgName)

	switch t := msg.TargetType.(type) {
	case *schema.StructType:
		// Struct messages - the struct is already defined in schema types
		// No need to generate anything extra for Koffi

	case *schema.ArrayType:
		// Array messages need a wrapper struct with items pointer and count
		fmt.Fprintf(buf, "const %s = koffi.struct('%s', {\n", structName, structName)
		elemType := koffiTypeForSchemaType(s, t.ElementType)
		fmt.Fprintf(buf, "  items: koffi.pointer('items', %s),\n", elemType)
		fmt.Fprintf(buf, "  count: 'size_t'\n")
		buf.WriteString("});\n\n")

	case *schema.PrimitiveType:
		// Primitive messages wrap a single value
		fmt.Fprintf(buf, "const %s = koffi.struct('%s', {\n", structName, structName)
		primType := koffiTypeForPrimitive(t)
		fmt.Fprintf(buf, "  value: %s\n", primType)
		buf.WriteString("});\n\n")
	}
}

func generateKoffiMessageClass(buf *bytes.Buffer, s *schema.Schema, msg *schema.MessageType) {
	className := msg.Name + "Message"
	msgName := toCIdentifier(msg.Name)

	fmt.Fprintf(buf, "class %s {\n", className)
	buf.WriteString("  #arena = null;\n")
	buf.WriteString("  #handle = null;\n")
	buf.WriteString("  #disposed = false;\n\n")

	// Constructor (private-ish via factory)
	buf.WriteString("  constructor(handle, arena) {\n")
	buf.WriteString("    this.#handle = handle;\n")
	buf.WriteString("    this.#arena = arena;\n")
	buf.WriteString("  }\n\n")

	// Static decode method
	fmt.Fprintf(buf, "  /**\n")
	fmt.Fprintf(buf, "   * Decode binary data into %s\n", className)
	fmt.Fprintf(buf, "   * @param {Buffer|Uint8Array} data - Binary data to decode\n")
	fmt.Fprintf(buf, "   * @returns {%s}\n", className)
	fmt.Fprintf(buf, "   */\n")
	buf.WriteString("  static decode(data) {\n")
	buf.WriteString("    const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n")
	buf.WriteString("    const arena = arena_new_sized(buffer.length * 2);\n")
	buf.WriteString("    \n")
	buf.WriteString("    const statusPtr = koffi.alloc(Status, 1);\n")
	fmt.Fprintf(buf, "    const handle = decode_%s(buffer, buffer.length, arena, statusPtr);\n", msgName)
	buf.WriteString("    const status = koffi.decode(statusPtr, Status);\n")
	buf.WriteString("    \n")
	buf.WriteString("    if (!status.ok) {\n")
	buf.WriteString("      const errMsg = status.message ? koffi.decode(status.message, 'string') : 'Unknown decode error';\n")
	buf.WriteString("      arena_free(arena);\n")
	buf.WriteString("      throw new Error(`Decode failed: ${errMsg}`);\n")
	buf.WriteString("    }\n")
	buf.WriteString("    \n")
	fmt.Fprintf(buf, "    return new %s(handle, arena);\n", className)
	buf.WriteString("  }\n\n")

	// Encode method
	buf.WriteString("  /**\n")
	buf.WriteString("   * Encode message to binary data\n")
	buf.WriteString("   * @returns {Buffer}\n")
	buf.WriteString("   */\n")
	buf.WriteString("  encode() {\n")
	buf.WriteString("    if (this.#disposed) {\n")
	buf.WriteString("      throw new Error('Message has been disposed');\n")
	buf.WriteString("    }\n")
	buf.WriteString("    \n")
	buf.WriteString("    const outLenPtr = koffi.alloc('size_t', 1);\n")
	buf.WriteString("    const statusPtr = koffi.alloc(Status, 1);\n")
	fmt.Fprintf(buf, "    const dataPtr = encode_%s(this.#handle, outLenPtr, this.#arena, statusPtr);\n", msgName)
	buf.WriteString("    const status = koffi.decode(statusPtr, Status);\n")
	buf.WriteString("    \n")
	buf.WriteString("    if (!status.ok) {\n")
	buf.WriteString("      const errMsg = status.message ? koffi.decode(status.message, 'string') : 'Unknown encode error';\n")
	buf.WriteString("      throw new Error(`Encode failed: ${errMsg}`);\n")
	buf.WriteString("    }\n")
	buf.WriteString("    \n")
	buf.WriteString("    const outLen = koffi.decode(outLenPtr, 'size_t');\n")
	buf.WriteString("    // Copy data to JS Buffer (arena owns the memory)\n")
	buf.WriteString("    const result = Buffer.from(koffi.decode(dataPtr, koffi.array('uint8_t', outLen)));\n")
	buf.WriteString("    return result;\n")
	buf.WriteString("  }\n\n")

	// Dispose method
	buf.WriteString("  /**\n")
	buf.WriteString("   * Free native resources. Always call when done.\n")
	buf.WriteString("   */\n")
	buf.WriteString("  dispose() {\n")
	buf.WriteString("    if (!this.#disposed && this.#arena) {\n")
	buf.WriteString("      arena_free(this.#arena);\n")
	buf.WriteString("      this.#arena = null;\n")
	buf.WriteString("      this.#handle = null;\n")
	buf.WriteString("      this.#disposed = true;\n")
	buf.WriteString("    }\n")
	buf.WriteString("  }\n")

	buf.WriteString("}\n\n")
}

// topSortStructTypes returns struct types sorted in topological order (dependencies first)
// This ensures that when a struct refers to another struct, the dependency is defined first
func topSortStructTypes(types []schema.Type) []*schema.StructType {
	// Build a map of struct types by name
	typeMap := make(map[string]*schema.StructType)
	for _, typ := range types {
		if st, ok := typ.(*schema.StructType); ok {
			typeMap[st.Name] = st
		}
	}

	// Build dependency graph
	deps := make(map[string][]string) // map from type to its dependencies
	for _, st := range typeMap {
		var typeDeps []string
		for _, field := range st.Fields {
			if depSt, ok := field.Type.(*schema.StructType); ok {
				typeDeps = append(typeDeps, depSt.Name)
			}
		}
		deps[st.Name] = typeDeps
	}

	// Topological sort using DFS
	var result []*schema.StructType
	visited := make(map[string]bool)
	inStack := make(map[string]bool)

	var visit func(name string)
	visit = func(name string) {
		if inStack[name] {
			return // Circular dependency - skip
		}
		if visited[name] {
			return
		}

		inStack[name] = true
		for _, dep := range deps[name] {
			if _, exists := typeMap[dep]; exists {
				visit(dep)
			}
		}
		inStack[name] = false
		visited[name] = true
		if st, ok := typeMap[name]; ok {
			result = append(result, st)
		}
	}

	// Visit all types
	for name := range typeMap {
		visit(name)
	}

	return result
}

func koffiTypeForField(s *schema.Schema, field *schema.Field) string {
	return koffiTypeForSchemaType(s, field.Type)
}

func koffiTypeForSchemaType(s *schema.Schema, t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		return koffiTypeForPrimitive(typ)
	case *schema.StructType:
		return fmt.Sprintf("igniffi_%s", toCIdentifier(typ.Name))
	case *schema.ArrayType:
		// Arrays are represented as pointer + length in igniffi
		// This is a simplification; actual struct needs items/count
		return "'void*'"
	default:
		return "'void*'"
	}
}

func koffiTypeForPrimitive(p *schema.PrimitiveType) string {
	switch p.Name {
	case "bool":
		return "'bool'"
	case "int8":
		return "'int8_t'"
	case "int16":
		return "'int16_t'"
	case "int32":
		return "'int32_t'"
	case "int64":
		return "'int64_t'"
	case "uint8":
		return "'uint8_t'"
	case "uint16":
		return "'uint16_t'"
	case "uint32":
		return "'uint32_t'"
	case "uint64":
		return "'uint64_t'"
	case "float32":
		return "'float'"
	case "float64":
		return "'double'"
	case "string":
		return "StringView"
	default:
		return "'void*'"
	}
}

func generateJSPackageJSON(config *PackageConfig, jsDir string) error {
	buf := &bytes.Buffer{}
	packageName := config.Namespace

	buf.WriteString("{\n")
	fmt.Fprintf(buf, "  \"name\": \"%s\",\n", packageName)
	buf.WriteString("  \"version\": \"1.0.0\",\n")
	buf.WriteString("  \"description\": \"ffire serialization bindings via Koffi FFI\",\n")
	buf.WriteString("  \"main\": \"index.js\",\n")
	buf.WriteString("  \"scripts\": {\n")
	buf.WriteString("    \"test\": \"node test.js\",\n")
	buf.WriteString("    \"bench\": \"node bench.js\"\n")
	buf.WriteString("  },\n")
	buf.WriteString("  \"keywords\": [\"ffire\", \"serialization\", \"binary\", \"ffi\"],\n")
	buf.WriteString("  \"license\": \"MIT\",\n")
	buf.WriteString("  \"dependencies\": {\n")
	buf.WriteString("    \"koffi\": \"^2.8.0\"\n")
	buf.WriteString("  },\n")
	buf.WriteString("  \"engines\": {\n")
	buf.WriteString("    \"node\": \">=14.0.0\"\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n")

	filePath := filepath.Join(jsDir, "package.json")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write package.json: %w", err)
	}

	fmt.Println("✓ Generated package.json")
	return nil
}

func generateJSReadme(config *PackageConfig, jsDir string) error {
	buf := &bytes.Buffer{}
	packageName := config.Namespace

	fmt.Fprintf(buf, "# %s - ffire JavaScript Bindings\n\n", packageName)
	buf.WriteString("High-performance binary serialization using ffire format with Koffi FFI.\n\n")

	buf.WriteString("## Installation\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("npm install\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Requirements\n\n")
	buf.WriteString("- Node.js 14.0.0 or higher\n")
	buf.WriteString("- No native compilation needed (Koffi handles FFI at runtime)\n\n")

	buf.WriteString("## Usage\n\n")
	buf.WriteString("```javascript\n")
	fmt.Fprintf(buf, "const { %sMessage } = require('%s');\n", config.Schema.Messages[0].Name, packageName)
	buf.WriteString("const fs = require('fs');\n\n")

	buf.WriteString("// Decode binary data\n")
	buf.WriteString("const data = fs.readFileSync('data.bin');\n")
	fmt.Fprintf(buf, "const msg = %sMessage.decode(data);\n\n", config.Schema.Messages[0].Name)

	buf.WriteString("// Encode back to binary\n")
	buf.WriteString("const encoded = msg.encode();\n")
	buf.WriteString("fs.writeFileSync('output.bin', encoded);\n\n")

	buf.WriteString("// Always dispose when done\n")
	buf.WriteString("msg.dispose();\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## API\n\n")
	for _, msg := range config.Schema.Messages {
		className := msg.Name + "Message"
		fmt.Fprintf(buf, "### %s\n\n", className)
		fmt.Fprintf(buf, "- **`static decode(data: Buffer|Uint8Array): %s`** - Decode binary data\n", className)
		buf.WriteString("- **`encode(): Buffer`** - Encode to binary\n")
		buf.WriteString("- **`dispose(): void`** - Free native resources\n\n")
	}

	buf.WriteString("## Performance\n\n")
	buf.WriteString("Koffi FFI provides ~80-150ns call overhead per FFI invocation.\n")
	buf.WriteString("For large messages, the encode/decode time dominates, making FFI overhead negligible.\n\n")

	buf.WriteString("## License\n\n")
	buf.WriteString("Generated by ffire\n")

	filePath := filepath.Join(jsDir, "README.md")
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	fmt.Println("✓ Generated README.md")
	return nil
}

func printJSInstructions(config *PackageConfig, jsDir string) {
	fmt.Printf("\n✅ JavaScript package ready at: %s\n\n", jsDir)
	fmt.Println("Install dependencies:")
	fmt.Printf("  cd %s\n", jsDir)
	fmt.Println("  npm install")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  const { %sMessage } = require('./');\n", config.Schema.Messages[0].Name)
	fmt.Println("  const msg = Message.decode(buffer);")
	fmt.Println("  const encoded = msg.encode();")
	fmt.Println("  msg.dispose();")
	fmt.Println()
}

// toCIdentifier converts a name to a valid C identifier (lowercase with underscores)
// Must match the igniffi package's toCIdentifier function exactly
func toCIdentifier(name string) string {
	var result strings.Builder
	for i, r := range name {
		if r >= 'A' && r <= 'Z' {
			if i > 0 {
				result.WriteRune('_')
			}
			result.WriteRune(r + 32) // Convert to lowercase
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}
