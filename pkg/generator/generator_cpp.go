package generator

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

func GenerateCpp(s *schema.Schema) ([]byte, error) {
	gen := &cppGenerator{schema: s, buf: &bytes.Buffer{}}
	return gen.generate()
}

type cppGenerator struct {
	schema *schema.Schema
	buf    *bytes.Buffer
	depth  int // Track nesting depth for unique variable names
}

func (g *cppGenerator) generate() ([]byte, error) {
	// Generated code header
	g.buf.WriteString("// Code generated by ffire. DO NOT EDIT.\n\n")

	// Header guard
	guardName := strings.ToUpper(g.schema.Package) + "_H"
	fmt.Fprintf(g.buf, "#ifndef %s\n", guardName)
	fmt.Fprintf(g.buf, "#define %s\n\n", guardName)

	// Includes
	g.buf.WriteString("#include <cstdint>\n")
	g.buf.WriteString("#include <cstring>\n")
	g.buf.WriteString("#include <string>\n")
	g.buf.WriteString("#include <vector>\n")
	g.buf.WriteString("#include <optional>\n")
	g.buf.WriteString("#include <stdexcept>\n\n")

	// Namespace
	fmt.Fprintf(g.buf, "namespace %s {\n\n", g.schema.Package)

	// Forward declarations for all structs (needed for mutual references)
	// Include Message suffix for root message types
	for _, msg := range g.schema.Messages {
		if structType, ok := msg.TargetType.(*schema.StructType); ok {
			fmt.Fprintf(g.buf, "struct %sMessage;\n", structType.Name)
		}
	}
	for _, typ := range g.schema.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			// Skip if this is a root message type (will be declared with Message suffix above)
			isRootType := false
			for _, msg := range g.schema.Messages {
				if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == structType.Name {
					isRootType = true
					break
				}
			}
			if !isRootType {
				fmt.Fprintf(g.buf, "struct %s;\n", structType.Name)
			}
		}
	}
	g.buf.WriteString("\n")

	// Build unified list of all structs (both root messages and embedded types)
	// We need to sort them together because root messages can depend on embedded types
	type structInfo struct {
		structType *schema.StructType
		isRoot     bool
	}
	
	allStructs := make([]structInfo, 0)
	
	// Add root message structs
	for _, msg := range g.schema.Messages {
		if structType, ok := msg.TargetType.(*schema.StructType); ok {
			allStructs = append(allStructs, structInfo{
				structType: structType,
				isRoot:     true,
			})
		}
	}
	
	// Add embedded/helper structs
	for _, typ := range g.schema.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			// Skip if this is a root message type (already added above)
			isRootType := false
			for _, msg := range g.schema.Messages {
				if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == structType.Name {
					isRootType = true
					break
				}
			}
			if !isRootType {
				allStructs = append(allStructs, structInfo{
					structType: structType,
					isRoot:     false,
				})
			}
		}
	}
	
	// Extract just the struct types for topological sort
	structTypes := make([]*schema.StructType, len(allStructs))
	for i, info := range allStructs {
		structTypes[i] = info.structType
	}
	
	// Sort by dependencies
	sortedStructTypes := g.topologicalSort(structTypes)
	
	// Generate in dependency order, applying Message suffix to root types
	for _, structType := range sortedStructTypes {
		// Check if this is a root message type
		isRoot := false
		for _, msg := range g.schema.Messages {
			if st, ok := msg.TargetType.(*schema.StructType); ok && st.Name == structType.Name {
				isRoot = true
				break
			}
		}
		
		if isRoot {
			g.generateMessageStruct(structType)
		} else {
			g.generateStruct(structType)
		}
	}

	// Generate encoder class
	g.buf.WriteString("// Binary encoder for wire format\n")
	g.buf.WriteString("class Encoder {\n")
	g.buf.WriteString("public:\n")
	g.buf.WriteString("    std::vector<uint8_t> buffer;\n\n")
	g.buf.WriteString("    void write_byte(uint8_t b) { buffer.push_back(b); }\n\n")
	g.buf.WriteString("    void write_bool(bool v) { buffer.push_back(v ? 0x01 : 0x00); }\n\n")
	g.buf.WriteString("    void write_int8(int8_t v) { buffer.push_back(static_cast<uint8_t>(v)); }\n\n")

	g.buf.WriteString("    void write_int16(int16_t v) {\n")
	g.buf.WriteString("        uint16_t u = static_cast<uint16_t>(v);\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 8));\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_int32(int32_t v) {\n")
	g.buf.WriteString("        uint32_t u = static_cast<uint32_t>(v);\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 8));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 16));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 24));\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_int64(int64_t v) {\n")
	g.buf.WriteString("        uint64_t u = static_cast<uint64_t>(v);\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 8));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 16));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 24));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 32));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 40));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 48));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(u >> 56));\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_float32(float v) {\n")
	g.buf.WriteString("        uint32_t u;\n")
	g.buf.WriteString("        std::memcpy(&u, &v, sizeof(float));\n")
	g.buf.WriteString("        write_int32(static_cast<int32_t>(u));\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_float64(double v) {\n")
	g.buf.WriteString("        uint64_t u;\n")
	g.buf.WriteString("        std::memcpy(&u, &v, sizeof(double));\n")
	g.buf.WriteString("        write_int64(static_cast<int64_t>(u));\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_string(const std::string& s) {\n")
	g.buf.WriteString("        uint16_t len = static_cast<uint16_t>(s.size());\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(len));\n")
	g.buf.WriteString("        buffer.push_back(static_cast<uint8_t>(len >> 8));\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), s.begin(), s.end());\n")
	g.buf.WriteString("    }\n\n")

	// Bulk write methods for zero-copy encoding of primitive arrays
	g.buf.WriteString("    // Bulk write methods for array optimization\n")
	g.buf.WriteString("    void write_bulk_int8(const std::vector<int8_t>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size());\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_bulk_int16(const std::vector<int16_t>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 2);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_bulk_int32(const std::vector<int32_t>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 4);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_bulk_int64(const std::vector<int64_t>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 8);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_bulk_float32(const std::vector<float>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 4);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    void write_bulk_float64(const std::vector<double>& arr) {\n")
	g.buf.WriteString("        if (arr.empty()) return;\n")
	g.buf.WriteString("        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());\n")
	g.buf.WriteString("        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 8);\n")
	g.buf.WriteString("    }\n")
	g.buf.WriteString("};\n\n")

	// Generate decoder class
	g.buf.WriteString("// Binary decoder for wire format\n")
	g.buf.WriteString("class Decoder {\n")
	g.buf.WriteString("public:\n")
	g.buf.WriteString("    const uint8_t* data;\n")
	g.buf.WriteString("    size_t size;\n")
	g.buf.WriteString("    size_t pos = 0;\n\n")
	g.buf.WriteString("    Decoder(const uint8_t* d, size_t s) : data(d), size(s) {}\n")
	g.buf.WriteString("    Decoder(const std::vector<uint8_t>& v) : data(v.data()), size(v.size()) {}\n\n")

	g.buf.WriteString("    void check_remaining(size_t needed) {\n")
	g.buf.WriteString("        if (pos + needed > size) {\n")
	g.buf.WriteString("            throw std::runtime_error(\"insufficient data for decode\");\n")
	g.buf.WriteString("        }\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    bool read_bool() {\n")
	g.buf.WriteString("        check_remaining(1);\n")
	g.buf.WriteString("        return data[pos++] != 0x00;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    int8_t read_int8() {\n")
	g.buf.WriteString("        check_remaining(1);\n")
	g.buf.WriteString("        return static_cast<int8_t>(data[pos++]);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    int16_t read_int16() {\n")
	g.buf.WriteString("        check_remaining(2);\n")
	g.buf.WriteString("        uint16_t u = static_cast<uint16_t>(data[pos]) |\n")
	g.buf.WriteString("                     (static_cast<uint16_t>(data[pos + 1]) << 8);\n")
	g.buf.WriteString("        pos += 2;\n")
	g.buf.WriteString("        return static_cast<int16_t>(u);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    int32_t read_int32() {\n")
	g.buf.WriteString("        check_remaining(4);\n")
	g.buf.WriteString("        uint32_t u = static_cast<uint32_t>(data[pos]) |\n")
	g.buf.WriteString("                     (static_cast<uint32_t>(data[pos + 1]) << 8) |\n")
	g.buf.WriteString("                     (static_cast<uint32_t>(data[pos + 2]) << 16) |\n")
	g.buf.WriteString("                     (static_cast<uint32_t>(data[pos + 3]) << 24);\n")
	g.buf.WriteString("        pos += 4;\n")
	g.buf.WriteString("        return static_cast<int32_t>(u);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    int64_t read_int64() {\n")
	g.buf.WriteString("        check_remaining(8);\n")
	g.buf.WriteString("        uint64_t u = static_cast<uint64_t>(data[pos]) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 1]) << 8) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 2]) << 16) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 3]) << 24) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 4]) << 32) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 5]) << 40) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 6]) << 48) |\n")
	g.buf.WriteString("                     (static_cast<uint64_t>(data[pos + 7]) << 56);\n")
	g.buf.WriteString("        pos += 8;\n")
	g.buf.WriteString("        return static_cast<int64_t>(u);\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    float read_float32() {\n")
	g.buf.WriteString("        uint32_t u = static_cast<uint32_t>(read_int32());\n")
	g.buf.WriteString("        float f;\n")
	g.buf.WriteString("        std::memcpy(&f, &u, sizeof(float));\n")
	g.buf.WriteString("        return f;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    double read_float64() {\n")
	g.buf.WriteString("        uint64_t u = static_cast<uint64_t>(read_int64());\n")
	g.buf.WriteString("        double d;\n")
	g.buf.WriteString("        std::memcpy(&d, &u, sizeof(double));\n")
	g.buf.WriteString("        return d;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    std::string read_string() {\n")
	g.buf.WriteString("        check_remaining(2);\n")
	g.buf.WriteString("        uint16_t len = static_cast<uint16_t>(data[pos]) |\n")
	g.buf.WriteString("                       (static_cast<uint16_t>(data[pos + 1]) << 8);\n")
	g.buf.WriteString("        pos += 2;\n")
	g.buf.WriteString("        check_remaining(len);\n")
	g.buf.WriteString("        std::string s(reinterpret_cast<const char*>(data + pos), len);\n")
	g.buf.WriteString("        pos += len;\n")
	g.buf.WriteString("        return s;\n")
	g.buf.WriteString("    }\n\n")

	g.buf.WriteString("    uint16_t read_array_length() {\n")
	g.buf.WriteString("        check_remaining(2);\n")
	g.buf.WriteString("        uint16_t len = static_cast<uint16_t>(data[pos]) |\n")
	g.buf.WriteString("                       (static_cast<uint16_t>(data[pos + 1]) << 8);\n")
	g.buf.WriteString("        pos += 2;\n")
	g.buf.WriteString("        return len;\n")
	g.buf.WriteString("    }\n")
	g.buf.WriteString("};\n\n")

	// Generate message encode/decode functions
	for _, msg := range g.schema.Messages {
		g.generateMessageEncode(msg)
		g.generateMessageDecode(msg)
	}

	// Generate helper functions for structs
	for _, typ := range g.schema.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			g.generateStructHelpers(structType)
		}
	}

	// Close namespace
	fmt.Fprintf(g.buf, "} // namespace %s\n\n", g.schema.Package)

	// Close header guard
	fmt.Fprintf(g.buf, "#endif // %s\n", guardName)

	return g.buf.Bytes(), nil
}

func (g *cppGenerator) generateMessageStruct(structType *schema.StructType) {
	// Generate root message struct with Message suffix to avoid keyword collisions
	fmt.Fprintf(g.buf, "struct %sMessage {\n", structType.Name)
	for _, field := range structType.Fields {
		typeStr := g.cppTypeString(field.Type)
		fmt.Fprintf(g.buf, "    %s %s;\n", typeStr, field.Name)
	}
	g.buf.WriteString("};\n\n")
}

func (g *cppGenerator) generateStruct(structType *schema.StructType) {
	// Generate helper/embedded struct (no Message suffix)
	fmt.Fprintf(g.buf, "struct %s {\n", structType.Name)
	for _, field := range structType.Fields {
		typeStr := g.cppTypeString(field.Type)
		fmt.Fprintf(g.buf, "    %s %s;\n", typeStr, field.Name)
	}
	g.buf.WriteString("};\n\n")
}

func (g *cppGenerator) cppTypeString(typ schema.Type) string {
	switch t := typ.(type) {
	case *schema.PrimitiveType:
		baseName := g.cppPrimitiveType(t.Name)
		if t.Optional {
			return "std::optional<" + baseName + ">"
		}
		return baseName

	case *schema.StructType:
		if t.Optional {
			return "std::optional<" + t.Name + ">"
		}
		return t.Name

	case *schema.ArrayType:
		elemType := g.cppTypeString(t.ElementType)
		vectorType := "std::vector<" + elemType + ">"
		if t.Optional {
			return "std::optional<" + vectorType + ">"
		}
		return vectorType

	default:
		return "void*"
	}
}

func (g *cppGenerator) cppPrimitiveType(name string) string {
	switch name {
	case "bool":
		return "bool"
	case "int8":
		return "int8_t"
	case "int16":
		return "int16_t"
	case "int32":
		return "int32_t"
	case "int64":
		return "int64_t"
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "string":
		return "std::string"
	default:
		return "void*"
	}
}

func (g *cppGenerator) generateMessageEncode(msg schema.MessageType) {
	rootTypeName := g.rootTypeName(msg.TargetType)
	funcName := fmt.Sprintf("encode_%s_message", strings.ToLower(rootTypeName))

	// For struct messages, use {Name}Message type; for arrays/primitives use target type
	var paramType string
	var constRef string
	if _, ok := msg.TargetType.(*schema.StructType); ok {
		// Root message struct uses Message suffix
		paramType = msg.Name + "Message"
		constRef = "const " + paramType + "&"
	} else {
		paramType = g.cppTypeString(msg.TargetType)
		// Special case for primitives - pass by value
		if _, ok := msg.TargetType.(*schema.PrimitiveType); ok {
			constRef = paramType
		} else {
			constRef = "const " + paramType + "&"
		}
	}

	fmt.Fprintf(g.buf, "// Encode %s to binary wire format\n", msg.Name)
	fmt.Fprintf(g.buf, "inline std::vector<uint8_t> %s(%s value) {\n", funcName, constRef)
	g.buf.WriteString("    Encoder enc;\n")
	g.generateEncodeValue("enc", "value", msg.TargetType, "    ")
	g.buf.WriteString("    return enc.buffer;\n")
	g.buf.WriteString("}\n\n")
}

func (g *cppGenerator) generateMessageDecode(msg schema.MessageType) {
	rootTypeName := g.rootTypeName(msg.TargetType)
	funcName := fmt.Sprintf("decode_%s_message", strings.ToLower(rootTypeName))

	// For struct messages, use {Name}Message type; for arrays/primitives use target type
	var returnType string
	if _, ok := msg.TargetType.(*schema.StructType); ok {
		// Root message struct uses Message suffix
		returnType = msg.Name + "Message"
	} else {
		returnType = g.cppTypeString(msg.TargetType)
	}

	fmt.Fprintf(g.buf, "// Decode %s from binary wire format\n", msg.Name)
	fmt.Fprintf(g.buf, "inline %s %s(const uint8_t* data, size_t size) {\n", returnType, funcName)
	g.buf.WriteString("    Decoder dec(data, size);\n")
	fmt.Fprintf(g.buf, "    %s result;\n", returnType)
	g.generateDecodeValue("dec", "result", msg.TargetType, "    ")
	g.buf.WriteString("    return result;\n")
	g.buf.WriteString("}\n\n")

	// Overload for vector
	fmt.Fprintf(g.buf, "inline %s %s(const std::vector<uint8_t>& data) {\n", returnType, funcName)
	fmt.Fprintf(g.buf, "    return %s(data.data(), data.size());\n", funcName)
	g.buf.WriteString("}\n\n")
}

func (g *cppGenerator) rootTypeName(typ schema.Type) string {
	switch t := typ.(type) {
	case *schema.PrimitiveType:
		return strings.Title(t.Name)
	case *schema.StructType:
		return t.Name
	case *schema.ArrayType:
		return g.rootTypeName(t.ElementType)
	default:
		return "Unknown"
	}
}

func (g *cppGenerator) generateEncodeValue(encVar, valueVar string, typ schema.Type, indent string) {
	switch t := typ.(type) {
	case *schema.PrimitiveType:
		g.generateEncodePrimitive(encVar, valueVar, t, indent)
	case *schema.StructType:
		g.generateEncodeStruct(encVar, valueVar, t, indent)
	case *schema.ArrayType:
		g.generateEncodeArray(encVar, valueVar, t, indent)
	}
}

func (g *cppGenerator) generateEncodePrimitive(encVar, valueVar string, typ *schema.PrimitiveType, indent string) {
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.has_value()) {\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x01);\n", indent, encVar)
		valueVar = valueVar + ".value()"
		indent += "    "
	}

	switch typ.Name {
	case "bool":
		fmt.Fprintf(g.buf, "%s%s.write_bool(%s);\n", indent, encVar, valueVar)
	case "int8":
		fmt.Fprintf(g.buf, "%s%s.write_int8(%s);\n", indent, encVar, valueVar)
	case "int16":
		fmt.Fprintf(g.buf, "%s%s.write_int16(%s);\n", indent, encVar, valueVar)
	case "int32":
		fmt.Fprintf(g.buf, "%s%s.write_int32(%s);\n", indent, encVar, valueVar)
	case "int64":
		fmt.Fprintf(g.buf, "%s%s.write_int64(%s);\n", indent, encVar, valueVar)
	case "float32":
		fmt.Fprintf(g.buf, "%s%s.write_float32(%s);\n", indent, encVar, valueVar)
	case "float64":
		fmt.Fprintf(g.buf, "%s%s.write_float64(%s);\n", indent, encVar, valueVar)
	case "string":
		fmt.Fprintf(g.buf, "%s%s.write_string(%s);\n", indent, encVar, valueVar)
	}

	if typ.Optional {
		indent = indent[:len(indent)-4]
		fmt.Fprintf(g.buf, "%s} else {\n", indent)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x00);\n", indent, encVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *cppGenerator) generateEncodeStruct(encVar, valueVar string, typ *schema.StructType, indent string) {
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.has_value()) {\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x01);\n", indent, encVar)
		valueVar = valueVar + ".value()"
		indent += "    "
	}

	for _, field := range typ.Fields {
		fieldVar := valueVar + "." + field.Name
		g.generateEncodeValue(encVar, fieldVar, field.Type, indent)
	}

	if typ.Optional {
		indent = indent[:len(indent)-4]
		fmt.Fprintf(g.buf, "%s} else {\n", indent)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x00);\n", indent, encVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

// generateBulkArrayEncode generates optimized bulk encoding for primitive arrays
func (g *cppGenerator) generateBulkArrayEncode(encVar, valueVar string, typ *schema.ArrayType, indent string) bool {
	primType, ok := typ.ElementType.(*schema.PrimitiveType)
	if !ok || primType.Optional {
		return false // Can't bulk encode optional or non-primitive types
	}

	var bulkMethod string
	switch primType.Name {
	case "int8":
		bulkMethod = "write_bulk_int8"
	case "int16":
		bulkMethod = "write_bulk_int16"
	case "int32":
		bulkMethod = "write_bulk_int32"
	case "int64":
		bulkMethod = "write_bulk_int64"
	case "float32":
		bulkMethod = "write_bulk_float32"
	case "float64":
		bulkMethod = "write_bulk_float64"
	case "string":
		// Optimize string arrays with reserve() to avoid reallocations
		fmt.Fprintf(g.buf, "%s{\n", indent)
		fmt.Fprintf(g.buf, "%s    size_t totalSize = %s.size() * 2; // length prefixes\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    for (const auto& s : %s) { totalSize += s.size(); }\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    %s.buffer.reserve(%s.buffer.size() + totalSize);\n", indent, encVar, encVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
		fmt.Fprintf(g.buf, "%sfor (const auto& elem : %s) {\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    %s.write_string(elem);\n", indent, encVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
		return true
	default:
		return false // No bulk optimization for this type
	}

	// Generate bulk write
	fmt.Fprintf(g.buf, "%s%s.%s(%s);\n", indent, encVar, bulkMethod, valueVar)
	return true
}

func (g *cppGenerator) generateEncodeArray(encVar, valueVar string, typ *schema.ArrayType, indent string) {
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.has_value()) {\n", indent, valueVar)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x01);\n", indent, encVar)
		valueVar = valueVar + ".value()"
		indent += "    "
	}

	// Write array length
	fmt.Fprintf(g.buf, "%s{\n", indent)
	fmt.Fprintf(g.buf, "%s    uint16_t len = static_cast<uint16_t>(%s.size());\n", indent, valueVar)
	fmt.Fprintf(g.buf, "%s    %s.write_byte(static_cast<uint8_t>(len));\n", indent, encVar)
	fmt.Fprintf(g.buf, "%s    %s.write_byte(static_cast<uint8_t>(len >> 8));\n", indent, encVar)
	fmt.Fprintf(g.buf, "%s}\n", indent)

	// Try bulk encoding first for primitive arrays
	if !g.generateBulkArrayEncode(encVar, valueVar, typ, indent) {
		// Fall back to element-by-element encoding
		fmt.Fprintf(g.buf, "%sfor (const auto& elem : %s) {\n", indent, valueVar)
		g.generateEncodeValue(encVar, "elem", typ.ElementType, indent+"    ")
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}

	if typ.Optional {
		indent = indent[:len(indent)-4]
		fmt.Fprintf(g.buf, "%s} else {\n", indent)
		fmt.Fprintf(g.buf, "%s    %s.write_byte(0x00);\n", indent, encVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *cppGenerator) generateDecodeValue(decVar, resultVar string, typ schema.Type, indent string) {
	switch t := typ.(type) {
	case *schema.PrimitiveType:
		g.generateDecodePrimitive(decVar, resultVar, t, indent)
	case *schema.StructType:
		g.generateDecodeStruct(decVar, resultVar, t, indent)
	case *schema.ArrayType:
		g.generateDecodeArray(decVar, resultVar, t, indent)
	}
}

func (g *cppGenerator) generateDecodePrimitive(decVar, resultVar string, typ *schema.PrimitiveType, indent string) {
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.read_bool()) {\n", indent, decVar)
		indent += "    "
	}

	switch typ.Name {
	case "bool":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_bool();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_bool();\n", indent, resultVar, decVar)
		}
	case "int8":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int8();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int8();\n", indent, resultVar, decVar)
		}
	case "int16":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int16();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int16();\n", indent, resultVar, decVar)
		}
	case "int32":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int32();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int32();\n", indent, resultVar, decVar)
		}
	case "int64":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int64();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_int64();\n", indent, resultVar, decVar)
		}
	case "float32":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_float32();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_float32();\n", indent, resultVar, decVar)
		}
	case "float64":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_float64();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_float64();\n", indent, resultVar, decVar)
		}
	case "string":
		if typ.Optional {
			fmt.Fprintf(g.buf, "%s%s = %s.read_string();\n", indent, resultVar, decVar)
		} else {
			fmt.Fprintf(g.buf, "%s%s = %s.read_string();\n", indent, resultVar, decVar)
		}
	}

	if typ.Optional {
		indent = indent[:len(indent)-4]
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *cppGenerator) generateDecodeStruct(decVar, resultVar string, typ *schema.StructType, indent string) {
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.read_bool()) {\n", indent, decVar)
		fmt.Fprintf(g.buf, "%s    %s tmp;\n", indent, typ.Name)
		indent += "    "
		resultVar = "tmp"
	}

	for _, field := range typ.Fields {
		fieldVar := resultVar + "." + field.Name
		g.generateDecodeValue(decVar, fieldVar, field.Type, indent)
	}

	if typ.Optional {
		indent = indent[:len(indent)-4]
		// Strip last ".value()" if added
		baseResultVar := resultVar
		if strings.HasSuffix(resultVar, ".value()") {
			baseResultVar = resultVar[:len(resultVar)-8]
		}
		fmt.Fprintf(g.buf, "%s    %s = tmp;\n", indent, baseResultVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

func (g *cppGenerator) generateDecodeArray(decVar, resultVar string, typ *schema.ArrayType, indent string) {
	originalResultVar := resultVar // Save for optional assignment
	if typ.Optional {
		fmt.Fprintf(g.buf, "%sif (%s.read_bool()) {\n", indent, decVar)
		indent += "    "
		elemType := g.cppTypeString(typ.ElementType)
		fmt.Fprintf(g.buf, "%sstd::vector<%s> tmp;\n", indent, elemType)
		resultVar = "tmp"
	}

	fmt.Fprintf(g.buf, "%s{\n", indent)
	fmt.Fprintf(g.buf, "%s    uint16_t len = %s.read_array_length();\n", indent, decVar)
	fmt.Fprintf(g.buf, "%s    %s.reserve(len);\n", indent, resultVar)
	fmt.Fprintf(g.buf, "%s    for (uint16_t i = 0; i < len; ++i) {\n", indent)

	// Use unique variable name based on depth to avoid shadowing in nested arrays
	elemVar := fmt.Sprintf("elem%d", g.depth)
	g.depth++
	elemType := g.cppTypeString(typ.ElementType)
	fmt.Fprintf(g.buf, "%s        %s %s;\n", indent, elemType, elemVar)
	g.generateDecodeValue(decVar, elemVar, typ.ElementType, indent+"        ")
	fmt.Fprintf(g.buf, "%s        %s.push_back(std::move(%s));\n", indent, resultVar, elemVar)
	g.depth--
	fmt.Fprintf(g.buf, "%s    }\n", indent)
	fmt.Fprintf(g.buf, "%s}\n", indent)

	if typ.Optional {
		indent = indent[:len(indent)-4]
		// Use the original result variable for assignment, not the temp variable
		fmt.Fprintf(g.buf, "%s    %s = std::move(tmp);\n", indent, originalResultVar)
		fmt.Fprintf(g.buf, "%s}\n", indent)
	}
}

// topologicalSort sorts structs so that structs with no dependencies come first.
// This ensures that when Level1 contains Level2, Level2 is defined before Level1.
func (g *cppGenerator) topologicalSort(structs []*schema.StructType) []*schema.StructType {
	// Build a map of struct names to their types
	structMap := make(map[string]*schema.StructType)
	for _, s := range structs {
		structMap[s.Name] = s
	}

	// Track dependencies: for each struct, which other structs does it depend on?
	dependencies := make(map[string][]string)
	for _, s := range structs {
		deps := make([]string, 0)
		for _, field := range s.Fields {
			if depName := g.getStructDependency(field.Type, structMap); depName != "" {
				deps = append(deps, depName)
			}
		}
		dependencies[s.Name] = deps
	}

	// Topological sort using Kahn's algorithm
	result := make([]*schema.StructType, 0, len(structs))

	// Count dependencies for each struct (outgoing edges - how many structs does this depend on?)
	remainingDeps := make(map[string]int)
	for name, deps := range dependencies {
		remainingDeps[name] = len(deps)
	}

	// Start with structs that have no dependencies
	queue := make([]string, 0)
	for name, count := range remainingDeps {
		if count == 0 {
			queue = append(queue, name)
		}
	}

	// Process queue
	for len(queue) > 0 {
		name := queue[0]
		queue = queue[1:]
		result = append(result, structMap[name])

		// Find structs that depend on this one and reduce their dependency count
		for depName, deps := range dependencies {
			for _, dep := range deps {
				if dep == name {
					remainingDeps[depName]--
					if remainingDeps[depName] == 0 {
						queue = append(queue, depName)
					}
					break
				}
			}
		}
	}

	// If there are cycles, just append remaining structs (shouldn't happen in valid schemas)
	if len(result) < len(structs) {
		for _, s := range structs {
			found := false
			for _, r := range result {
				if r.Name == s.Name {
					found = true
					break
				}
			}
			if !found {
				result = append(result, s)
			}
		}
	}

	return result
}

// getStructDependency returns the name of the struct type that this field type depends on,
// or empty string if it doesn't depend on any struct.
func (g *cppGenerator) getStructDependency(typ schema.Type, structMap map[string]*schema.StructType) string {
	switch t := typ.(type) {
	case *schema.StructType:
		if _, ok := structMap[t.Name]; ok {
			return t.Name
		}
	case *schema.ArrayType:
		return g.getStructDependency(t.ElementType, structMap)
	}
	return ""
}

func (g *cppGenerator) generateStructHelpers(structType *schema.StructType) {
	// C++ doesn't need separate helper functions since we inline everything
	// The message encode/decode functions handle everything
}
