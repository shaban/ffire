package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shaban/ffire/pkg/schema"
)

// rustKeywords lists Rust keywords that cannot be used as identifiers
var rustKeywords = map[string]bool{
	"as": true, "break": true, "const": true, "continue": true, "crate": true,
	"else": true, "enum": true, "extern": true, "false": true, "fn": true,
	"for": true, "if": true, "impl": true, "in": true, "let": true,
	"loop": true, "match": true, "mod": true, "move": true, "mut": true,
	"pub": true, "ref": true, "return": true, "self": true, "Self": true,
	"static": true, "struct": true, "super": true, "trait": true, "true": true,
	"type": true, "unsafe": true, "use": true, "where": true, "while": true,
	"async": true, "await": true, "dyn": true, "abstract": true, "become": true,
	"box": true, "do": true, "final": true, "macro": true, "override": true,
	"priv": true, "typeof": true, "unsized": true, "virtual": true, "yield": true,
}

// SanitizeRustModuleName ensures the module name is not a Rust keyword
func SanitizeRustModuleName(name string) string {
	if rustKeywords[name] {
		return name + "_mod"
	}
	return name
}

// escapeRustFieldName escapes Rust keywords used as field names
func escapeRustFieldName(name string) string {
	if rustKeywords[name] {
		return "r#" + name
	}
	return name
}

// GenerateRustPackage generates a complete native Rust package
func GenerateRustPackage(config *PackageConfig) error {
	// Sanitize the namespace to avoid Rust keywords
	config.Namespace = SanitizeRustModuleName(config.Namespace)

	// Create rust directory
	rustDir := filepath.Join(config.OutputDir, "rust")
	srcDir := filepath.Join(rustDir, "src")
	if err := os.MkdirAll(srcDir, 0755); err != nil {
		return fmt.Errorf("failed to create rust directory: %w", err)
	}

	// Generate native Rust code
	rustCode, err := generateRustNative(config.Schema)
	if err != nil {
		return fmt.Errorf("failed to generate Rust code: %w", err)
	}

	// Write Rust source file
	libPath := filepath.Join(srcDir, "lib.rs")
	if err := os.WriteFile(libPath, rustCode, 0644); err != nil {
		return fmt.Errorf("failed to write Rust source: %w", err)
	}
	fmt.Printf("✓ Generated Rust source: %s\n", libPath)

	// Generate Cargo.toml
	cargoToml := generateCargoToml(config.Namespace)
	cargoPath := filepath.Join(rustDir, "Cargo.toml")
	if err := os.WriteFile(cargoPath, []byte(cargoToml), 0644); err != nil {
		return fmt.Errorf("failed to write Cargo.toml: %w", err)
	}
	fmt.Printf("✓ Generated Cargo.toml\n")

	// Generate README
	readme := generateRustReadme(config.Namespace)
	readmePath := filepath.Join(rustDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(readme), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}
	fmt.Printf("✓ Generated README.md\n")

	fmt.Printf("\n✅ Rust package ready at: %s\n\n", rustDir)
	fmt.Println("Build:")
	fmt.Printf("  cd %s\n", rustDir)
	fmt.Println("  cargo build --release")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  use %s::*;\n", config.Namespace)
	fmt.Println("  let msg = MyMessage::decode(&data)?;")
	fmt.Println("  let encoded = msg.encode();")
	fmt.Println()

	return nil
}

func generateCargoToml(namespace string) string {
	return fmt.Sprintf(`[package]
name = "%s"
version = "0.1.0"
edition = "2021"
description = "Generated ffire serialization code"

[lib]
name = "%s"
path = "src/lib.rs"

[dependencies]
`, namespace, namespace)
}

func generateRustReadme(namespace string) string {
	return fmt.Sprintf(`# %s - Rust FFire Bindings

Native Rust implementation for ffire serialization.

## Building

`+"```bash"+`
cargo build --release
`+"```"+`

## Usage

`+"```rust"+`
use %s::*;

fn main() -> Result<(), FFireError> {
    let data: &[u8] = // ... binary data
    
    // Decode
    let msg = MyMessage::decode(data)?;
    
    // Encode
    let encoded = msg.encode();
    
    Ok(())
}
`+"```"+`

## Features

- Zero-copy decoding where possible
- Safe Rust (no unsafe blocks)
- Little-endian wire format
- Bulk memory operations for primitive arrays
`, namespace, namespace)
}

// generateRustNative generates pure Rust code optimized for performance
func generateRustNative(s *schema.Schema) ([]byte, error) {
	var buf bytes.Buffer

	// File header
	buf.WriteString("// Generated by ffire - Native Rust implementation\n")
	buf.WriteString("// DO NOT EDIT - This file is auto-generated\n\n")

	// Error type
	buf.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	buf.WriteString("pub enum FFireError {\n")
	buf.WriteString("    BufferTooShort,\n")
	buf.WriteString("    InvalidUtf8,\n")
	buf.WriteString("    InvalidData,\n")
	buf.WriteString("}\n\n")

	buf.WriteString("impl std::fmt::Display for FFireError {\n")
	buf.WriteString("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n")
	buf.WriteString("        match self {\n")
	buf.WriteString("            FFireError::BufferTooShort => write!(f, \"Buffer too short\"),\n")
	buf.WriteString("            FFireError::InvalidUtf8 => write!(f, \"Invalid UTF-8\"),\n")
	buf.WriteString("            FFireError::InvalidData => write!(f, \"Invalid data\"),\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	buf.WriteString("impl std::error::Error for FFireError {}\n\n")

	// Generate struct definitions
	// First, generate helper structs (non-root types)
	rootMessageTypes := make(map[string]bool)
	for _, msg := range s.Messages {
		if st, ok := msg.TargetType.(*schema.StructType); ok {
			rootMessageTypes[st.Name] = true
		}
	}

	for _, typ := range s.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			if !rootMessageTypes[structType.Name] {
				generateRustStruct(&buf, structType, false)
			}
		}
	}

	// Generate message type definitions (root types with Message suffix)
	for _, msg := range s.Messages {
		if structType, ok := msg.TargetType.(*schema.StructType); ok {
			generateRustStruct(&buf, structType, true)
			generateRustMessageImpl(&buf, msg.Name, structType)
		} else if arrayType, ok := msg.TargetType.(*schema.ArrayType); ok {
			generateRustArrayMessage(&buf, msg.Name, arrayType)
		}
	}

	// Generate helper struct encode/decode implementations
	for _, typ := range s.Types {
		if structType, ok := typ.(*schema.StructType); ok {
			if !rootMessageTypes[structType.Name] {
				generateRustStructImpl(&buf, structType)
			}
		}
	}

	return buf.Bytes(), nil
}

func generateRustStruct(buf *bytes.Buffer, structType *schema.StructType, isMessage bool) {
	structName := structType.Name
	if isMessage {
		structName = structType.Name + "Message"
	}

	buf.WriteString("#[derive(Debug, Clone, PartialEq)]\n")
	buf.WriteString(fmt.Sprintf("pub struct %s {\n", structName))

	for _, field := range structType.Fields {
		rustType := getRustTypeString(field.Type)
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		buf.WriteString(fmt.Sprintf("    pub %s: %s,\n", fieldName, rustType))
	}

	buf.WriteString("}\n\n")
}

func generateRustMessageImpl(buf *bytes.Buffer, messageName string, structType *schema.StructType) {
	structName := messageName + "Message"
	snakeName := toSnakeCase(messageName)

	buf.WriteString(fmt.Sprintf("impl %s {\n", structName))

	// Encode method
	buf.WriteString("    /// Encode the message to binary wire format\n")
	buf.WriteString("    pub fn encode(&self) -> Vec<u8> {\n")
	buf.WriteString("        let mut buf = Vec::new();\n")

	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		generateRustEncodeField(buf, field.Type, fmt.Sprintf("self.%s", fieldName), "        ", false) // buf is local Vec<u8>
	}

	buf.WriteString("        buf\n")
	buf.WriteString("    }\n\n")

	// Decode method
	buf.WriteString("    /// Decode a message from binary wire format\n")
	buf.WriteString("    pub fn decode(data: &[u8]) -> Result<Self, FFireError> {\n")
	buf.WriteString("        let mut pos = 0;\n")

	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		generateRustDecodeField(buf, field.Type, fieldName, "        ")
	}

	buf.WriteString(fmt.Sprintf("        Ok(%s {\n", structName))
	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		buf.WriteString(fmt.Sprintf("            %s,\n", fieldName))
	}
	buf.WriteString("        })\n")
	buf.WriteString("    }\n")

	buf.WriteString("}\n\n")

	// Generate free functions for consistent API with array messages
	buf.WriteString(fmt.Sprintf("/// Encode %s to binary wire format\n", structName))
	buf.WriteString(fmt.Sprintf("pub fn encode_%s_message(msg: &%s) -> Vec<u8> {\n", snakeName, structName))
	buf.WriteString("    msg.encode()\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("/// Decode %s from binary wire format\n", structName))
	buf.WriteString(fmt.Sprintf("pub fn decode_%s_message(data: &[u8]) -> Result<%s, FFireError> {\n", snakeName, structName))
	buf.WriteString(fmt.Sprintf("    %s::decode(data)\n", structName))
	buf.WriteString("}\n\n")
}

func generateRustArrayMessage(buf *bytes.Buffer, messageName string, arrayType *schema.ArrayType) {
	structName := messageName + "Message"
	elemType := getRustTypeString(arrayType.ElementType)

	buf.WriteString("/// Type alias for array message\n")
	buf.WriteString(fmt.Sprintf("pub type %s = Vec<%s>;\n\n", structName, elemType))

	// Generate encode/decode functions for array messages
	buf.WriteString(fmt.Sprintf("/// Encode %s to binary wire format\n", structName))
	buf.WriteString(fmt.Sprintf("pub fn encode_%s_message(arr: &%s) -> Vec<u8> {\n", toSnakeCase(messageName), structName))
	buf.WriteString("    let mut buf = Vec::new();\n")

	// Write length prefix
	buf.WriteString("    buf.extend_from_slice(&(arr.len() as u16).to_le_bytes());\n")

	// Write elements
	generateRustEncodeArrayElements(buf, arrayType.ElementType, "arr", "    ", false)

	buf.WriteString("    buf\n")
	buf.WriteString("}\n\n")

	buf.WriteString(fmt.Sprintf("/// Decode %s from binary wire format\n", structName))
	buf.WriteString(fmt.Sprintf("pub fn decode_%s_message(data: &[u8]) -> Result<%s, FFireError> {\n", toSnakeCase(messageName), structName))
	buf.WriteString("    let mut pos = 0;\n")
	buf.WriteString("    if data.len() < 2 {\n")
	buf.WriteString("        return Err(FFireError::BufferTooShort);\n")
	buf.WriteString("    }\n")
	buf.WriteString("    let len = u16::from_le_bytes([data[0], data[1]]) as usize;\n")
	buf.WriteString("    pos += 2;\n")

	generateRustDecodeArrayElements(buf, arrayType.ElementType, "result", "len", "    ")

	buf.WriteString("    Ok(result)\n")
	buf.WriteString("}\n\n")
}

func generateRustStructImpl(buf *bytes.Buffer, structType *schema.StructType) {
	buf.WriteString(fmt.Sprintf("impl %s {\n", structType.Name))

	// Encode method
	buf.WriteString("    fn encode_to(&self, buf: &mut Vec<u8>) {\n")
	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		generateRustEncodeField(buf, field.Type, fmt.Sprintf("self.%s", fieldName), "        ", true) // buf is &mut ref
	}
	buf.WriteString("    }\n\n")

	// Decode method
	buf.WriteString("    fn decode_from(data: &[u8], pos: &mut usize) -> Result<Self, FFireError> {\n")
	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		generateRustDecodeFieldWithPos(buf, field.Type, fieldName, "        ")
	}

	buf.WriteString(fmt.Sprintf("        Ok(%s {\n", structType.Name))
	for _, field := range structType.Fields {
		fieldName := escapeRustFieldName(toSnakeCase(field.Name))
		buf.WriteString(fmt.Sprintf("            %s,\n", fieldName))
	}
	buf.WriteString("        })\n")
	buf.WriteString("    }\n")

	buf.WriteString("}\n\n")
}

func generateRustEncodeField(buf *bytes.Buffer, fieldType schema.Type, accessor string, indent string, bufIsMutRef bool) {
	// bufIsMutRef: true if buf is already &mut Vec<u8> (in encode_to), false if buf is local Vec<u8> (in encode)
	bufArg := "&mut buf"
	if bufIsMutRef {
		bufArg = "buf"
	}

	switch t := fieldType.(type) {
	case *schema.PrimitiveType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%sif let Some(ref v) = %s {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    buf.push(1);\n", indent))
			generateRustEncodePrimitive(buf, t.Name, "v", indent+"    ", true) // v is a reference
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    buf.push(0);\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		} else {
			generateRustEncodePrimitive(buf, t.Name, accessor, indent, false) // accessor is a value
		}

	case *schema.ArrayType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%sif let Some(ref arr) = %s {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    buf.push(1);\n", indent))
			buf.WriteString(fmt.Sprintf("%s    buf.extend_from_slice(&(arr.len() as u16).to_le_bytes());\n", indent))
			generateRustEncodeArrayElements(buf, t.ElementType, "arr", indent+"    ", bufIsMutRef)
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    buf.push(0);\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		} else {
			buf.WriteString(fmt.Sprintf("%sbuf.extend_from_slice(&(%s.len() as u16).to_le_bytes());\n", indent, accessor))
			generateRustEncodeArrayElements(buf, t.ElementType, accessor, indent, bufIsMutRef)
		}

	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%s%s.encode_to(%s);\n", indent, accessor, bufArg))
	}
}

func generateRustEncodePrimitive(buf *bytes.Buffer, typeName string, accessor string, indent string, isRef bool) {
	// For references, we may need to dereference (*) for some types
	deref := ""
	if isRef {
		deref = "*"
	}
	
	switch typeName {
	case "bool":
		buf.WriteString(fmt.Sprintf("%sbuf.push(if %s%s { 1 } else { 0 });\n", indent, deref, accessor))
	case "int8":
		buf.WriteString(fmt.Sprintf("%sbuf.push(%s%s as u8);\n", indent, deref, accessor))
	case "int16", "int32", "int64", "float32", "float64":
		buf.WriteString(fmt.Sprintf("%sbuf.extend_from_slice(&%s.to_le_bytes());\n", indent, accessor))
	case "string":
		buf.WriteString(fmt.Sprintf("%slet bytes = %s.as_bytes();\n", indent, accessor))
		buf.WriteString(fmt.Sprintf("%sbuf.extend_from_slice(&(bytes.len() as u16).to_le_bytes());\n", indent))
		buf.WriteString(fmt.Sprintf("%sbuf.extend_from_slice(bytes);\n", indent))
	}
}

func generateRustEncodeArrayElements(buf *bytes.Buffer, elemType schema.Type, accessor string, indent string, bufIsMutRef bool) {
	// bufIsMutRef: true if buf is already &mut Vec<u8> (in encode_to methods), false if buf is Vec<u8> (in free functions)
	bufArg := "&mut buf"
	if bufIsMutRef {
		bufArg = "buf"
	}
	
	switch t := elemType.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "bool":
			buf.WriteString(fmt.Sprintf("%sfor v in %s.iter() {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    buf.push(if *v { 1 } else { 0 });\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		case "int8":
			buf.WriteString(fmt.Sprintf("%sfor v in %s.iter() {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    buf.push(*v as u8);\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		case "int16", "int32", "int64", "float32", "float64":
			// Bulk copy - reinterpret as bytes
			buf.WriteString(fmt.Sprintf("%sfor v in %s.iter() {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    buf.extend_from_slice(&v.to_le_bytes());\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		case "string":
			buf.WriteString(fmt.Sprintf("%sfor s in %s.iter() {\n", indent, accessor))
			buf.WriteString(fmt.Sprintf("%s    let bytes = s.as_bytes();\n", indent))
			buf.WriteString(fmt.Sprintf("%s    buf.extend_from_slice(&(bytes.len() as u16).to_le_bytes());\n", indent))
			buf.WriteString(fmt.Sprintf("%s    buf.extend_from_slice(bytes);\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}
	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%sfor item in %s.iter() {\n", indent, accessor))
		buf.WriteString(fmt.Sprintf("%s    item.encode_to(%s);\n", indent, bufArg))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
	}
}

func generateRustDecodeField(buf *bytes.Buffer, fieldType schema.Type, varName string, indent string) {
	switch t := fieldType.(type) {
	case *schema.PrimitiveType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%slet %s = if data.get(pos).copied().unwrap_or(0) == 1 {\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s    pos += 1;\n", indent))
			generateRustDecodePrimitive(buf, t.Name, "v", indent+"    ")
			buf.WriteString(fmt.Sprintf("%s    Some(v)\n", indent))
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    None\n", indent))
			buf.WriteString(fmt.Sprintf("%s};\n", indent))
		} else {
			generateRustDecodePrimitive(buf, t.Name, varName, indent)
		}

	case *schema.ArrayType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%slet %s = if data.get(pos).copied().unwrap_or(0) == 1 {\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s    pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let len = u16::from_le_bytes([data[pos], data[pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    pos += 2;\n", indent))
			generateRustDecodeArrayElements(buf, t.ElementType, "arr", "len", indent+"    ")
			buf.WriteString(fmt.Sprintf("%s    Some(arr)\n", indent))
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    None\n", indent))
			buf.WriteString(fmt.Sprintf("%s};\n", indent))
		} else {
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet len = u16::from_le_bytes([data[pos], data[pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += 2;\n", indent))
			generateRustDecodeArrayElements(buf, t.ElementType, varName, "len", indent)
		}

	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%slet %s = %s::decode_from(data, &mut pos)?;\n", indent, varName, t.Name))
	}
}

func generateRustDecodeFieldWithPos(buf *bytes.Buffer, fieldType schema.Type, varName string, indent string) {
	// Same as generateRustDecodeField but uses *pos instead of pos
	switch t := fieldType.(type) {
	case *schema.PrimitiveType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%slet %s = if data.get(*pos).copied().unwrap_or(0) == 1 {\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s    *pos += 1;\n", indent))
			generateRustDecodePrimitiveWithPos(buf, t.Name, "v", indent+"    ")
			buf.WriteString(fmt.Sprintf("%s    Some(v)\n", indent))
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    *pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    None\n", indent))
			buf.WriteString(fmt.Sprintf("%s};\n", indent))
		} else {
			generateRustDecodePrimitiveWithPos(buf, t.Name, varName, indent)
		}

	case *schema.ArrayType:
		if t.Optional {
			buf.WriteString(fmt.Sprintf("%slet %s = if data.get(*pos).copied().unwrap_or(0) == 1 {\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s    *pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < *pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let len = u16::from_le_bytes([data[*pos], data[*pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    *pos += 2;\n", indent))
			generateRustDecodeArrayElementsWithPos(buf, t.ElementType, "arr", "len", indent+"    ")
			buf.WriteString(fmt.Sprintf("%s    Some(arr)\n", indent))
			buf.WriteString(fmt.Sprintf("%s} else {\n", indent))
			buf.WriteString(fmt.Sprintf("%s    *pos += 1;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    None\n", indent))
			buf.WriteString(fmt.Sprintf("%s};\n", indent))
		} else {
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet len = u16::from_le_bytes([data[*pos], data[*pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += 2;\n", indent))
			generateRustDecodeArrayElementsWithPos(buf, t.ElementType, varName, "len", indent)
		}

	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%slet %s = %s::decode_from(data, pos)?;\n", indent, varName, t.Name))
	}
}

func generateRustDecodePrimitive(buf *bytes.Buffer, typeName string, varName string, indent string) {
	switch typeName {
	case "bool":
		buf.WriteString(fmt.Sprintf("%slet %s = data.get(pos).copied().unwrap_or(0) != 0;\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 1;\n", indent))
	case "int8":
		buf.WriteString(fmt.Sprintf("%slet %s = data.get(pos).copied().unwrap_or(0) as i8;\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 1;\n", indent))
	case "int16":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i16::from_le_bytes([data[pos], data[pos+1]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 2;\n", indent))
	case "int32":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 4 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i32::from_le_bytes([data[pos], data[pos+1], data[pos+2], data[pos+3]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 4;\n", indent))
	case "int64":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 8 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i64::from_le_bytes(data[pos..pos+8].try_into().unwrap());\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 8;\n", indent))
	case "float32":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 4 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = f32::from_le_bytes([data[pos], data[pos+1], data[pos+2], data[pos+3]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 4;\n", indent))
	case "float64":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 8 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = f64::from_le_bytes(data[pos..pos+8].try_into().unwrap());\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += 8;\n", indent))
	case "string":
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet str_len = u16::from_le_bytes([data[pos], data[pos+1]]) as usize;\n", indent))
		buf.WriteString(fmt.Sprintf("%spos += 2;\n", indent))
		buf.WriteString(fmt.Sprintf("%sif data.len() < pos + str_len { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = std::str::from_utf8(&data[pos..pos+str_len]).map_err(|_| FFireError::InvalidUtf8)?.to_string();\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%spos += str_len;\n", indent))
	}
}

func generateRustDecodePrimitiveWithPos(buf *bytes.Buffer, typeName string, varName string, indent string) {
	switch typeName {
	case "bool":
		buf.WriteString(fmt.Sprintf("%slet %s = data.get(*pos).copied().unwrap_or(0) != 0;\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 1;\n", indent))
	case "int8":
		buf.WriteString(fmt.Sprintf("%slet %s = data.get(*pos).copied().unwrap_or(0) as i8;\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 1;\n", indent))
	case "int16":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i16::from_le_bytes([data[*pos], data[*pos+1]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 2;\n", indent))
	case "int32":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 4 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i32::from_le_bytes([data[*pos], data[*pos+1], data[*pos+2], data[*pos+3]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 4;\n", indent))
	case "int64":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 8 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = i64::from_le_bytes(data[*pos..*pos+8].try_into().unwrap());\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 8;\n", indent))
	case "float32":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 4 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = f32::from_le_bytes([data[*pos], data[*pos+1], data[*pos+2], data[*pos+3]]);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 4;\n", indent))
	case "float64":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 8 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = f64::from_le_bytes(data[*pos..*pos+8].try_into().unwrap());\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += 8;\n", indent))
	case "string":
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet str_len = u16::from_le_bytes([data[*pos], data[*pos+1]]) as usize;\n", indent))
		buf.WriteString(fmt.Sprintf("%s*pos += 2;\n", indent))
		buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + str_len { return Err(FFireError::BufferTooShort); }\n", indent))
		buf.WriteString(fmt.Sprintf("%slet %s = std::str::from_utf8(&data[*pos..*pos+str_len]).map_err(|_| FFireError::InvalidUtf8)?.to_string();\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s*pos += str_len;\n", indent))
	}
}

func generateRustDecodeArrayElements(buf *bytes.Buffer, elemType schema.Type, varName string, lenVar string, indent string) {
	switch t := elemType.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "bool":
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<bool> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    data.get(pos + i).copied().unwrap_or(0) != 0\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += %s;\n", indent, lenVar))
		case "int8":
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i8> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    data.get(pos + i).copied().unwrap_or(0) as i8\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += %s;\n", indent, lenVar))
		case "int16":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 2;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i16> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = pos + i * 2;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i16::from_le_bytes([data[off], data[off+1]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += byte_len;\n", indent))
		case "int32":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 4;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i32> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = pos + i * 4;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i32::from_le_bytes([data[off], data[off+1], data[off+2], data[off+3]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += byte_len;\n", indent))
		case "int64":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 8;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i64> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = pos + i * 8;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i64::from_le_bytes(data[off..off+8].try_into().unwrap())\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += byte_len;\n", indent))
		case "float32":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 4;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<f32> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = pos + i * 4;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    f32::from_le_bytes([data[off], data[off+1], data[off+2], data[off+3]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += byte_len;\n", indent))
		case "float64":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 8;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<f64> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = pos + i * 8;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    f64::from_le_bytes(data[off..off+8].try_into().unwrap())\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%spos += byte_len;\n", indent))
		case "string":
			buf.WriteString(fmt.Sprintf("%slet mut %s: Vec<String> = Vec::with_capacity(%s);\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%sfor _ in 0..%s {\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let str_len = u16::from_le_bytes([data[pos], data[pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    pos += 2;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < pos + str_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let s = std::str::from_utf8(&data[pos..pos+str_len]).map_err(|_| FFireError::InvalidUtf8)?.to_string();\n", indent))
			buf.WriteString(fmt.Sprintf("%s    pos += str_len;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    %s.push(s);\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}
	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%slet mut %s: Vec<%s> = Vec::with_capacity(%s);\n", indent, varName, t.Name, lenVar))
		buf.WriteString(fmt.Sprintf("%sfor _ in 0..%s {\n", indent, lenVar))
		buf.WriteString(fmt.Sprintf("%s    let item = %s::decode_from(data, &mut pos)?;\n", indent, t.Name))
		buf.WriteString(fmt.Sprintf("%s    %s.push(item);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
	}
}

func generateRustDecodeArrayElementsWithPos(buf *bytes.Buffer, elemType schema.Type, varName string, lenVar string, indent string) {
	switch t := elemType.(type) {
	case *schema.PrimitiveType:
		switch t.Name {
		case "bool":
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<bool> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    data.get(*pos + i).copied().unwrap_or(0) != 0\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += %s;\n", indent, lenVar))
		case "int8":
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i8> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    data.get(*pos + i).copied().unwrap_or(0) as i8\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += %s;\n", indent, lenVar))
		case "int16":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 2;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i16> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = *pos + i * 2;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i16::from_le_bytes([data[off], data[off+1]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += byte_len;\n", indent))
		case "int32":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 4;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i32> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = *pos + i * 4;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i32::from_le_bytes([data[off], data[off+1], data[off+2], data[off+3]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += byte_len;\n", indent))
		case "int64":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 8;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<i64> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = *pos + i * 8;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    i64::from_le_bytes(data[off..off+8].try_into().unwrap())\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += byte_len;\n", indent))
		case "float32":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 4;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<f32> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = *pos + i * 4;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    f32::from_le_bytes([data[off], data[off+1], data[off+2], data[off+3]])\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += byte_len;\n", indent))
		case "float64":
			buf.WriteString(fmt.Sprintf("%slet byte_len = %s * 8;\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%sif data.len() < *pos + byte_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%slet %s: Vec<f64> = (0..%s).map(|i| {\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%s    let off = *pos + i * 8;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    f64::from_le_bytes(data[off..off+8].try_into().unwrap())\n", indent))
			buf.WriteString(fmt.Sprintf("%s}).collect();\n", indent))
			buf.WriteString(fmt.Sprintf("%s*pos += byte_len;\n", indent))
		case "string":
			buf.WriteString(fmt.Sprintf("%slet mut %s: Vec<String> = Vec::with_capacity(%s);\n", indent, varName, lenVar))
			buf.WriteString(fmt.Sprintf("%sfor _ in 0..%s {\n", indent, lenVar))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < *pos + 2 { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let str_len = u16::from_le_bytes([data[*pos], data[*pos+1]]) as usize;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    *pos += 2;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    if data.len() < *pos + str_len { return Err(FFireError::BufferTooShort); }\n", indent))
			buf.WriteString(fmt.Sprintf("%s    let s = std::str::from_utf8(&data[*pos..*pos+str_len]).map_err(|_| FFireError::InvalidUtf8)?.to_string();\n", indent))
			buf.WriteString(fmt.Sprintf("%s    *pos += str_len;\n", indent))
			buf.WriteString(fmt.Sprintf("%s    %s.push(s);\n", indent, varName))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}
	case *schema.StructType:
		buf.WriteString(fmt.Sprintf("%slet mut %s: Vec<%s> = Vec::with_capacity(%s);\n", indent, varName, t.Name, lenVar))
		buf.WriteString(fmt.Sprintf("%sfor _ in 0..%s {\n", indent, lenVar))
		buf.WriteString(fmt.Sprintf("%s    let item = %s::decode_from(data, pos)?;\n", indent, t.Name))
		buf.WriteString(fmt.Sprintf("%s    %s.push(item);\n", indent, varName))
		buf.WriteString(fmt.Sprintf("%s}\n", indent))
	}
}

func getRustTypeString(t schema.Type) string {
	switch typ := t.(type) {
	case *schema.PrimitiveType:
		baseType := ""
		switch typ.Name {
		case "bool":
			baseType = "bool"
		case "int8":
			baseType = "i8"
		case "int16":
			baseType = "i16"
		case "int32":
			baseType = "i32"
		case "int64":
			baseType = "i64"
		case "float32":
			baseType = "f32"
		case "float64":
			baseType = "f64"
		case "string":
			baseType = "String"
		default:
			baseType = typ.Name
		}
		if typ.Optional {
			return fmt.Sprintf("Option<%s>", baseType)
		}
		return baseType
	case *schema.ArrayType:
		elemType := getRustTypeString(typ.ElementType)
		if typ.Optional {
			return fmt.Sprintf("Option<Vec<%s>>", elemType)
		}
		return fmt.Sprintf("Vec<%s>", elemType)
	case *schema.StructType:
		return typ.Name
	default:
		return "Unknown"
	}
}

// toSnakeCase converts CamelCase/camelCase to snake_case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteByte('_')
		}
		if r >= 'A' && r <= 'Z' {
			result.WriteByte(byte(r) + 32) // to lowercase
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}
