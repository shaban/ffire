# GitHub Copilot Instructions for ffire

## ⚠️ CRITICAL: Read Architecture YAML Before Any Changes

This embedded YAML is the **source of truth** for ffire's architecture. Consult it before modifying generators, benchmarks, or tests.

```yaml
# ffire Architecture Reference (Authoritative)

code_organization:
  generators:
    location: "pkg/generator/"
    pattern: "generator_{language}.go"
    reference_implementations: 
      - "generator_go.go"      # Tier A: Pure Go, most complete
      - "generator_swift.go"   # Tier B: Reference for FFI pattern
    c_abi: "generator_c_abi.go"  # Shared by all Tier B languages
    
  benchmarks:
    location: "pkg/benchmark/"
    pattern: "benchmark_{language}.go"
    coordinator: "benchmarks/magefile.go"
    
  test_data:
    schemas: "benchmarks/schemas/{name}.ffi"
    fixtures: "benchmarks/testdata/{schema_name}.json"
    generated: "benchmarks/generated/ffire_{lang}_{schema}/"
    
  tiers:
    tier_a: ["go", "cpp"]           # Self-contained, no C ABI
    tier_b: ["swift", "dart", "python", "javascript"]  # FFI to C ABI

build_system:
  task_runner: "magefile"
  location: "benchmarks/magefile.go"
  
  commands:
    generate_all: "mage genAll"
    generate_language: "mage gen{Lang}"  # genGo, genDart, genSwift, etc.
    run_all_benchmarks: "mage run{Lang}"  # runGo, runDart, etc.
    
  never_use_directly:
    - "go test ./..."
    - "dart test"
    - "swift test"
    - "pytest"
    reason: "Magefile coordinates cross-language execution and filtering"

schema_parsing:
  # Core variables extracted from .ffi schema files
  
  schema_package:
    field: "schema.Package"
    source: "package {name} declaration in .ffi file"
    purpose: "Module/namespace/library name for generated code"
    
    used_for:
      - "Import statements (import test, package:test/test.dart)"
      - "Library filenames (libtest.dylib, libtest.so)"
      - "Namespace declarations (namespace test)"
      - "Module names (module test)"
      
    never_use: "filename"
    example: "File struct.ffi with 'package test' → import test, NOT import struct"
    
  message_name:
    field: "msg.Name"
    source: "type {Name} struct declaration"
    purpose: "User's logical type name (without Message suffix)"
    
    used_for:
      - "Generating class names (Config → ConfigMessage)"
      - "Function names (EncodeConfigMessage, DecodeConfigMessage)"
      - "C ABI function prefixes (config_decode, config_encode)"
      
    transform: "Add Message suffix for classes, lowercase for C ABI"
    
  target_type:
    field: "msg.TargetType"
    type: "schema.Type (StructType | ArrayType | PrimitiveType)"
    purpose: "The actual type being serialized"
    
    used_for:
      - "Determining encoding/decoding logic"
      - "C++ function template selection"
      - "Type validation"
      
  struct_name:
    field: "structType.Name"
    purpose: "Name of embedded/helper struct (not a root message)"
    transform: "NO Message suffix for embedded types"
    example: "type Device struct (embedded) → struct Device"

naming_conventions:
  # Universal rules across all 11 language generators
  
  message_suffix:
    rule: "ALL generators MUST append 'Message' to root type names"
    
    rationale:
      - "Universal keyword collision avoidance (works in 11 languages)"
      - "Industry standard (protobuf, gRPC use Message terminology)"
      - "Clear boundary: generated ConfigMessage ≠ user's domain Config"
      - "Zero maintenance: no language-specific keyword lists"
      
    applies_to:
      - go
      - cpp
      - swift
      - dart
      - python
      - javascript
      - java
      - csharp
      - rust
      - ruby
      - php
      
    transformation:
      user_writes: "type Config struct { Host string; Port int32 }"
      generated_class: "ConfigMessage"
      generated_functions: 
        - "EncodeConfigMessage(msg *ConfigMessage) []byte"
        - "DecodeConfigMessage(data []byte) *ConfigMessage"
        
    exceptions:
      c_abi_functions:
        rule: "Use lowercase bare name (no Message suffix)"
        pattern: "{lowercase_name}_{action}"
        examples:
          - "config_decode(data, len, error)  // NOT configmessage_decode"
          - "config_encode(handle, out, error)"
          - "config_free(handle)"
        rationale: "C has no namespaces; flat global namespace requires short names"
        
  embedded_types:
    rule: "Helper/embedded structs use bare names (no Message suffix)"
    
    definition: "Types referenced by root messages but not root themselves"
    
    examples:
      root_type: "type Config struct → ConfigMessage"
      embedded_type: "type Device struct → Device (no suffix)"
      
    detection: "Type in schema.Types but not in schema.Messages"
    
  c_abi_naming:
    handle_type: "{Name}Handle"
    handle_impl: "{Name}HandleImpl"
    
    functions:
      decode: "{lowercase_name}_decode"
      encode: "{lowercase_name}_encode"
      free: "{lowercase_name}_free"
      free_data: "{lowercase_name}_free_data"
      free_error: "{lowercase_name}_free_error"
      
    example: "Config → ConfigHandle, config_decode, config_encode"
    
    note: "Handle type uses PascalCase, functions use snake_case"

language_paradigms:
  # How schema concepts map to each target language
  
  go:
    tier: "A"
    package_system: "Single package per schema"
    
    root_type:
      pattern: "type {Name}Message struct"
      example: "type ConfigMessage struct { Host string; Port int32 }"
      
    embedded_type:
      pattern: "type {Name} struct"
      example: "type Device struct { ID string }"
      
    encode_function:
      pattern: "func Encode{Name}Message(msg *{Name}Message) ([]byte, error)"
      example: "func EncodeConfigMessage(msg *ConfigMessage) ([]byte, error)"
      
    decode_function:
      pattern: "func Decode{Name}Message(data []byte) (*{Name}Message, error)"
      example: "func DecodeConfigMessage(data []byte) (*ConfigMessage, error)"
      
    package_declaration:
      pattern: "package {schema.Package}"
      example: "package test"
      
  cpp:
    tier: "A"
    header_guard: "{PACKAGE}_H"
    
    root_type:
      pattern: "struct {Name}Message"
      example: "struct ConfigMessage { std::string Host; int32_t Port; };"
      
    embedded_type:
      pattern: "struct {Name}"
      example: "struct Device { std::string ID; };"
      
    encode_function:
      pattern: "std::vector<uint8_t> encode_{lowercase_name}_message(const {Name}Message&)"
      example: "std::vector<uint8_t> encode_config_message(const ConfigMessage&)"
      
    decode_function:
      pattern: "{Name}Message decode_{lowercase_name}_message(const uint8_t*, size_t)"
      example: "ConfigMessage decode_config_message(const uint8_t*, size_t)"
      
    namespace:
      pattern: "namespace {schema.Package}"
      example: "namespace test"
      
  swift:
    tier: "B"
    ffi_binding: "C ABI via @_silgen_name"
    
    root_type:
      pattern: "public class {Name}Message"
      example: "public class ConfigMessage"
      
    encode_method:
      pattern: "func encode() -> Data"
      access: "Calls c_{lowercase_name}_encode internally"
      
    decode_method:
      pattern: "static func decode(_ data: Data) -> {Name}Message"
      access: "Calls c_{lowercase_name}_decode internally"
      
    module:
      pattern: "{schema.Package}"
      example: "module test"
      
    c_function_binding:
      pattern: "@_silgen_name(\"{lowercase_name}_decode\")"
      example: "@_silgen_name(\"config_decode\")"
      
    library_load:
      location: "Bundled in package Resources/"
      deployment: "Framework with embedded dylib (not system-wide)"
      
  dart:
    tier: "B"
    ffi_binding: "dart:ffi with DynamicLibrary"
    
    root_type:
      pattern: "class {Name}Message"
      example: "class ConfigMessage"
      
    encode_method:
      pattern: "Uint8List encode()"
      access: "FFI to {lowercase_name}_encode"
      
    decode_method:
      pattern: "static {Name}Message decode(Uint8List data)"
      access: "FFI to {lowercase_name}_decode"
      
    package_import:
      pattern: "package:{schema.Package}/{schema.Package}.dart"
      example: "package:test/test.dart"
      note: "Uses schema.Package, NOT filename"
      
    library_load:
      macos: "lib{schema.Package}.dylib"
      linux: "lib{schema.Package}.so"
      windows: "{schema.Package}.dll"
      location: "Relative path 'lib/' within package directory"
      deployment: "Bundled with package (not system-wide installation)"
      rationale: "Avoids naming conflicts, allows multiple ffire packages simultaneously"
      
    ffi_lookup:
      pattern: "_lib.lookup<NativeFunction<...>>('{lowercase_name}_{action}')"
      example: "_lib.lookup<...>('config_decode')"
      
  javascript:
    tier: "B"
    binding: "N-API (node-addon-api)"
    
    root_type:
      pattern: "class {Name}Message"
      example: "class ConfigMessage"
      
    encode_method:
      pattern: "encode() -> Buffer"
      implementation: "Calls addon.encode{Name}Message(this)"
      
    decode_method:
      pattern: "static decode(buffer) -> {Name}Message"
      implementation: "Calls addon.decode{Name}Message(buffer)"
      
    module_exports:
      pattern: "module.exports = { {Name}Message }"
      example: "module.exports = { ConfigMessage }"
      
    napi_functions:
      encode: "Napi::Value Encode{Name}Message(const Napi::CallbackInfo&)"
      decode: "Napi::Value Decode{Name}Message(const Napi::CallbackInfo&)"
      
    native_addon:
      location: "build/Release/{package}.node"
      deployment: "Compiled native addon bundled with npm package"
      note: "N-API bindings, not FFI to separate dylib"
      
  python:
    tier: "B"
    binding: "pybind11 (native C++ bindings)"
    
    root_type:
      pattern: "class {Name}Message"
      example: "class ConfigMessage"
      note: "Only struct-based root messages are bound as classes"
      limitation: "Array/primitive root messages not yet supported in pybind11 bindings"
      
    encode_decode:
      pattern: "Standalone module functions (NOT class methods)"
      encode: "{lowercase_name}_encode(msg) -> bytes"
      decode: "{lowercase_name}_decode(data) -> {Name}Message"
      example: "config_encode(msg), config_decode(data)"
      note: "Functions are module-level, not instance or class methods"
      
    critical_api_design:
      wrong: "msg = ConfigMessage.decode(data); encoded = msg.encode()"
      correct: "msg = config_decode(data); encoded = config_encode(msg)"
      reason: "Python uses standalone functions, not class/instance methods"
      historical: "Always been this way since pybind11 introduction"
      
    package_import:
      pattern: "from {schema.Package} import {Name}Message, {lowercase_name}_decode, {lowercase_name}_encode"
      example: "from test import ConfigMessage, config_decode, config_encode"
      note: "Package name from schema, NOT filename"
      
  c_abi:
    purpose: "FFI layer for Tier B languages (Swift, Dart, Python, JavaScript)"
    
    handle_type:
      pattern: "typedef void* {Name}Handle"
      example: "typedef void* ConfigHandle"
      opaque: true
      
    decode_function:
      signature: "{Name}Handle {lowercase_name}_decode(const uint8_t* data, size_t len, char** error_msg)"
      example: "ConfigHandle config_decode(const uint8_t* data, size_t len, char** error_msg)"
      returns: "Opaque handle or NULL on error"
      
    encode_function:
      signature: "size_t {lowercase_name}_encode({Name}Handle handle, uint8_t** out_data, char** error_msg)"
      example: "size_t config_encode(ConfigHandle handle, uint8_t** out_data, char** error_msg)"
      returns: "Size of encoded data or 0 on error"
      
    free_functions:
      handle: "void {lowercase_name}_free({Name}Handle handle)"
      data: "void {lowercase_name}_free_data(uint8_t* data)"
      error: "void {lowercase_name}_free_error(char* error_msg)"
      
    no_message_suffix: "C ABI function names use bare name, not {Name}Message"
    
    keyword_collision_safety:
      risk: "C keywords as type names could collide (e.g., type Register → register_decode)"
      current_status: "Not implemented - C compiler will error if collision occurs"
      recommended_fix: "Detect C keywords, append '_msg' suffix: register_msg_decode"
      implementation: "pkg/generator/keywords.go has merged C+Go keyword list (37 keywords)"
      detection_function: "IsCOrGoKeyword(name string) bool"
      note: "C+Go keywords merged for single source of truth; type collisions handled by Message suffix"

validation:
  # Checklist before claiming a task is complete
  
  before_modifying_generator:
    - "Read reference implementation (generator_go.go or generator_swift.go)"
    - "Verify change against this YAML naming_conventions section"
    - "Check language_paradigms mapping for target language"
    - "Ensure Message suffix on root types (except C ABI functions)"
    
  before_committing_generator:
    - "Run: mage genAll (generate all 10 benchmark schemas)"
    - "Run: mage run{Lang} (execute all benchmarks for language)"
    - "Verify all 10 schemas pass (not just struct)"
    - "Check generated code has Message suffix on classes"
    - "Check C ABI calls use lowercase bare names"
    
  architecture_compliance:
    message_suffix:
      check: "Generated class name is {Name}Message, not {Name}"
      violation_example: "class Config (WRONG) instead of class ConfigMessage (CORRECT)"
      
    package_naming:
      check: "Imports use schema.Package, not filename"
      violation_example: "import struct (WRONG) instead of import test (CORRECT)"
      
    c_abi_naming:
      check: "C functions are {lowercase}_action, not {lowercase}message_action"
      violation_example: "configmessage_decode (WRONG) instead of config_decode (CORRECT)"
      
  known_architectural_violations:
    cpp_generator:
      file: "pkg/generator/generator_cpp.go"
      issue: "FIXED: Previously generated 'struct Config', now generates 'struct ConfigMessage'"
      fix: "Merged root messages into topological sort for proper dependency ordering"
      status: "✅ fixed"
      
    dart_generator:
      file: "pkg/generator/generator_dart.go"
      issue: "FIXED: Previously generated 'class Config', now generates 'class ConfigMessage'"
      status: "✅ fixed"
      
    python_pybind11_generator:
      file: "pkg/generator/generator_python_pybind11.go"
      issue: "FIXED: Now generates 'class ConfigMessage' and exports properly"
      fix: "Separated root message types from embedded types in __init__.py exports"
      limitation: "Only struct-based root messages supported (array/primitive not bound)"
      status: "✅ fixed (with limitations)"
      
    python_benchmark:
      file: "pkg/benchmark/benchmark_python.go"
      issue: "FIXED: Benchmark now uses standalone functions and schema.Package"
      fix: "Changed from ConfigMessage.decode() to config_decode(), uses schema.Package not filename"
      status: "✅ fixed"

workflows:
  # Step-by-step procedures for common tasks
  
  adding_new_generator:
    steps:
      - "Copy structure from pkg/generator/generator_go.go (reference)"
      - "Follow language_paradigms.{target_lang} mapping from this YAML"
      - "Ensure Message suffix: className := msg.Name + 'Message'"
      - "C ABI access: baseName := strings.ToLower(msg.Name)  // no Message"
      - "Add generator to cmd/ffire/gen.go switch statement"
      - "Create pkg/benchmark/benchmark_{lang}.go"
      - "Add to benchmarks/magefile.go (gen{Lang} and run{Lang} targets)"
      - "Test: mage gen{Lang} && mage run{Lang}"
      - "Verify all 10 benchmark schemas pass"
      
  debugging_benchmark_failure:
    decision_tree:
      - "Check: Does generated class have Message suffix?"
      - "  NO → Generator is broken, fix generator_{lang}.go"
      - "  YES → Continue"
      - "Check: Do C ABI calls use lowercase bare name?"
      - "  NO → C ABI generator is broken"
      - "  YES → Continue"
      - "Check: Does import use schema.Package?"
      - "  NO → Generator using filename, fix to use schema.Package"
      - "  YES → Continue"
      - "Check (Python): Does benchmark use standalone functions?"
      - "  NO → Benchmark using class methods, fix to use module functions"
      - "  YES → Investigate further"
      
    common_mistakes:
      - "Benchmark expects ConfigMessage but generator produces Config"
      - "Import uses filename 'struct' instead of package name 'test'"
      - "C ABI lookup uses 'configmessage_decode' instead of 'config_decode'"
      - "Python benchmark uses ConfigMessage.decode() instead of config_decode()"
      
  fixing_name_collision:
    correct_approach:
      - "DO NOT add language-specific keyword lists"
      - "Message suffix should prevent all collisions"
      - "If collision occurs with Message suffix, architecture is broken"
      
    incorrect_approach:
      - "Adding keyword detection: if name == 'struct' then name += 'Type'"
      - "Per-language suffixes: Swift adds 'Type', Dart adds 'Class'"
      - "These create inconsistency across languages"
      
  updating_architecture:
    steps:
      - "Update this .copilot-instructions.md YAML (source of truth)"
      - "Regenerate docs/ from YAML facts"
      - "Update affected generators to match YAML"
      - "Run full test suite: mage genAll && test all languages"
      - "Update known_architectural_violations if bugs remain"

keyword_handling:
  # How keywords are managed across languages
  
  overview: "Three distinct keyword purposes - do NOT conflate them"
  
  c_and_go_keywords:
    location: "pkg/generator/keywords.go"
    variable: "cAndGoKeywords (37 keywords)"
    function: "IsCOrGoKeyword(name string) bool"
    
    purpose: "C ABI function prefix collision detection"
    applies_to: "C ABI function names ONLY"
    
    why_merged:
      - "C and Go share 28/37 keywords (significant overlap)"
      - "Both languages need same collision handling"
      - "Single source of truth reduces maintenance"
      - "Go generator can also benefit from detection"
      
    usage_example:
      problem: "type Register struct → register_decode() (C keyword collision)"
      detection: "IsCOrGoKeyword('register') → true"
      fix: "register_msg_decode() (append _msg suffix)"
      
    status: "Created but not yet implemented in generators"
    
  swift_module_keywords:
    location: "pkg/generator/generator_swift.go"
    variable: "swiftModuleKeywords (26 keywords)"
    function: "SanitizeSwiftModuleName(name string) string"
    
    purpose: "Swift module/package name collision avoidance"
    applies_to: "module/package names ONLY (NOT type names)"
    
    why_separate_from_c_go:
      - "Serves completely different purpose (module names vs function names)"
      - "Swift keywords don't apply to C ABI"
      - "Type names already protected by Message suffix"
      
    usage_example:
      problem: "package struct → module struct (Swift keyword collision)"
      detection: "swiftModuleKeywords['struct'] → true"
      fix: "module structModule (append Module suffix)"
      
    not_used_for: "Type names (ConfigMessage works fine even if 'config' were a keyword)"
    
  type_name_keywords:
    approach: "NO keyword lists needed"
    reason: "Message suffix handles ALL type name collisions universally"
    
    why_this_works:
      - "User writes: type Config struct"
      - "Generated: ConfigMessage (never collides)"
      - "Works in all 11 languages simultaneously"
      - "Zero language-specific handling required"
      
    anti_pattern: "DO NOT create per-language type keyword lists"
    
  summary:
    c_go_keywords: "For C ABI function names (register_decode collision)"
    swift_keywords: "For Swift module names (module struct collision)"
    type_keywords: "Not needed (Message suffix handles all)"

red_flags:
  # Indicators that you're violating architecture - STOP and consult this file
  
  - symptom: "Generating class without Message suffix"
    example: "class Config { ... }"
    correct: "class ConfigMessage { ... }"
    action: "Add Message suffix to className"
    
  - symptom: "Benchmark expects bare name"
    example: "final msg = Config.decode(data)"
    correct: "final msg = ConfigMessage.decode(data)"
    action: "Check if generator is producing wrong name"
    
  - symptom: "Python benchmark using class methods for encode/decode"
    example: "msg = ConfigMessage.decode(data); encoded = msg.encode()"
    correct: "msg = config_decode(data); encoded = config_encode(msg)"
    action: "Python uses standalone functions, not methods"
    
  - symptom: "Using filename instead of schema.Package"
    example: "import 'package:struct/struct.dart'"
    correct: "import 'package:test/test.dart'"
    action: "Use schema.Package not schemaName"
    
  - symptom: "C ABI function has Message suffix"
    example: "configmessage_decode(data, len)"
    correct: "config_decode(data, len)"
    action: "Use lowercase bare name for C ABI"
    
  - symptom: "Adding language-specific keyword handling"
    example: "if swiftKeywords[name] { name += 'Type' }"
    correct: "className := msg.Name + 'Message'  // Universal"
    action: "Remove keyword list, use Message suffix"
    
  - symptom: "Testing only 1 schema"
    example: "mage genDart struct && test struct only"
    correct: "mage genDart && mage runDart  // All 10 schemas"
    action: "Test all benchmark schemas"
    
  - symptom: "Using 'go test' or language runner directly"
    example: "cd generated/ffire_dart_struct && dart test"
    correct: "mage runDart  // From benchmarks/ directory"
    action: "Use magefile for coordination"

library_deployment:
  # How native libraries are bundled and loaded
  
  strategy: "Bundled deployment (not system-wide installation)"
  
  rationale:
    - "Avoids naming conflicts between different ffire packages"
    - "Allows multiple schemas/packages in same application"
    - "No admin privileges needed for installation"
    - "Each package is self-contained"
    
  per_language:
    dart:
      location: "lib/ directory within package"
      load_path: "DynamicLibrary.open('lib/lib{package}.dylib')"
      relative_to: "Package root directory"
      
    swift:
      location: "Resources/ within framework bundle"
      load_path: "Bundle.main.path(forResource: ...)"
      deployment: "Framework with embedded dylib"
      
    python:
      location: "Package directory (site-packages/{package}/)"
      load_path: "ctypes.CDLL(os.path.join(pkg_dir, 'lib{package}.dylib'))"
      relative_to: "Python package installation directory"
      
    javascript:
      location: "build/Release/{package}.node"
      load_path: "require('./build/Release/{package}.node')"
      note: "N-API native addon, not separate dylib"
      
  library_naming:
    pattern: "lib{schema.Package}.{ext}"
    macos: "lib{package}.dylib"
    linux: "lib{package}.so"
    windows: "{package}.dll"
    note: "Uses schema.Package name, NOT filename"
    
  system_wide_installation:
    supported: false
    reason: "Would cause naming conflicts if multiple packages use same schema.Package"
    alternative: "Each package bundles its own dylib copy"

testing:
  # How testing is organized in ffire
  
  benchmark_schemas:
    location: "benchmarks/schemas/"
    count: 10
    names:
      - "struct.ffi"       # Simple struct
      - "array_float.ffi"  # Primitive array
      - "array_int.ffi"    # Primitive array
      - "array_string.ffi" # String array
      - "array_struct.ffi" # Struct array
      - "complex.ffi"      # Complex nested
      - "empty.ffi"        # Empty message
      - "nested.ffi"       # Nested structs
      - "optional.ffi"     # Optional fields
      - "tags.ffi"         # Field tags
      
    purpose: "Cover all wire format features"
    requirement: "ALL generators must pass all 10 schemas"
    
  fixture_data:
    location: "benchmarks/testdata/"
    pattern: "{schema_name}.json"
    purpose: "Consistent test data across languages"
    
  generated_benchmarks:
    location: "benchmarks/generated/"
    pattern: "ffire_{lang}_{schema}/"
    structure:
      go: "ffire_{schema}/"           # No language prefix for Go
      others: "ffire_{lang}_{schema}/"  # e.g., ffire_dart_struct/
      
  execution:
    coordinator: "benchmarks/magefile.go"
    parallel: false
    per_language: true
    output: "JSON format for consistency"
```

---

## How to Use This File

### Before Making Changes

1. **Read the relevant YAML section** for your task
2. **Check reference implementations** (Go or Swift generator)
3. **Follow the workflows** section for step-by-step guidance
4. **Check RELEASE_ROADMAP.md** for current priorities and next tasks

### When Something Breaks

1. **Consult red_flags** section - likely violation is listed
2. **Check validation** section for compliance checklist
3. **Review language_paradigms** for correct pattern

### Updating Architecture

1. **Update this YAML first** (source of truth)
2. **Then update docs/** with full rationale
3. **Then update code** to match YAML
4. **Update known_architectural_violations** if bugs remain

### Project Roadmap

**Next Tasks**: See `/Users/shaban/Code/ffire/RELEASE_ROADMAP.md`
- Comprehensive release plan with 6 phases
- 61 total tasks with testable verification criteria
- Current focus: Phase 1 (Stabilization)
- Each task has specific commit message template

---

## Quick Reference

**Message Suffix Rule:**
```
User writes: type Config struct
Generated:   class ConfigMessage  (ALL languages)
C ABI:       config_decode()     (lowercase, no suffix)
```

**Package Naming:**
```
File: struct.ffi
Declares: package test
Import: test (NOT struct)
Library: libtest.dylib (NOT libstruct.dylib)
```

**Library Deployment:**
```
Strategy: Bundled (not system-wide)
Location: lib/ within package directory
Load: DynamicLibrary.open('lib/libtest.dylib')  // Relative path
Why: Avoids conflicts, allows multiple ffire packages
```

**Keyword Handling:**
```
C+Go Keywords:   pkg/generator/keywords.go (37 keywords, for C ABI function names)
Swift Keywords:  generator_swift.go swiftModuleKeywords (26 keywords, for module names ONLY)
Type Keywords:   Not needed (Message suffix handles all type collisions)
Status:          Created but not yet implemented in generators
```

**Testing:**
```bash
mage genAll      # Generate all languages × all schemas
mage runGo       # Test Go benchmarks
mage runDart     # Test Dart benchmarks
mage runSwift    # Test Swift benchmarks
```

---

## Current Status

**✅ Architecture-Compliant:**
- Go generator (reference implementation)
- C++ generator (struct {Name}Message with topological sort)
- Swift generator (Tier B reference)
- Dart generator (class {Name}Message)
- Python pybind11 generator (class {Name}Message for struct types only)
- JavaScript generator (class {Name}Message)
- C ABI generator (bare lowercase names)

**⚠️ Known Limitations:**
- Python pybind11: Only struct-based root messages supported (6/10 benchmarks fail on array/primitive types)
  - Works: struct, nested, empty, tags
  - Fails: array_float, array_int, array_string, array_struct, complex, optional
  - Reason: pybind11 bindings only generated for struct types, not arrays/primitives

**Testing Commands:**
```bash
# From benchmarks/ directory
mage genAll      # Generate all languages × all schemas
mage bench       # Full workflow: generate + run + compare
mage run{Lang}   # Run specific language (runGo, runCpp, runSwift, etc.)
```

**Benchmark Results:**
- Go: 10/10 ✅
- C++: 10/10 ✅
- Swift: 10/10 ✅
- Dart: 10/10 ✅
- JavaScript: 10/10 ✅
- Python: 4/10 (struct types only)
