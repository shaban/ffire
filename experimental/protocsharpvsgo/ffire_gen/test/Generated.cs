// Code generated by ffire. DO NOT EDIT.

using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Test
{
    internal struct Parameter
    {
        public string DisplayName { get; set; }
        public float DefaultValue { get; set; }
        public float CurrentValue { get; set; }
        public int Address { get; set; }
        public float MaxValue { get; set; }
        public float MinValue { get; set; }
        public string Unit { get; set; }
        public string Identifier { get; set; }
        public bool CanRamp { get; set; }
        public bool IsWritable { get; set; }
        public long RawFlags { get; set; }
        public string[] IndexedValues { get; set; }
        public string? IndexedValuesSource { get; set; }

        public byte[] Encode()
        {
            int size = ComputeSize();
            byte[] buffer = new byte[size];
            Span<byte> span = buffer;
            int offset = 0;
            EncodeTo(span, ref offset);
            return buffer;
        }

        public static Parameter Decode(byte[] data)
        {
            ReadOnlySpan<byte> span = data;
            int offset = 0;
            return DecodeFrom(span, ref offset);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int ComputeSize()
        {
            int size = 0;
            size += 2 + Encoding.UTF8.GetByteCount(DisplayName ?? "");
            size += 4;
            size += 4;
            size += 4;
            size += 4;
            size += 4;
            size += 2 + Encoding.UTF8.GetByteCount(Unit ?? "");
            size += 2 + Encoding.UTF8.GetByteCount(Identifier ?? "");
            size += 1;
            size += 1;
            size += 8;
            size += 1;
            if (IndexedValues != null)
            {
                size += 2;
                foreach (var item in IndexedValues)
                {
                    size += 2 + Encoding.UTF8.GetByteCount(item);
                }
            }
            size += 1;
            if (IndexedValuesSource != null)
            {
                size += 2 + Encoding.UTF8.GetByteCount(IndexedValuesSource);
            }
            return size;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void EncodeTo(Span<byte> buffer, ref int offset)
        {
            int strLen = Encoding.UTF8.GetByteCount(DisplayName ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(DisplayName ?? "", buffer.Slice(offset));
            offset += strLen;
            BinaryPrimitives.WriteSingleLittleEndian(buffer.Slice(offset, 4), DefaultValue);
            offset += 4;
            BinaryPrimitives.WriteSingleLittleEndian(buffer.Slice(offset, 4), CurrentValue);
            offset += 4;
            BinaryPrimitives.WriteInt32LittleEndian(buffer.Slice(offset, 4), Address);
            offset += 4;
            BinaryPrimitives.WriteSingleLittleEndian(buffer.Slice(offset, 4), MaxValue);
            offset += 4;
            BinaryPrimitives.WriteSingleLittleEndian(buffer.Slice(offset, 4), MinValue);
            offset += 4;
            int strLen = Encoding.UTF8.GetByteCount(Unit ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(Unit ?? "", buffer.Slice(offset));
            offset += strLen;
            int strLen = Encoding.UTF8.GetByteCount(Identifier ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(Identifier ?? "", buffer.Slice(offset));
            offset += strLen;
            buffer[offset++] = (byte)(CanRamp ? 1 : 0);
            buffer[offset++] = (byte)(IsWritable ? 1 : 0);
            BinaryPrimitives.WriteInt64LittleEndian(buffer.Slice(offset, 8), RawFlags);
            offset += 8;
            if (IndexedValues != null)
            {
                buffer[offset++] = 1;
                BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)IndexedValues.Length);
                offset += 2;
                foreach (var item in IndexedValues)
                {
                    int strLen = Encoding.UTF8.GetByteCount(item ?? "");
                    BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
                    offset += 2;
                    Encoding.UTF8.GetBytes(item ?? "", buffer.Slice(offset));
                    offset += strLen;
                }
            }
            else
            {
                buffer[offset++] = 0;
            }
            if (IndexedValuesSource != null)
            {
                buffer[offset++] = 1;
                int strLen = Encoding.UTF8.GetByteCount(IndexedValuesSource ?? "");
                BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
                offset += 2;
                Encoding.UTF8.GetBytes(IndexedValuesSource ?? "", buffer.Slice(offset));
                offset += strLen;
            }
            else
            {
                buffer[offset++] = 0;
            }
        }

        internal static Parameter DecodeFrom(ReadOnlySpan<byte> buffer, ref int offset)
        {
            var obj = new Parameter();
            obj.DisplayName = FFireHelpers.DecodeString(buffer, ref offset);
            obj.DefaultValue = BinaryPrimitives.ReadSingleLittleEndian(buffer.Slice(offset, 4)); offset += 4;
            obj.CurrentValue = BinaryPrimitives.ReadSingleLittleEndian(buffer.Slice(offset, 4)); offset += 4;
            obj.Address = BinaryPrimitives.ReadInt32LittleEndian(buffer.Slice(offset, 4)); offset += 4;
            obj.MaxValue = BinaryPrimitives.ReadSingleLittleEndian(buffer.Slice(offset, 4)); offset += 4;
            obj.MinValue = BinaryPrimitives.ReadSingleLittleEndian(buffer.Slice(offset, 4)); offset += 4;
            obj.Unit = FFireHelpers.DecodeString(buffer, ref offset);
            obj.Identifier = FFireHelpers.DecodeString(buffer, ref offset);
            obj.CanRamp = buffer[offset++] != 0;
            obj.IsWritable = buffer[offset++] != 0;
            obj.RawFlags = BinaryPrimitives.ReadInt64LittleEndian(buffer.Slice(offset, 8)); offset += 8;
            if (buffer[offset++] == 1)
            {
                int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));
                offset += 2;
                obj.IndexedValues = new string[length];
                for (int i = 0; i < length; i++)
                {
                    obj.IndexedValues[i] = FFireHelpers.DecodeString(buffer, ref offset);
                }
            }
            if (buffer[offset++] == 1)
            {
                obj.IndexedValuesSource = FFireHelpers.DecodeString(buffer, ref offset);
            }
            return obj;
        }
    }

    internal struct Plugin
    {
        public string Name { get; set; }
        public string ManufacturerID { get; set; }
        public string Type { get; set; }
        public string Subtype { get; set; }
        public Parameter[] Parameters { get; set; }

        public byte[] Encode()
        {
            int size = ComputeSize();
            byte[] buffer = new byte[size];
            Span<byte> span = buffer;
            int offset = 0;
            EncodeTo(span, ref offset);
            return buffer;
        }

        public static Plugin Decode(byte[] data)
        {
            ReadOnlySpan<byte> span = data;
            int offset = 0;
            return DecodeFrom(span, ref offset);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int ComputeSize()
        {
            int size = 0;
            size += 2 + Encoding.UTF8.GetByteCount(Name ?? "");
            size += 2 + Encoding.UTF8.GetByteCount(ManufacturerID ?? "");
            size += 2 + Encoding.UTF8.GetByteCount(Type ?? "");
            size += 2 + Encoding.UTF8.GetByteCount(Subtype ?? "");
            size += 2;
            if (Parameters != null)
            {
                foreach (var item in Parameters)
                {
                    size += item.ComputeSize();
                }
            }
            return size;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void EncodeTo(Span<byte> buffer, ref int offset)
        {
            int strLen = Encoding.UTF8.GetByteCount(Name ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(Name ?? "", buffer.Slice(offset));
            offset += strLen;
            int strLen = Encoding.UTF8.GetByteCount(ManufacturerID ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(ManufacturerID ?? "", buffer.Slice(offset));
            offset += strLen;
            int strLen = Encoding.UTF8.GetByteCount(Type ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(Type ?? "", buffer.Slice(offset));
            offset += strLen;
            int strLen = Encoding.UTF8.GetByteCount(Subtype ?? "");
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)strLen);
            offset += 2;
            Encoding.UTF8.GetBytes(Subtype ?? "", buffer.Slice(offset));
            offset += strLen;
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)(Parameters?.Length ?? 0));
            offset += 2;
            if (Parameters != null)
            {
                foreach (var item in Parameters)
                {
                    item.EncodeTo(buffer, ref offset);
                }
            }
        }

        internal static Plugin DecodeFrom(ReadOnlySpan<byte> buffer, ref int offset)
        {
            var obj = new Plugin();
            obj.Name = FFireHelpers.DecodeString(buffer, ref offset);
            obj.ManufacturerID = FFireHelpers.DecodeString(buffer, ref offset);
            obj.Type = FFireHelpers.DecodeString(buffer, ref offset);
            obj.Subtype = FFireHelpers.DecodeString(buffer, ref offset);
            int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));
            offset += 2;
            obj.Parameters = new Parameter[length];
            for (int i = 0; i < length; i++)
            {
                obj.Parameters[i] = Parameter.DecodeFrom(buffer, ref offset);
            }
            return obj;
        }
    }

    public struct PluginListMessage
    {
        public Plugin[]? Items { get; set; }

        public byte[] Encode()
        {
            int size = ComputeSize();
            byte[] buffer = new byte[size];
            Span<byte> span = buffer;
            int offset = 0;
            EncodeTo(span, ref offset);
            return buffer;
        }

        public static PluginListMessage Decode(byte[] data)
        {
            ReadOnlySpan<byte> span = data;
            int offset = 0;
            return DecodeFrom(span, ref offset);
        }

        internal int ComputeSize()
        {
            int size = 2; // array length
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    size += item.ComputeSize();
                }
            }
            return size;
        }

        internal void EncodeTo(Span<byte> buffer, ref int offset)
        {
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(offset, 2), (ushort)(Items?.Length ?? 0));
            offset += 2;
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    item.EncodeTo(buffer, ref offset);
                }
            }
        }

        internal static PluginListMessage DecodeFrom(ReadOnlySpan<byte> buffer, ref int offset)
        {
            var obj = new PluginListMessage();
            int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));
            offset += 2;
            obj.Items = new Plugin[length];
            for (int i = 0; i < length; i++)
            {
                obj.Items[i] = Plugin.DecodeFrom(buffer, ref offset);
            }
            return obj;
        }
    }

    internal static class FFireHelpers
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static string DecodeString(ReadOnlySpan<byte> buffer, ref int offset)
        {
            int length = BinaryPrimitives.ReadUInt16LittleEndian(buffer.Slice(offset, 2));
            offset += 2;
            string result = Encoding.UTF8.GetString(buffer.Slice(offset, length));
            offset += length;
            return result;
        }
    }

}
