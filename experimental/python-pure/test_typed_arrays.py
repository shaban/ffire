#!/usr/bin/env python3
"""
Test generated pure Python code with typed arrays to verify type safety.
"""

import array
import sys

# Code generated by ffire. DO NOT EDIT.
# Pure Python implementation - no native bindings

import struct
import array
from typing import Optional, List

# [Encoder and Decoder classes would be here - using from test_primitives.py logic]

class Encoder:
    def __init__(self, estimated_size=256):
        self.buffer = bytearray(estimated_size)
        self.pos = 0

    def ensure_capacity(self, needed):
        if self.pos + needed > len(self.buffer):
            new_size = max(len(self.buffer) * 2, self.pos + needed)
            self.buffer.extend(bytearray(new_size - len(self.buffer)))

    def to_bytes(self):
        return bytes(self.buffer[:self.pos])

    def write_int16(self, v):
        self.ensure_capacity(2)
        struct.pack_into('<H', self.buffer, self.pos, v)
        self.pos += 2

    def write_int32_array(self, arr):
        """Zero-copy write for typed int32 array"""
        if not isinstance(arr, array.array) or arr.typecode != 'i':
            arr = array.array('i', arr)  # Convert to typed array
        byte_len = len(arr) * 4
        self.ensure_capacity(byte_len)
        mv = memoryview(arr).cast('B')  # Zero-copy view
        self.buffer[self.pos:self.pos+byte_len] = mv
        self.pos += byte_len

    def write_float32_array(self, arr):
        """Zero-copy write for typed float32 array"""
        if not isinstance(arr, array.array) or arr.typecode != 'f':
            arr = array.array('f', arr)
        byte_len = len(arr) * 4
        self.ensure_capacity(byte_len)
        mv = memoryview(arr).cast('B')
        self.buffer[self.pos:self.pos+byte_len] = mv
        self.pos += byte_len


class Decoder:
    def __init__(self, data):
        self.data = data
        self.pos = 0

    def read_array_length(self):
        length = struct.unpack_from('<H', self.data, self.pos)[0]
        self.pos += 2
        return length

    def read_int32_array(self, length):
        """Zero-copy read returning typed int32 array"""
        byte_len = length * 4
        mv = memoryview(self.data)[self.pos:self.pos+byte_len]
        arr = array.array('i')
        arr.frombytes(mv)
        self.pos += byte_len
        return arr  # Returns typed array.array('i')

    def read_float32_array(self, length):
        """Zero-copy read returning typed float32 array"""
        byte_len = length * 4
        mv = memoryview(self.data)[self.pos:self.pos+byte_len]
        arr = array.array('f')
        arr.frombytes(mv)
        self.pos += byte_len
        return arr  # Returns typed array.array('f')


# Test message class
class AudioBuffer:
    def __init__(self, samples: array.array = None, sampleRate: int = 44100):
        self.samples = samples if samples is not None else array.array('f')
        self.sampleRate = sampleRate

    def encode(self) -> bytes:
        enc = Encoder()
        enc.write_int16(len(self.samples))
        enc.write_float32_array(self.samples)
        return enc.to_bytes()

    @staticmethod
    def decode(data):
        dec = Decoder(data)
        obj = AudioBuffer()
        length = dec.read_array_length()
        obj.samples = dec.read_float32_array(length)  # Returns array.array('f')
        return obj


def test_typed_array_type_safety():
    """Verify typed arrays maintain type safety"""
    print("=== Testing Typed Array Type Safety ===\n")

    # Create audio buffer with typed float32 array
    samples = array.array('f', [0.0, 0.1, 0.2, 0.3, 0.4, 0.5])
    buffer = AudioBuffer(samples)

    print(f"Original type: {type(buffer.samples)}")
    print(f"Original typecode: {buffer.samples.typecode}")
    print(f"Original samples: {list(buffer.samples)}")

    # Encode
    encoded = buffer.encode()
    print(f"\nEncoded: {encoded.hex()} ({len(encoded)} bytes)")

    # Decode
    decoded = AudioBuffer.decode(encoded)
    print(f"\nDecoded type: {type(decoded.samples)}")
    print(f"Decoded typecode: {decoded.samples.typecode}")
    print(f"Decoded samples: {list(decoded.samples)}")

    # Verify type safety
    assert isinstance(decoded.samples, array.array), "Should return array.array, not list"
    assert decoded.samples.typecode == 'f', "Should be float32 array (typecode 'f')"
    assert list(decoded.samples) == list(samples), "Values should match"

    print("\n✅ Type safety verified!")
    print(f"   - Decoded as array.array (not generic list)")
    print(f"   - Typecode preserved: '{decoded.samples.typecode}'")
    print(f"   - Zero-copy operations maintained type information")

    return True


def test_type_coercion():
    """Test that regular lists are converted to typed arrays"""
    print("\n=== Testing Type Coercion ===\n")

    # Start with a regular Python list
    regular_list = [1, 2, 3, 4, 5]
    print(f"Input type: {type(regular_list)}")

    # Create buffer with regular list (should be converted)
    buffer = AudioBuffer(array.array('f', regular_list))

    # Encode and decode
    encoded = buffer.encode()
    decoded = AudioBuffer.decode(encoded)

    print(f"Output type: {type(decoded.samples)}")
    print(f"Output typecode: {decoded.samples.typecode}")

    assert isinstance(decoded.samples, array.array), "Should convert to typed array"
    assert decoded.samples.typecode == 'f', "Should have correct typecode"

    print("\n✅ Type coercion works!")
    print(f"   - Regular list → array.array('f')")
    print(f"   - Type safety enforced during encoding")

    return True


def test_int32_typed_arrays():
    """Test int32 typed arrays"""
    print("\n=== Testing int32 Typed Arrays ===\n")

    class IntArray:
        def __init__(self, values: array.array = None):
            self.values = values if values is not None else array.array('i')

        def encode(self) -> bytes:
            enc = Encoder()
            enc.write_int16(len(self.values))
            enc.write_int32_array(self.values)
            return enc.to_bytes()

        @staticmethod
        def decode(data):
            dec = Decoder(data)
            obj = IntArray()
            length = dec.read_array_length()
            obj.values = dec.read_int32_array(length)  # Returns array.array('i')
            return obj

    # Test with int32 array
    values = array.array('i', range(1000))
    msg = IntArray(values)

    print(f"Type: {type(msg.values)}, typecode: {msg.values.typecode}")
    print(f"Element count: {len(msg.values)}")

    encoded = msg.encode()
    decoded = IntArray.decode(encoded)

    print(f"Decoded type: {type(decoded.values)}, typecode: {decoded.values.typecode}")

    assert isinstance(decoded.values, array.array), "Should be array.array"
    assert decoded.values.typecode == 'i', "Should be int32 (typecode 'i')"
    assert list(decoded.values) == list(values), "Values should match"

    print("\n✅ int32 arrays work correctly!")

    return True


if __name__ == "__main__":
    print(f"Python version: {sys.version}\n")

    try:
        test_typed_array_type_safety()
        test_type_coercion()
        test_int32_typed_arrays()

        print("\n" + "="*60)
        print("✅ ALL TESTS PASSED!")
        print("="*60)
        print("\nPure Python codec maintains type safety:")
        print("  - Returns array.array (typed arrays), not generic lists")
        print("  - Preserves typecode ('i' for int32, 'f' for float32, etc.)")
        print("  - Zero-copy operations maintain type information")
        print("  - Automatic type coercion from lists when needed")
    except AssertionError as e:
        print(f"\n❌ TEST FAILED: {e}")
        sys.exit(1)
