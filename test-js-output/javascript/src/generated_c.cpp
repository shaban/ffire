// Code generated by ffire. DO NOT EDIT.

#include "generated_c.h"
#include "generated.hpp"
#include <cstring>

// Internal wrapper structs
struct ConfigHandleImpl {
    test::Config item;
    std::string error;
    std::vector<uint8_t> encoded_data;
};

// Helper to create error message
static char* make_error_msg(const std::string& msg) {
    char* error = new char[msg.size() + 1];
    std::strcpy(error, msg.c_str());
    return error;
}

extern "C" {

ConfigHandle config_decode(const uint8_t* data, size_t len, char** error_msg) {
    if (!data || len == 0) {
        if (error_msg) *error_msg = make_error_msg("Invalid input data");
        return nullptr;
    }
    
    try {
        auto result = test::decode_config_message(data, len);
        
        ConfigHandleImpl* handle = new ConfigHandleImpl;
        handle->item = std::move(result);
        return static_cast<ConfigHandle>(handle);
    } catch (const std::exception& e) {
        if (error_msg) *error_msg = make_error_msg(e.what());
        return nullptr;
    }
}

size_t config_encode(ConfigHandle handle, uint8_t** out_data, char** error_msg) {
    if (!handle) {
        if (error_msg) *error_msg = make_error_msg("Invalid handle");
        return 0;
    }
    
    try {
        ConfigHandleImpl* impl = static_cast<ConfigHandleImpl*>(handle);
        
        impl->encoded_data = test::encode_config_message(impl->item);
        
        // Allocate new buffer for caller
        *out_data = new uint8_t[impl->encoded_data.size()];
        std::memcpy(*out_data, impl->encoded_data.data(), impl->encoded_data.size());
        
        return impl->encoded_data.size();
    } catch (const std::exception& e) {
        if (error_msg) *error_msg = make_error_msg(e.what());
        return 0;
    }
}

void config_free(ConfigHandle handle) {
    delete static_cast<ConfigHandleImpl*>(handle);
}

void config_free_data(uint8_t* data) {
    delete[] data;
}

void config_free_error(char* error_msg) {
    delete[] error_msg;
}

// TODO: Implement config_get_host
// TODO: Implement config_get_port
// TODO: Implement config_get_enablessl
// TODO: Implement config_get_timeout
// TODO: Implement config_get_maxretries

} // extern "C"
