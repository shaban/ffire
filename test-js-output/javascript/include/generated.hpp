// Code generated by ffire. DO NOT EDIT.

#ifndef TEST_H
#define TEST_H

#include <cstdint>
#include <cstring>
#include <string>
#include <vector>
#include <optional>
#include <stdexcept>

namespace test {

struct Config;

struct Config {
    std::string Host;
    int32_t Port;
    bool EnableSSL;
    float Timeout;
    int32_t MaxRetries;
};

// Binary encoder for wire format
class Encoder {
public:
    std::vector<uint8_t> buffer;

    void write_byte(uint8_t b) { buffer.push_back(b); }

    void write_bool(bool v) { buffer.push_back(v ? 0x01 : 0x00); }

    void write_int8(int8_t v) { buffer.push_back(static_cast<uint8_t>(v)); }

    void write_int16(int16_t v) {
        uint16_t u = static_cast<uint16_t>(v);
        buffer.push_back(static_cast<uint8_t>(u));
        buffer.push_back(static_cast<uint8_t>(u >> 8));
    }

    void write_int32(int32_t v) {
        uint32_t u = static_cast<uint32_t>(v);
        buffer.push_back(static_cast<uint8_t>(u));
        buffer.push_back(static_cast<uint8_t>(u >> 8));
        buffer.push_back(static_cast<uint8_t>(u >> 16));
        buffer.push_back(static_cast<uint8_t>(u >> 24));
    }

    void write_int64(int64_t v) {
        uint64_t u = static_cast<uint64_t>(v);
        buffer.push_back(static_cast<uint8_t>(u));
        buffer.push_back(static_cast<uint8_t>(u >> 8));
        buffer.push_back(static_cast<uint8_t>(u >> 16));
        buffer.push_back(static_cast<uint8_t>(u >> 24));
        buffer.push_back(static_cast<uint8_t>(u >> 32));
        buffer.push_back(static_cast<uint8_t>(u >> 40));
        buffer.push_back(static_cast<uint8_t>(u >> 48));
        buffer.push_back(static_cast<uint8_t>(u >> 56));
    }

    void write_float32(float v) {
        uint32_t u;
        std::memcpy(&u, &v, sizeof(float));
        write_int32(static_cast<int32_t>(u));
    }

    void write_float64(double v) {
        uint64_t u;
        std::memcpy(&u, &v, sizeof(double));
        write_int64(static_cast<int64_t>(u));
    }

    void write_string(const std::string& s) {
        uint16_t len = static_cast<uint16_t>(s.size());
        buffer.push_back(static_cast<uint8_t>(len));
        buffer.push_back(static_cast<uint8_t>(len >> 8));
        buffer.insert(buffer.end(), s.begin(), s.end());
    }

    // Bulk write methods for array optimization
    void write_bulk_int8(const std::vector<int8_t>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size());
    }

    void write_bulk_int16(const std::vector<int16_t>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 2);
    }

    void write_bulk_int32(const std::vector<int32_t>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 4);
    }

    void write_bulk_int64(const std::vector<int64_t>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 8);
    }

    void write_bulk_float32(const std::vector<float>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 4);
    }

    void write_bulk_float64(const std::vector<double>& arr) {
        if (arr.empty()) return;
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(arr.data());
        buffer.insert(buffer.end(), ptr, ptr + arr.size() * 8);
    }
};

// Binary decoder for wire format
class Decoder {
public:
    const uint8_t* data;
    size_t size;
    size_t pos = 0;

    Decoder(const uint8_t* d, size_t s) : data(d), size(s) {}
    Decoder(const std::vector<uint8_t>& v) : data(v.data()), size(v.size()) {}

    void check_remaining(size_t needed) {
        if (pos + needed > size) {
            throw std::runtime_error("insufficient data for decode");
        }
    }

    bool read_bool() {
        check_remaining(1);
        return data[pos++] != 0x00;
    }

    int8_t read_int8() {
        check_remaining(1);
        return static_cast<int8_t>(data[pos++]);
    }

    int16_t read_int16() {
        check_remaining(2);
        uint16_t u = static_cast<uint16_t>(data[pos]) |
                     (static_cast<uint16_t>(data[pos + 1]) << 8);
        pos += 2;
        return static_cast<int16_t>(u);
    }

    int32_t read_int32() {
        check_remaining(4);
        uint32_t u = static_cast<uint32_t>(data[pos]) |
                     (static_cast<uint32_t>(data[pos + 1]) << 8) |
                     (static_cast<uint32_t>(data[pos + 2]) << 16) |
                     (static_cast<uint32_t>(data[pos + 3]) << 24);
        pos += 4;
        return static_cast<int32_t>(u);
    }

    int64_t read_int64() {
        check_remaining(8);
        uint64_t u = static_cast<uint64_t>(data[pos]) |
                     (static_cast<uint64_t>(data[pos + 1]) << 8) |
                     (static_cast<uint64_t>(data[pos + 2]) << 16) |
                     (static_cast<uint64_t>(data[pos + 3]) << 24) |
                     (static_cast<uint64_t>(data[pos + 4]) << 32) |
                     (static_cast<uint64_t>(data[pos + 5]) << 40) |
                     (static_cast<uint64_t>(data[pos + 6]) << 48) |
                     (static_cast<uint64_t>(data[pos + 7]) << 56);
        pos += 8;
        return static_cast<int64_t>(u);
    }

    float read_float32() {
        uint32_t u = static_cast<uint32_t>(read_int32());
        float f;
        std::memcpy(&f, &u, sizeof(float));
        return f;
    }

    double read_float64() {
        uint64_t u = static_cast<uint64_t>(read_int64());
        double d;
        std::memcpy(&d, &u, sizeof(double));
        return d;
    }

    std::string read_string() {
        check_remaining(2);
        uint16_t len = static_cast<uint16_t>(data[pos]) |
                       (static_cast<uint16_t>(data[pos + 1]) << 8);
        pos += 2;
        check_remaining(len);
        std::string s(reinterpret_cast<const char*>(data + pos), len);
        pos += len;
        return s;
    }

    uint16_t read_array_length() {
        check_remaining(2);
        uint16_t len = static_cast<uint16_t>(data[pos]) |
                       (static_cast<uint16_t>(data[pos + 1]) << 8);
        pos += 2;
        return len;
    }
};

// Encode Config to binary wire format
inline std::vector<uint8_t> encode_config_message(const Config& value) {
    Encoder enc;
    enc.write_string(value.Host);
    enc.write_int32(value.Port);
    enc.write_bool(value.EnableSSL);
    enc.write_float32(value.Timeout);
    enc.write_int32(value.MaxRetries);
    return enc.buffer;
}

// Decode Config from binary wire format
inline Config decode_config_message(const uint8_t* data, size_t size) {
    Decoder dec(data, size);
    Config result;
    result.Host = dec.read_string();
    result.Port = dec.read_int32();
    result.EnableSSL = dec.read_bool();
    result.Timeout = dec.read_float32();
    result.MaxRetries = dec.read_int32();
    return result;
}

inline Config decode_config_message(const std::vector<uint8_t>& data) {
    return decode_config_message(data.data(), data.size());
}

} // namespace test

#endif // TEST_H
